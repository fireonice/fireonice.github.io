<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/01/25/RabbitMQ/"/>
      <url>/2022/01/25/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>消息队列</p><p>流量削峰</p><p>应用解耦：上游只需发送消息</p><p>异步处理：异步处理回调消息</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><p>生产者、交换机、队列、消费者</p><h2 id="六大核心模式"><a href="#六大核心模式" class="headerlink" title="六大核心模式"></a>六大核心模式</h2><p>简单、工作队列、发布订阅、路由、主题、发布确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223147422.png" alt="image-20220125223147422"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>Broker</strong></p><p><strong>Virtual host</strong></p><p><strong>Connection</strong></p><p><strong>Channel</strong></p><p><strong>Exchange</strong></p><p><strong>Queue</strong></p><p><strong>Binding</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223250580.png" alt="image-20220125223250580"></p><h1 id="2、核心"><a href="#2、核心" class="headerlink" title="2、核心"></a>2、核心</h1><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><strong>轮询</strong>分发消息</p><p>消息应答：消费者是否处理消息</p><p>自动应答、手动应答（批量应答）</p><p>消息自动重新入队</p><p>rabbitmq持久化：队列持久化、消息持久化</p><p>不公平分发</p><p>预取值：通道中堆积消息个数</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>单个确认发布</p><p>批量确认发布</p><p>异步确认发布：异步通知——交换机确认收到、未确认收到</p><p>并发链路式队列——发消息和监听线程之间传递消息——本质：map</p><p>1、发送消息时进记录队列</p><p>2、确认回调再删除</p><p>未删除的——未确认消息</p><p>跳表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224155047.png" alt="image-20220125224155047"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224048175.png" alt="image-20220125224048175"></p><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p><p>无名 exchange</p><p>临时队列</p><p>bindings</p><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h3><p>广播：路由key为空</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224517818.png" alt="image-20220125224517818"></p><h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>发送路由key对应队列——无论队列个数</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224644373.png" alt="image-20220125224644373"></p><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p>没有*和#：fanout、direct模式</p><p>*(星号)可以代替一个单词</p><p>#(井号)可以替代零个或多个单词</p><h1 id="3、高级"><a href="#3、高级" class="headerlink" title="3、高级"></a>3、高级</h1><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>发送异常消息——进入死信队列</p><p>死信队列的来源：</p><p>消息 TTL 过期</p><p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p><p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224938734.png" alt="image-20220125224938734"></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延迟队列——消息过期进入死信队列</p><p>存放需要在指定时间被处理的元素的队列</p><p>应用场景</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225016545.png" alt="image-20220125225016545"></p><p>缺陷：ttl不灵活</p><h3 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h3><p>QC队列不设置过期时间，由生产者设置ttl</p><p>缺陷：队列FIFO</p><h3 id="基于插件优化"><a href="#基于插件优化" class="headerlink" title="基于插件优化"></a>基于插件优化</h3><p>基于插件的交换机：在交换机处延迟</p><p>延迟交换机：类型、延迟类型（直接：路由key固定）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225256329.png" alt="image-20220125225256329"></p><p>其他延时队列：</p><p>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz，或者利用 kafka 的时间轮。RabbitMQ安全，完善。</p><h2 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h2><h3 id="交换机回调"><a href="#交换机回调" class="headerlink" title="交换机回调"></a>交换机回调</h3><p>交换机确认消息是否收到</p><p>写回调方法、注入</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225816018.png" alt="image-20220125225816018"></p><p>生产者只管给交换机消息，只接受交换机的接收结果</p><p>路由错误无法接收结果</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>无法路由时，消息回退给交换机，通知生产者</p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>无法投递的消息给备份交换机</p><p>没有什么是加一层解决不了的</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230021103.png" alt="image-20220125230021103"></p><p>备份优先级更高</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等性：重复提交</p><p>消费者ack中断，造成重新消费</p><p>解决思路：生成全局唯一id，消费之前判断是否被消费过</p><p>1、唯一ID + 指纹码机制（数据库）</p><p>2、Redis原子性：利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>设置优先级参数</p><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>消息存到磁盘中，消费者从磁盘取</p><p>内存占比非常小，取消息慢</p><h1 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h1><h2 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125221757500.png" alt="image-20220125221757500"></p><h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125222245390.png" alt="image-20220125222245390"></p><h2 id="高负载均衡"><a href="#高负载均衡" class="headerlink" title="高负载均衡"></a>高负载均衡</h2><p><strong>nginx、gateway</strong>、Haproxy等集群，进行反向代理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230327710.png" alt="image-20220125230327710"></p><p>以下暂用不到</p><h2 id="Shovel集群"><a href="#Shovel集群" class="headerlink" title="Shovel集群"></a>Shovel集群</h2><p>远程同步</p><h2 id="Federation-联邦集群"><a href="#Federation-联邦集群" class="headerlink" title="Federation 联邦集群"></a>Federation 联邦集群</h2><p>Federation Exchange、Federation Queue</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/acae23ba5952abdce66bb65e8b00a5a0.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ</title>
      <link href="/2022/01/24/ActiveMQ/"/>
      <url>/2022/01/24/ActiveMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221656632.png" alt="image-20220124221656632"></p><p>解耦、异步、削峰</p><p>分布式系统</p><p>只要消息发送，尽量异步</p><p>只要解耦，尽量引入消息中间件</p><h2 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h2><p>JMS编码架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221810182.png" alt="image-20220124221810182"></p><p>原生API：</p><p>生产者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息生产者</p><p>消息生产者发送消息</p><p>（1）创建消息</p><p>（2）通过生产者发送</p><p>关闭资源（倒序：生产者、session、连接）</p><p>消费者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息消费者</p><p>消费生产者接收消息——接收消息（一直型、定时型）、消息类型要一致</p><p>关闭资源（倒序：消费者、session、连接）</p><p>1、receive</p><p>2、监听</p><p>队列同时监听：轮询</p><p>主题：先订阅再有生产消息</p><h2 id="3、JMS"><a href="#3、JMS" class="headerlink" title="3、JMS"></a>3、JMS</h2><p>JavaEE</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222038405.png" alt="image-20220124222038405"></p><p>JMS：java消息服务</p><p>消息头</p><p>消息体</p><p>消息属性</p><p>可靠性：持久化、事务、签收、集群</p><h2 id="4、Broker"><a href="#4、Broker" class="headerlink" title="4、Broker"></a>4、Broker</h2><h2 id="5、spring-boot整合"><a href="#5、spring-boot整合" class="headerlink" title="5、spring boot整合"></a>5、spring boot整合</h2><p>间隔定投</p><p>注解监听</p><h2 id="6、传输协议"><a href="#6、传输协议" class="headerlink" title="6、传输协议"></a>6、传输协议</h2><p>种类</p><p>NIO + 多协议</p><h2 id="7、消息存储和持久化"><a href="#7、消息存储和持久化" class="headerlink" title="7、消息存储和持久化"></a>7、消息存储和持久化</h2><p>AMQ</p><p>KahaDB：事务日志 + 索引文件</p><p>Db.log：存储消息、Db.data：B树索引、Lock：文件锁</p><p>LevelDB：基于文件的本地数据库：redis aof</p><p>JDBC + Mysql：</p><p>建库，自动建表：消息表、订阅关系表、记录master表</p><p>JDBC With Journal：</p><p>存到高速缓存日志，减少数据库压力</p><h2 id="8、多节点集群"><a href="#8、多节点集群" class="headerlink" title="8、多节点集群"></a>8、多节点集群</h2><p>Zookeeper和Replicated LevelDB集群</p><p>原理：对外暴露master</p><p>主从复制 + Zookeeper集群</p><p>已被舍弃</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222731107.png" alt="image-20220124222731107"></p><h2 id="9、高级特性、面试考点"><a href="#9、高级特性、面试考点" class="headerlink" title="9、高级特性、面试考点"></a>9、高级特性、面试考点</h2><p>异步投递：</p><p>发送是否成功：写回调函数：成功、失败的信息</p><p>延时投递和定时投递：消息头属性中设置</p><p>分发策略</p><p>消息重试机制：消息侧回滚、消费侧没有commit等</p><p>有毒消息：重发超过6次，放到DLQ（死信队列）</p><p>死信队列：查看出错消息，人工干预修复，可自定义</p><p>防止重复调用，幂等性：数据库主键、redis key</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security</title>
      <link href="/2022/01/24/Spring%20Security/"/>
      <url>/2022/01/24/Spring%20Security/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h2><p>认证</p><p>授权</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220153579.png" alt="image-20220124220153579"></p><h2 id="2、web权限"><a href="#2、web权限" class="headerlink" title="2、web权限"></a>2、web权限</h2><p>查询数据库认证</p><p>自定义登录页面</p><p>方法注解</p><p>注销</p><p>原理分析</p><p>CSRF</p><h2 id="3、微服务权限"><a href="#3、微服务权限" class="headerlink" title="3、微服务权限"></a>3、微服务权限</h2><p>流程</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220433500.png" alt="image-20220124220433500"></p><p>数据库分表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220446710.png" alt="image-20220124220446710"></p><p>JWT：JWT 头、内容、签名哈希</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220917745.png" alt="image-20220124220917745"></p><h2 id="4、源码解析"><a href="#4、源码解析" class="headerlink" title="4、源码解析"></a>4、源码解析</h2><p><strong>Spring Security</strong> 采取<strong>过滤链</strong>实现认证与授权</p><p>认证流程</p><p>权限访问流程</p><p>请求间共享认证信息</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2022/01/24/nginx/"/>
      <url>/2022/01/24/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>nginx</p><p>正向代理</p><p>反向代理</p><p>负载均衡</p><p>动静分离</p><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>高可用集群（主从模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215235206.png" alt="image-20220124215235206"></p><p>高可用集群（双主模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215307904.png" alt="image-20220124215307904"></p><h2 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h2><p><img src="https://img-blog.csdnimg.cn/20191103213303224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hcml0aC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="Nginx 整体架构"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2022/01/24/zookeeper/"/>
      <url>/2022/01/24/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="1、入门"><a href="#1、入门" class="headerlink" title="1、入门"></a>1、入门</h2><p>概述：工作机制</p><p>数据结构：ZNode 树型文件系统</p><p>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下</p><p>线、软负载均衡等</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h2 id="3、集群"><a href="#3、集群" class="headerlink" title="3、集群"></a>3、集群</h2><p>选举机制：</p><p>第一次启动</p><p>非第一次启动：任期id——事务id——id</p><p>节点类型：</p><p>持久、短暂、有序号、无序号</p><p>监听器</p><p>写数据原理：</p><p>发给leader</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213707456.png" alt="image-20220124213707456"></p><p>发给follower</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213720276.png" alt="image-20220124213720276"></p><h2 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h2><p>服务器动态上下线</p><p>分布式锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213847011.png" alt="image-20220124213847011"></p><p>Curator框架实现分布式锁</p><h2 id="5、源码"><a href="#5、源码" class="headerlink" title="5、源码"></a>5、源码</h2><p>选举机制：第一次、非第一次</p><p>分布式一致性：</p><p>Paxos算法</p><p>ZAB协议：消息广播、崩溃恢复</p><p>异常发生——leader选举 + 数据恢复</p><p>数据恢复——一个follower所有事务提交之后才变为follower</p><p>CAP理论：保证CP</p><p>持久化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214406672.png" alt="image-20220124214406672"></p><p>序列化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214429678.png" alt="image-20220124214429678"></p><p>服务端初始化源码-启动脚本</p><p>初始化-解析参数</p><p>初始化-过期快照删除</p><p>初始化-通信初始化</p><p>服务端加载数据源码</p><p>选举-选举准备</p><p>选举-选举执行</p><p>Follower 和 Leader 状态同步源码</p><p>状态同步细节</p><p>Leader启动</p><p>Follower启动</p><p>客户端启动</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214747431.png" alt="image-20220124214747431"></p><p>选举</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo</title>
      <link href="/2022/01/24/dubbo/"/>
      <url>/2022/01/24/dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>分布式系统演变</p><p>RPC原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212540495.png" alt="image-20220124212540495"></p><p>dubbo核心原理</p><p>监控中心</p><h2 id="2、dubbo配置"><a href="#2、dubbo配置" class="headerlink" title="2、dubbo配置"></a>2、dubbo配置</h2><h2 id="3、高可用"><a href="#3、高可用" class="headerlink" title="3、高可用"></a>3、高可用</h2><p>zookeeper</p><p>集群负载均衡</p><p>hystrix、服务熔断、服务降级</p><h2 id="4、原理"><a href="#4、原理" class="headerlink" title="4、原理"></a>4、原理</h2><h3 id="RPC原理："><a href="#RPC原理：" class="headerlink" title="RPC原理："></a>RPC原理：</h3><p>一次完整的RPC调用流程（同步调用，异步另说）如下： </p><p><strong>1）服务消费方（client）调用以本地调用方式调用服务；</strong> </p><p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p><p>3）client stub找到服务地址，并将消息发送到服务端； </p><p>4）server stub收到消息后进行解码； </p><p>5）server stub根据解码结果调用本地的服务； </p><p>6）本地服务执行并将结果返回给server stub； </p><p>7）server stub将返回结果打包成消息并发送至消费方； </p><p>8）client stub接收到消息，并进行解码； </p><p><strong>9）服务消费方得到最终结果。</strong></p><p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h3 id="netty通信原理"><a href="#netty通信原理" class="headerlink" title="netty通信原理"></a>netty通信原理</h3><p>BIO</p><p>NIO</p><h3 id="dubbo原理"><a href="#dubbo原理" class="headerlink" title="dubbo原理"></a>dubbo原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212904106.png" alt="image-20220124212904106"></p><p>框架设计</p><p>启动解析、加载配置信息</p><p>服务暴露</p><p>服务引用</p><p>服务调用</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch</title>
      <link href="/2022/01/24/elasticsearch/"/>
      <url>/2022/01/24/elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="入门-HTTP"><a href="#入门-HTTP" class="headerlink" title="入门-HTTP"></a>入门-HTTP</h1><h1 id="入门-JavaAPI"><a href="#入门-JavaAPI" class="headerlink" title="入门-JavaAPI"></a>入门-JavaAPI</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>进阶：文档、字段、映射、分片、副本、分配</p><p>系统架构：</p><p>选举主节点，master调度管理集群</p><p>P1P2P3分片、R2R0R1副本，不在一个机器上</p><p>每一个分片就是底层的LUCENE的索引</p><p>分布式集群：</p><p>故障转移、水平扩容、应对故障</p><p>路由计算 &amp; 分片控制</p><p>数据写流程</p><p>数据读流程</p><p>更新流程 &amp; 批量操作流程</p><p>倒排索引</p><p>文档搜索</p><p>文档刷新 &amp; 文档刷写 &amp; 文档合并</p><p>文档分析</p><p>文档处理</p><p>文档展示-Kibana</p><h1 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h1><p>SpringData-整体介绍</p><p>文档搜索</p><p>Spark streaming</p><p>Flink</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>硬件选择</p><p>分片策略</p><p>路由选择</p><p>写入速度优化</p><p>重要配置</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>为什么使用elasticsearch</p><p>Master选举</p><p>集群脑裂</p><p>索引文档的流程</p><p>更新和删除文档</p><p>搜索流程</p><p>Linux设置部署优化</p><p>GC方面，注意</p><p>上亿数据的聚合实现</p><p>并发情况下，如何保证读写—致</p><p>监控</p><p>字典树</p><p>集群、节点、索引、文档、类型</p><p>倒排索引</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>为什么使用es</p><p>概念：集群、节点、索引、文档、类型</p><p>基本操作：索引、更新、删除、搜索</p><p>集群：master选举、脑裂</p><p>字典树</p><p>倒排索引</p><p>优化：linux部署设置、GC、</p><p>海量数据：如何聚合</p><p>高并发：如何保证读写一致</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/01/24/docker/"/>
      <url>/2022/01/24/docker/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/docker%E6%80%BB%E7%BB%93.png" alt="docker总结"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/01/24/redis/"/>
      <url>/2022/01/24/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h2><p>Memcache</p><p>Redis</p><p>MongoDB</p><h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>单线程+多路IO复用</p><p>应用场景：</p><p>缓存、session共享、持久化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124203929901.png" alt="image-20220124203929901"></p><h2 id="五大常用数据类型"><a href="#五大常用数据类型" class="headerlink" title="五大常用数据类型"></a>五大常用数据类型</h2><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><h2 id="三大新数据类型"><a href="#三大新数据类型" class="headerlink" title="三大新数据类型"></a>三大新数据类型</h2><h2 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h2><p>网络连接：心跳检测、连接时长</p><p>通用：日志级别、库</p><p>存储策略</p><h2 id="reids的发布和订阅"><a href="#reids的发布和订阅" class="headerlink" title="reids的发布和订阅"></a>reids的发布和订阅</h2><p>Bitmaps：统计</p><p>HyperLogLog：基数计算：不重复数据个数的计算</p><p>Geographic：地理</p><h2 id="Jedis、RedisTemplate"><a href="#Jedis、RedisTemplate" class="headerlink" title="Jedis、RedisTemplate"></a>Jedis、RedisTemplate</h2><h2 id="事务、锁机制、秒杀"><a href="#事务、锁机制、秒杀" class="headerlink" title="事务、锁机制、秒杀"></a>事务、锁机制、秒杀</h2><p>事务：</p><p>Multi、Exec、discard</p><p>悲观锁、乐观锁</p><p>监视key</p><p>特点：单独的隔离操作、没有隔离级别的概念、不保证原子性</p><p>秒杀：</p><p>乐观锁 + 连接池 + LUA脚本（原子化）  解决库存遗留问题</p><h2 id="持久化RDB、AOF"><a href="#持久化RDB、AOF" class="headerlink" title="持久化RDB、AOF"></a>持久化RDB、AOF</h2><p>RDB：临时文件 –&gt; 覆盖</p><p>AOF：只记录写的操作，只能追加，redis读取这些操作重写构建数据</p><p>写操作追加到缓存区，根据策略进行持久化同步，根据重写策略进行重写压缩</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>一主二仆</p><p>薪火相传：分组传递</p><p>宕机上位</p><p>连接时：全量复制</p><p>同步时：增量复制</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124205643714.png" alt="image-20220124205643714"></p><p>主从复制原理</p><p>哨兵模式：</p><p>Master down ，sentinel自动监控 —&gt; 选举某从机作为主机</p><p>Master 再次上线后 变为从机</p><p>选举规则：</p><p>1、Priority最小</p><p>2、偏移量最全</p><p>3、Runid最小的（随机生成）</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>无中心化</p><p>集群节点的插槽计算：计算key所属的插槽，平均分摊压力</p><p>哈希槽分区</p><h2 id="应用问题"><a href="#应用问题" class="headerlink" title="应用问题"></a>应用问题</h2><p>缓存穿透</p><p>解决方案：</p><p>缓存空值（设置过期时间）、设置白名单（bitmaps）</p><p>布隆过滤器（底层bitmap）、实时监控redis（设置黑名单）</p><p>缓存击穿</p><p>解决方案：</p><p>预先设置热门key（增加时长）、实时调整（频繁访问key增加时长）</p><p>锁（先上锁，查完数据库放锁）</p><p>缓存雪崩</p><p>构建多层缓存（多级缓存处理）、锁和队列（不适合高并发）</p><p>设置过期标志（更新时长）、分散缓存失效时间（过期时间不同）</p><p>分布式锁</p><p>reids分布式锁：</p><p>setnx  同时设置过期时间</p><p>Redisson</p><p>总结：</p><p>Uuid + 过期时间 + 加锁</p><p>Lua释放锁（uuid比较）</p><h2 id="Redis6新功能"><a href="#Redis6新功能" class="headerlink" title="Redis6新功能"></a>Redis6新功能</h2><p>Acl用户权限</p><p>Io多线程：网络数据读写和协议解析</p><p>工具支持cluster</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud + SpringCloud Alibaba分布式集群总结</title>
      <link href="/2022/01/24/SpringCoud%20Alibaba/"/>
      <url>/2022/01/24/SpringCoud%20Alibaba/</url>
      
        <content type="html"><![CDATA[<h2 id="eureka："><a href="#eureka：" class="headerlink" title="eureka："></a>eureka：</h2><p>单机eureka、集群eureka</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="zookeeper："><a href="#zookeeper：" class="headerlink" title="zookeeper："></a>zookeeper：</h2><p>linux docker部署zookeeper，配置注册地址</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="consul："><a href="#consul：" class="headerlink" title="consul："></a>consul：</h2><p>命令本地启动consul，8500端口页面</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="Ribbon："><a href="#Ribbon：" class="headerlink" title="Ribbon："></a>Ribbon：</h2><p>Irule配置或自定义负载均衡算法，@Ribbonclient配置调用的服务和算法</p><p>手写轮询算法，CAS锁</p><h2 id="Openfeign："><a href="#Openfeign：" class="headerlink" title="Openfeign："></a>Openfeign：</h2><p>接口注解调用，默认支持ribbon自带负载均衡</p><p>ribbon超时控制，日志显示</p><h2 id="Hystrix："><a href="#Hystrix：" class="headerlink" title="Hystrix："></a>Hystrix：</h2><p>服务降级：@HystrixCommand，调用中出现错误、超时、宕机等，启用兜底方法，fallback方法分离</p><p>服务熔断：配置熔断情况，时间窗口，请求阈值，错误百分比阈值等，half open</p><p>hystrixDashboard可视化监控，监控服务访问</p><h2 id="Zuul、Gataway："><a href="#Zuul、Gataway：" class="headerlink" title="Zuul、Gataway："></a>Zuul、Gataway：</h2><p>路由转发、断言匹配、执行过滤器链，支持负载均衡</p><p>作为中转站进行路由映射，过滤器生命周期pre、post，常用过滤器：请求头、参数匹配等，自定义过滤器</p><h2 id="Config："><a href="#Config：" class="headerlink" title="Config："></a>Config：</h2><p>服务端实时获取Github配置，文件配置映射，生产模式配置，客户端父子配置文件，设置文件映射和配置中心</p><p>Post请求动态刷新客户端配置</p><h2 id="Bus："><a href="#Bus：" class="headerlink" title="Bus："></a>Bus：</h2><p>支持RabbitMQ和kafka，自动进行消息监听配置中心变化，全局订阅实现配置更新，称为消息总线</p><p>加入bus依赖，rabbitmq配置，自动监听，一次发送处处生效</p><p>定点刷新，post附带服务端端口号</p><h2 id="Stream："><a href="#Stream：" class="headerlink" title="Stream："></a>Stream：</h2><p>统一底层差异，设置生产者、消费者、监听进行消息发送</p><p>分组消费，配置group，支持消息持久化</p><h2 id="Sleuth："><a href="#Sleuth：" class="headerlink" title="Sleuth："></a>Sleuth：</h2><p>zipkin可视化监控，本地命令启动，全局链路id关联调用链路</p><p>配置zikpin地址，采样率设置</p><h2 id="Nacos："><a href="#Nacos：" class="headerlink" title="Nacos："></a>Nacos：</h2><p>nacos服务注册中心，本地命令启动，支持CP、AP切换</p><p>作为配置中心，加入配置匹配格式，配置名称空间，分组等进行匹配，自带动态刷新</p><p>namespace：环境、group：分组，不同微服务模块、service：微服务模块、cluster：集群，杭州虚拟划分，实现容灾，instance：微服务实例</p><p>持久化配置，默认嵌入式数据库derby，连接到mysql即可</p><p>nacos集群，linux docker部署，请求到Nginx集群，nacos集群，底层db集群</p><h2 id="Sentinel："><a href="#Sentinel：" class="headerlink" title="Sentinel："></a>Sentinel：</h2><p>sentinel可视化控制台，本地命令启动，yaml配置地址，默认懒加载</p><p>流控规则，</p><p>统计规则：慢调用比例，异常比例、异常数，</p><p>流控模式：直接、关联，关联的资源达到阈值限流自己、链路，统计指定资源到当前资源，对请求来源限流，</p><p>流控效果：直接、预热，阈值从冷启动因子经过预热时长后达到正常阈值，秒杀应用、排队等待，匀速排队，阈值必须为qps，处理间隔突发的流量</p><p>服务降级，降级策略：RT平均响应时间、异常比例、异常数，分钟统计，支持半开状态</p><p>热点key限流，支持参数索引，排除特殊参数。系统规则，全局限流</p><p>@SentinelResource，blockhandler：限流兜底方法，自定义限流处理逻辑，代码分离</p><p>服务熔断，整合ribbon，加上fallback即可，整合feign，消费者侧接口注解处fallback</p><p>规则持久化，yaml配置datasource，地址指向nacos，文件匹配</p><h2 id="seata："><a href="#seata：" class="headerlink" title="seata："></a>seata：</h2><p>ID+三组件，TC全局事务协调器，TM事务提交回滚，RM分支事务、分支注册、状态汇报等</p><p>seata service本机命令启动，配置文件，数据库，nacos地址</p><p>mysql建表，seata事务表，业务数据库回滚日志表</p><p>微服务配置，文件nacos匹配，yaml配置，seata代理数据库，@GlobalTransactional，异常回滚</p><p>执行流程：一阶段加载：解析sql语句找到业务数据保存为before image，执行业务sql，保存after iamge，生成行锁，二阶段提交：顺利提交，seata删除快照和行锁，完成数据清理即可，二阶段回滚：回滚执行的业务sql，通过一阶段回滚日志进行反向补偿，用before image还原业务数据，脏写校验，对比当前和after image</p><h2 id="分布式全局唯一id："><a href="#分布式全局唯一id：" class="headerlink" title="分布式全局唯一id："></a>分布式全局唯一id：</h2><p>UUID，入库性能差、数据库自增主键，B+树索引分裂、reids集群增长步长，需要维护，雪花算法</p><p><img src="https://z3.ax1x.com/2021/07/27/WhcJM9.png" alt="WhcJM9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud Alibaba </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
