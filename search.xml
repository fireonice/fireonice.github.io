<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>谷粒商城——分布式基础-全栈开发篇</title>
      <link href="/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1、写在前面"><a href="#1、写在前面" class="headerlink" title="1、写在前面"></a>1、写在前面</h1><p>仿京东商城大型分布式架构电商平台：微服务架构+分布式+全栈+集群+部署+自动化运维+可视化CICD</p><p>Gitee仓库：<a href="https://gitee.com/namdev/gulimall">https://gitee.com/namdev/gulimall</a></p><p>后台接口文档：<a href="https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd">https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd</a></p><h1 id="2、架构"><a href="#2、架构" class="headerlink" title="2、架构"></a>2、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201439633.png" alt="image-20220212201439633"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201228064.png" alt="image-20220212201228064"></p><h1 id="3、基础环境"><a href="#3、基础环境" class="headerlink" title="3、基础环境"></a>3、基础环境</h1><p>linux、docker</p><p>数据库</p><p>人人后台</p><p>分布式组件</p><h1 id="4、商品、订单、仓库服务后台"><a href="#4、商品、订单、仓库服务后台" class="headerlink" title="4、商品、订单、仓库服务后台"></a>4、商品、订单、仓库服务后台</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211040144.png" alt="image-20220212211040144"></p><h2 id="pms库"><a href="#pms库" class="headerlink" title="pms库"></a>pms库</h2><p>Attr：属性表</p><p>Attr_group：属性分组表</p><p>Attr_attrgroup_relation：属性分组关联表</p><p>Product_attr_value：商品id属性值表</p><p>Spu_info：商品spu</p><p>Sku_info：商品sku</p><p>Sku_images：商品sku图片</p><p>Sku_sale_attr_values：商品sku销售属性值</p><p>三级分类——属性分组——属性</p><p>属性——商品（spu）属性集——商品型号（sku）属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211136464.png" alt="image-20220212211136464"></p><h2 id="保存商品"><a href="#保存商品" class="headerlink" title="保存商品"></a>保存商品</h2><p>Spu_info：基本信息</p><p>Spu_info_desc：id + 描述图片</p><p>Spu_images：id + 图片集</p><p>Product_attr_value：spu规格参数 spuid + 属性值</p><p>Spu_bounds：商品积分 （sms库）</p><p>Sku_info：sku基本信息 + spuid</p><p>Sku_images：skuid + sku图片信息</p><p>Sku_sale_attr_value：sku销售属性 skuid + 属性值</p><p>Sku优惠满减信息（sms库）：skuid</p><p>Sku_ladder：打折表</p><p>Sku_full_reduction：满减表</p><p>Member_price：会员价格表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211157512.png" alt="image-20220212211157512"></p><h2 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h2><p>单表、多表、多库、远程调用、属性拷贝等暂时省略</p><h1 id="5、jsr303校验"><a href="#5、jsr303校验" class="headerlink" title="5、jsr303校验"></a>5、jsr303校验</h1><p>开启校验（错误返回） + bean校验注解</p><p>统一异常处理</p><p>枚举类</p><p>jsr303分组校验</p><p>jsr303自定义校验注解</p><h1 id="5、object"><a href="#5、object" class="headerlink" title="5、object"></a>5、object</h1><p>1.PO(persistant object) 持久对象 </p><p>PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 </p><p>2.DO（Domain Object）领域对象就是从现实世界中抽象出来的有形或无形的业务实体。 </p><p>3.TO(Transfer Object) 数据传输对象</p><p>不同的应用程序之间传输的对象 </p><p>4.DTO（Data Transfer Object）数据传输对象</p><p>这个概念来源于 J2EE 的设计模式，原来的目的是为了 EJB 的分布式应用提供粗粒度的 数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。 </p><p>5.VO(value object) 值对象 </p><p>通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已。但应是抽象出 的业务对象 , 可以和表对应 , 也可以不 , 这根据业务的需要 。用 new 关键字创建，由 GC 回收的。 View object：视图对象； 接受页面传递来的数据，封装对象将业务处理完成的对象，封装成页面要用的数据 </p><p><strong>6.BO(business object)</strong> <strong>业务对象</strong> </p><p>从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 </p><p>java 对 象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。business object: 业务对象主要作 用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简 历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经 历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。</p><p>7.POJO(plain ordinary java object) 简单无规则 java 对象 </p><p>传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护 数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增 加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及 setter 和 getter 方法！。POJO 是 DO/DTO/BO/VO 的统称。 </p><p>8.DAO(data access object) 数据访问对象 </p><p>是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久 层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作.</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——金融业务平台</title>
      <link href="/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/"/>
      <url>/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/</url>
      
        <content type="html"><![CDATA[<h1 id="1、产品架构"><a href="#1、产品架构" class="headerlink" title="1、产品架构"></a>1、产品架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207192011048.png" alt="image-20220207192011048"></p><h1 id="2、业务流程"><a href="#2、业务流程" class="headerlink" title="2、业务流程"></a>2、业务流程</h1><p>1、账户绑定</p><p>（用户表、用户绑定表）</p><p>用户——绑定信息提交（借款、出借）——调用第三方托管平台账户创建（阿里云短信）——绑定完成（异步更新）</p><p>2、申请借款额度</p><p>（用户表、积分表、借款人表、借款人图片表）垂直分表</p><p>提交借款人个人信息（身份证等证件资源：对象存储）——后台系统评估——审核通过——获取额度</p><p>3、借款额度审核</p><p>后台借款额度申请列表——借款人信息——借款额度审核</p><p>4、借款申请</p><p>（借款信息表、积分等级配置表、标的准备表）</p><p>获取借款额度（用户积分）——提交借款申请——获取借款申请状态</p><p>5、借款审核</p><p>后台借款信息列表——借款详情——借款审批</p><p>6、标的管理</p><p>（标的表）</p><p>审核完成——新标的、标的详情、标的列表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207194625467.png" alt="image-20220207194625467"></p><p>7、我要投资</p><p>前端标的列表</p><p>8、充值</p><p>（用户账号表[余额等]、交易流水表）</p><p>注册 + 账户绑定——充值——第三方托管支付——完成（异步修改）</p><p>幂等性保证（重复请求）：判断流水是否存在，存在则退出</p><p>9、投标</p><p>收益根据还款方式：等额本息、等额本金、按期付息到期还本、一次还本付息</p><p>（标的表、标的出借记录表、还款记录表、标的出借回款记录表）标的id</p><p>标的详情——输入金额计算收益——投标支付——完成（异步回调：标的状态、投资流水、金额、标的信息）</p><p>10、放款</p><p>（还款人还款记录表、投资人回款记录表）</p><p>管理平台放款——（1）标的状态和标的平台收益（2）<strong>给借款账号转入金额</strong>（3）增加借款交易流水（4）<strong>解冻并扣除投资人资金</strong>（5）增加投资人交易流水（6）生成借款人还款计划和出借人回款计划</p><p>11、投资列表展示</p><p>后台列表——前台列表——后台还款计划——前台还款计划——前台回款计划</p><p>12、提现和还款</p><p>第三方托管提现</p><p>还款——转出金额——分配转入投资方——流水明细、回款明细</p><p>13、个人中心</p><p>流水明细、用户账号明细</p><p>14、消息队列</p><p>监听消息队列发送短信（充值、绑定、转出等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/27528777bac0634fd778ca60094057b4.png" alt="27528777bac0634fd778ca60094057b4"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——MongoDB、业务流程</title>
      <link href="/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/"/>
      <url>/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<h1 id="1、架构"><a href="#1、架构" class="headerlink" title="1、架构"></a>1、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222116806.png" alt="image-20220206222116806"></p><h1 id="2、MongoDB"><a href="#2、MongoDB" class="headerlink" title="2、MongoDB"></a>2、MongoDB</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于分布式文件存储的开源数据库系统</p><p>字段值可以包含其他文档，数组及文档数组。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222409680.png" alt="image-20220206222409680"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MongoDB 是一个面向文档存储的数据库</p><p>MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序</p><p>可以通过本地或者网络创建数据镜像，实现高扩展性</p><p>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上，分片</p><p>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>1、网站数据、大数据、缓存</p><p>2、高伸缩性</p><p>3、对象、json数据</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>MongoTemplate</p><p>MongoRepository（SpringData方法定义规范）</p><h1 id="3、预约挂号业务"><a href="#3、预约挂号业务" class="headerlink" title="3、预约挂号业务"></a>3、预约挂号业务</h1><p>1、排班和挂号详情信息——【医院+科室——规则——日期——排班、挂号信息】</p><p>2、确认挂号信息——【就诊人、排班信息】</p><p>3、生成预约挂号订单【就诊人 + 排班 —— 生成订单】</p><p>4、挂号订单支付（微信）【微信支付、订单状态】</p><p>5、取消预约订单【退款、取消订单】</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206221759069.png" alt="image-20220206221759069"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——前后端分离+微服务</title>
      <link href="/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1、MP"><a href="#1、MP" class="headerlink" title="1、MP"></a>1、MP</h1><p>基本流程</p><p>主键自动生成</p><p>自动填充</p><p>乐观锁实现</p><p>select、分页</p><p>delete：逻辑删除、物理删除</p><p>mp性能分析插件</p><p>条件查询Querywrapper</p><h1 id="2、后端1"><a href="#2、后端1" class="headerlink" title="2、后端1"></a>2、后端1</h1><p>json时区</p><p>swagger测试</p><p>统一返回格式</p><p>@requestbody</p><p>统一、指定、自定义异常处理</p><p>日志输出、日志级别</p><h1 id="3、前端1"><a href="#3、前端1" class="headerlink" title="3、前端1"></a>3、前端1</h1><p>es6语法：</p><p>数组解构、对象赋值、模拟字符串、对象方法、箭头函数</p><p>vue指令、组件</p><p>vue生命周期：</p><p>Create、Mounted</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220205230634449.png" alt="image-20220205230634449"></p><p>断点</p><p>Vue路由</p><p>Axios</p><p>Element-ui</p><p>Node.js</p><p>npm</p><p>Babel</p><p>前端模块化</p><p>Webpack</p><p>vue-admin-template、目录结构</p><p>跨域</p><p>路由切换</p><p><strong>开发流程</strong></p><p>服务端渲染技术</p><p>NUST框架</p><h1 id="4、oss、视频点播、短信、微信支付、微信注册"><a href="#4、oss、视频点播、短信、微信支付、微信注册" class="headerlink" title="4、oss、视频点播、短信、微信支付、微信注册"></a>4、oss、视频点播、短信、微信支付、微信注册</h1><p>阿里云对象存储</p><p>阿里云视频点播：上传、播放、删除</p><p>阿里云短信服务</p><p>微信支付</p><p>微信注册</p><h1 id="5、后端2"><a href="#5、后端2" class="headerlink" title="5、后端2"></a>5、后端2</h1><p>nginx</p><p>EasyExcel读写</p><p>Vue tree</p><p>vo</p><p>bean转换</p><p>树形结构：遍历、循环</p><p>路由、隐藏路由、动态路由</p><p>富文本编辑器</p><p>多表联查——SQL</p><p>openfeign、nacos</p><p>远程调用流程：</p><p>1、接口化请求调用</p><p>2、Feign</p><p>3、Hystrix</p><p>4、Ribbon</p><p>5、Httpclient</p><h1 id="6、后端3"><a href="#6、后端3" class="headerlink" title="6、后端3"></a>6、后端3</h1><p>redis缓存：</p><p>Cacheable、Cacheput、Cacheevict</p><p>sso单点登录</p><p>jwt：json web token</p><p>1、jwt头信息</p><p>2、有效载荷</p><p>3、签名哈希</p><p>sso实现：</p><p>1、session复制</p><p>2、Cookie带着唯一key在中redis 查询 </p><p>3、Token：用户信息加密成的字符串（自包含令牌）</p><p>（1）cookie 或者 地址栏</p><p>（2）访问时携带字符串</p><p>Reids过期时间、token过期时间 均可设置过期</p><p>密码加密：</p><p>1、MD5工具类</p><p>2、密码加密和数据库比较</p><p>token解析</p><h1 id="7、前端2"><a href="#7、前端2" class="headerlink" title="7、前端2"></a>7、前端2</h1><p>二维码</p><p>定时器</p><p>token实现：</p><p>(1) 登录返回token</p><p>(2) Token放到cookie中</p><p>(3) 前端拦截器（请求拦截）：判断cookie是否有token，把token放到请求头中</p><p>(4) 根据请求头的token获取用户信息，用户信息放到cookie中</p><p>(5) 显示用户信息</p><p>验证——获得token（放到cookie）——拦截：获取token放到header——调用api获取用户信息（放到cookie）</p><p>cookie：json字符串转为json对象</p><p>OAuth2</p><p>微信登录：</p><p>1、使用httpclient发送get请求（工具类 + 依赖）</p><p>2、从json字符串获取值（转为map）</p><p>3、再请求一个地址，获取扫码人信息</p><p>4、自动注册（未注册）</p><p>token路径传递</p><p>1、通过路径获取token</p><p>以下同前面</p><p>2、Token——cookie、拦截器：token——header</p><p>存在cookie中是因为有拦截器会将cookie中的token存到header中，后端也是从hader中取token的，cookie相当于转存的介质</p><p>3、Token + header = member——cookie</p><p>播放器组件</p><p>评论组件</p><p>微信支付：</p><p>(1) 生成订单</p><p>① 根据课程id获取课程信息——远程调用</p><p>② 根据用户id（jwt从header获取id）获取用户信息——远程调用</p><p>(2) 根据id查询订单信息</p><p>(3) 生成微信支付二维码</p><p>① 、获取订单参数</p><p>②、发送httpclient请求（参数xml）</p><p>③、获取返回结果</p><p>(4) 查询支付状态</p><p>①Service——发送httpclient请求——返回包含状态</p><p>②添加支付记录，更改订单状态</p><p>③定时器</p><p>根据Url下载二维码组件</p><p>Echarts</p><p>定时任务</p><h1 id="8、后端4"><a href="#8、后端4" class="headerlink" title="8、后端4"></a>8、后端4</h1><p>canal数据同步</p><p>Gateway：路由、断言、过滤器</p><p>权限管理</p><p>权限关系表</p><p>递归分级</p><p>SpringSecurity</p><p>nacos配置中心</p><h1 id="9、Jenkins"><a href="#9、Jenkins" class="headerlink" title="9、Jenkins"></a>9、Jenkins</h1><p>Jenkins、github action</p><h1 id="10、产品开发流程"><a href="#10、产品开发流程" class="headerlink" title="10、产品开发流程"></a>10、产品开发流程</h1><p>1、需求调研（产品经理）</p><p>2、需求评审（产品/设计/前端/后端/测试/运营）</p><p>3、立项（项目经理、品管）</p><p>4、UI设计</p><p>5、开发</p><p>· 架构、数据库设计、API文档、MOCK数据、开发、单元测试</p><p>· 前端</p><p>· 后端</p><p>6、前端后端联调</p><p>7、项目提测：黑盒白盒、压力测试（qps）  loadrunner</p><p>8、bug修改</p><p>9、回归测试</p><p>10、运维和部署上线</p><p>11、灰度发布</p><p>12、全量发布</p><p>13、维护和运营</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mycat</title>
      <link href="/2022/01/28/Mycat/"/>
      <url>/2022/01/28/Mycat/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><p>① Java与数据库紧耦合。 </p><p>② 高访问量高并发对数据库的压力。 </p><p>③ 读写请求数据不一致</p><p>对比：<img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195056298.png" alt="image-20220128195056298"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>读写分离：配合主从复制、主备模式</p><p>数据分片：分库分表</p><p>多数据源整合</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195358045.png" alt="image-20220128195358045"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>拦截</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195439600.png" alt="image-20220128195439600"></p><p>三个重要配置文件</p><p>1、逻辑库、表、分片节点</p><p>2、分片规则</p><p>3、用户、系统配置</p><h1 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h1><p>Myqsl：从接入点开始复制</p><h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><p>日志格式</p><p>balance属性：读写分离</p><p>复制原理：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195544208.png" alt="image-20220128195544208"></p><h2 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h2><p>主备切换</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195329105.png" alt="image-20220128195329105"></p><h1 id="3、分库分表"><a href="#3、分库分表" class="headerlink" title="3、分库分表"></a>3、分库分表</h1><h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195834488.png" alt="image-20220128195834488"></p><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><p>多表联查</p><p>全局表：全局一致性（广播）</p><p>常用分片规则：</p><p>取模、分片枚举、范围约定、日期</p><h2 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h2><p>1、本地文件</p><p>2、时间戳</p><p>3、数据库方式</p><p>4、reids、雪花算法等</p><h1 id="4、基于HA机制的Mycat高可用"><a href="#4、基于HA机制的Mycat高可用" class="headerlink" title="4、基于HA机制的Mycat高可用"></a>4、基于HA机制的Mycat高可用</h1><p>Mycat集群保证数据库高可用</p><p>haproxy保证mycat高可用（负载均衡）</p><p>Keepalived保证haproxy高可用（创建虚拟ip）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200457657.png" alt="image-20220128200457657"></p><p>安全权限</p><p>user、privileges、sql拦截</p><h1 id="6、监控"><a href="#6、监控" class="headerlink" title="6、监控"></a>6、监控</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200635053.png" alt="image-20220128200635053"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mycat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2022/01/27/RocketMQ/"/>
      <url>/2022/01/27/RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h2><p>限流削峰（请求存在队列中）</p><p>异步解耦</p><p>数据采集</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213121974.png" alt="image-20220127213121974"></p><h2 id="MQ常见协议"><a href="#MQ常见协议" class="headerlink" title="MQ常见协议"></a>MQ常见协议</h2><p>JMS</p><p>STOMP</p><p>AMQP</p><p>MQTT</p><h1 id="2、RocketMQ"><a href="#2、RocketMQ" class="headerlink" title="2、RocketMQ"></a>2、RocketMQ</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>消息、主题、标签、队列、消息标识（消息唯一id：生产者、broker）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213610678.png" alt="image-20220127213610678"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213633953.png" alt="image-20220127213633953"></p><p>生产者</p><p>消费者</p><p>（一个消费者组，消费者消费队列不同）</p><p>Name Server（注册中心）：broker管理、路由信息管理</p><p>路由注册、路由剔除（心跳包）、路由发现、选择策略：轮询</p><p>broker</p><p>组成：实体、客户端管理、存储、高可用（集群数据同步）、索引（ID）</p><p>集群部署：主备集群</p><p>主从、主备</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213923298.png" alt="image-20220127213923298"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>1、启动server、监听端口</p><p>2、Broker与serve长连接</p><p>3、创建topic</p><p>4、生产者发送消息：和server建立连接，获取路由（topic、broker）。</p><p>与broker长连接，向broker发送消息。路由信息每30s缓存在本地。</p><p>5、消费者，server连接，获取路由。与broker长连接，消费。</p><p>Consumer发送心跳，确认broker存活状态。</p><h3 id="Topic的创建模式"><a href="#Topic的创建模式" class="headerlink" title="Topic的创建模式"></a>Topic的创建模式</h3><p>集群、broker模式</p><h3 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h3><p>一般情况数量一样</p><p>设计目的：方便topic的缩容</p><p>写队列先缩容，读队列消费完后再缩容，不丢失任何消息。</p><h2 id="集群搭建理论"><a href="#集群搭建理论" class="headerlink" title="集群搭建理论"></a>集群搭建理论</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214305521.png" alt="image-20220127214305521"></p><h3 id="数据复制与刷盘策略"><a href="#数据复制与刷盘策略" class="headerlink" title="数据复制与刷盘策略"></a>数据复制与刷盘策略</h3><p>生产者、消费者：groupname相同即可</p><p>Nameserver集群：相互不通信，启动即可</p><p>Broker集群：多个主备小集群</p><p>数据复制：master向slave复制</p><h3 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h3><p>刷盘：由内存写入到磁盘</p><p>同步、异步复制（ACK时机）</p><p>同步：slave成功后ack</p><p>异步：master写入后ack</p><h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p>同步、异步刷盘</p><p>同步：broker写入磁盘ack</p><p>异步：broker写入内存ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214313364.png" alt="image-20220127214313364"></p><p>多master集群：宕机后无法消费</p><h3 id="多master多slave集群"><a href="#多master多slave集群" class="headerlink" title="多master多slave集群"></a>多master多slave集群</h3><p>一个master一个slave：主备模式</p><p>Master处理消息读写</p><p>Slave负责消息备份和宕机后的自动切换</p><p>最好使用RAID阵列</p><p>同步双写：同步复制</p><p>安全性最高，RT响应时间长</p><p>Slave不能自动切换</p><p>RAID10磁盘阵列 + 异步复制</p><h2 id="磁盘阵列RAID"><a href="#磁盘阵列RAID" class="headerlink" title="磁盘阵列RAID"></a>磁盘阵列RAID</h2><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h1 id="3、RocketMQ的工作原理"><a href="#3、RocketMQ的工作原理" class="headerlink" title="3、RocketMQ的工作原理"></a>3、RocketMQ的工作原理</h1><h2 id="消息的生产"><a href="#消息的生产" class="headerlink" title="消息的生产"></a>消息的生产</h2><p>1、生产者向servre发送请求，获取topic路由</p><p>2、Server返回topic路由表及broker列表</p><p>（1）路由表：map&lt;topic,queuedata&gt;，queuedata：broker——queue</p><p>找到queue对应的broker</p><p>（2）Broker列表</p><p>3、选择queue</p><p>4、生产者对消息特殊处理</p><p>5、生产者向broker发出RPC请求，发送到queue（底层netty）</p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><p>轮询（问题：性能）、最小投递延迟（问题：分配不均）</p><h2 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h2><h3 id="store目录"><a href="#store目录" class="headerlink" title="store目录"></a>store目录</h3><p>刷盘、消息、配置、队列、消息索引、全局资源锁</p><h3 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h3><p>第n个文件名：前n-1个文件大小之和</p><p>消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214852355.png" alt="image-20220127214852355"></p><h3 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h3><p>消费队列</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214940291.png" alt="image-20220127214940291"></p><p>索引条目：</p><p>是commitlog的索引文件——定位具体消息</p><p>消息条目——偏移量、消息长度、消息tag</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215015213.png" alt="image-20220127215015213"></p><h3 id="对文件的读写"><a href="#对文件的读写" class="headerlink" title="对文件的读写"></a>对文件的读写</h3><p>消息写入</p><p>1、根据queueid，得到comsumequeue要写入的偏移量</p><p>2、封装消息单元</p><p>3、写入commitlog</p><p>4、形成索引条目</p><p>消息拉取</p><p>1、获取所在queue的偏移量</p><p>2、发送broker拉取请求，queue等信息</p><p>3、得到consumequeue中位置</p><p>4、查找指定tag索引</p><p>5、定位commitlog</p><p>6、读取其中的消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215053467.png" alt="image-20220127215053467"></p><p>性能提升：</p><p>文件读写：通过mmap零拷贝</p><p>Comsuequeue读取：</p><p>引入pagecache预读取机制，接近内存读取（顺序读写）</p><p>本质：缓存</p><p>写：先写入pagecache，再异步写入磁盘</p><p>读：首先读pagecache，若没有命中，将磁盘数据加载到pacache，同时对相邻数据预读取</p><p>Commitlog读取：随机访问，会影响性能</p><p>与kafka对比：</p><p>RocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。</p><p>mappedFile文件就类似于Kafka中的segment段</p><h2 id="indexfile"><a href="#indexfile" class="headerlink" title="indexfile"></a>indexfile</h2><p>根据key进行消息查询（前提：消息包含key）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215235908.png" alt="image-20220127215235908"></p><p>Indexheader：该索引索引相关信息（数量，偏移量等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215241833.png" alt="image-20220127215241833"></p><p>Slot</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215249106.png" alt="image-20220127215249106"></p><p>Index</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215257689.png" alt="image-20220127215257689"></p><p>创建</p><p>indexfile查询流程：</p><p>1、根据key、time找到indexfile</p><p>2、传入时间与文件名差值</p><p>3、计算key的hash——Slot序号——读取slot——最新的indexNo</p><p>4、根据indexN找到index位置</p><p>5、相比Index中的diff</p><p>（1）若时间差小，往前找</p><p>（2）若时间差大，index中定位位置，找到消息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215406692.png" alt="image-20220127215406692"></p><h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><h3 id="两种消息获取方式"><a href="#两种消息获取方式" class="headerlink" title="两种消息获取方式"></a>两种消息获取方式</h3><p>Push（consumer主动拉取），注意拉取时间间隔</p><p>pull（broker主动推动，实时性高），向queue注册监听器，基于长连接</p><h3 id="两种消息消费模式"><a href="#两种消息消费模式" class="headerlink" title="两种消息消费模式"></a>两种消息消费模式</h3><p>广播模式：每个消费者都接收topic全部消息</p><p>集群模式：消费者平分消息</p><h3 id="消息进度保存"><a href="#消息进度保存" class="headerlink" title="消息进度保存"></a>消息进度保存</h3><p>广播模式：消费者保存</p><p>集群模式：保存broker中共享，消息进度参与负载均衡</p><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>Queue和consumer的之间重新分配</p><p>增加减少消费者，提升消息并行</p><p>消费者要小于队列</p><p>危害：</p><p>消息暂停：重分配后才能再消费</p><p>消费重复：异步提交，导致可能重复消费</p><p>一次性读取消息数量需要均衡：重复消费、性能</p><p>消息突刺：重复消费过多消息、积压时间过长</p><p>产生的原因和过程</p><p>1、Queue数量变化</p><p>（1）broker扩缩容</p><p>（2）Broker升级运维</p><p>（3）网络异常</p><p>（4）Queue扩缩容</p><p>2、消费者数量变化</p><p>（1）consumergroup扩缩容</p><p>（2）Consumer升级运维</p><p>（3）网络异常</p><p>过程：</p><p>Broker发现变化，向consumergroup发出Rebalance通知</p><p>Consumer采用分配算法，自主进行Rebalance</p><p>Broker中group coordinate选举consumer leader</p><p>由lerder完成分区的再分配，上报coordinate，coordinate同步给consumer实例</p><p>Kafka的Rebalance由选举的comsumer leader完成。</p><p>Rocket的Rebalance由每个consumer完成</p><p>Queue分配算法</p><p>平均分配</p><p>环形平均策略：类似轮询</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215711998.png" alt="image-20220127215711998"></p><p>一致性hash策略：先把consumer放到环上，再把queue的hash值放环上，顺时针找consumer （缺点：分配不均）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215721201.png" alt="image-20220127215721201"></p><p>同机房策略</p><p>一致性hash：减少扩缩容的rebalance</p><p>扩缩容需要rebalance，变化较大</p><p>一致性hash扩缩容变化较小：应用场景，consumer变化较多</p><p>至少一次原则</p><h2 id="订阅关系的一致性"><a href="#订阅关系的一致性" class="headerlink" title="订阅关系的一致性"></a>订阅关系的一致性</h2><h2 id="offset管理"><a href="#offset管理" class="headerlink" title="offset管理"></a>offset管理</h2><p>Consumer的消费进度offset</p><h3 id="Offset本地管理"><a href="#Offset本地管理" class="headerlink" title="Offset本地管理"></a>Offset本地管理</h3><p>广播，消费进度保存在consumer中</p><h3 id="Offset远程管理"><a href="#Offset远程管理" class="headerlink" title="Offset远程管理"></a>Offset远程管理</h3><p>集群消费，保存在broker文件中</p><p>所有consumer共享queue的消费进度</p><p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制</p><p>Rebalance后，新的consumer可以读取相应消费进度继续消费</p><p>NextBeginOffset：下次消费起始</p><p>消费异常：异常消息提交broker的重试队列</p><p>同步、异步提交offset</p><p>异步：提交offset、无需等待broker响应，直接从broker获取next</p><h2 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h2><h3 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h3><p>重复消费影响相同</p><p>1、发送重复：Broker对生产者ack失败，生产者重复发送相同消息（msgid相同）</p><p>2、消费重复：consumer对broker的ack失败，broker再次投递相同消息</p><p>3、Rebalance：consumer、queue变化，没提交ack前Rebalance可能重复消费</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>幂等令牌：具备唯一业务表示的字符串，唯一id</p><p>唯一性处理：服务端采用算法，保证成功执行一次</p><p>1、通过缓存去重，缓存是否命中幂等令牌</p><p>2、数据库查询是否有幂等令牌（缓存可能过期）</p><p>3、同一事务中：唯一性处理、幂等令牌写入缓存，幂等令牌写入DB</p><h3 id="支付场景中的解决方案"><a href="#支付场景中的解决方案" class="headerlink" title="支付场景中的解决方案"></a>支付场景中的解决方案</h3><p>1、首先redis获取流水号</p><p>（1）不为空，调用重复逻辑</p><p>2、无缓存，查询DB</p><p>（1）不为空，调用重复逻辑</p><p>3、为空，在分布式事务完成</p><p>（1）完成支付</p><p>（2）流水号作为key，存入redis（过期时间）</p><p>（3）流水号作为主键存入DB</p><p>消费幂等的实现</p><p>最好以业务唯一标识作为依据</p><h2 id="消息堆积与消费延迟"><a href="#消息堆积与消费延迟" class="headerlink" title="消息堆积与消费延迟"></a>消息堆积与消费延迟</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220321282.png" alt="image-20220127220321282"></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>消费速度跟不上生产速度</p><p>1、上下游能力不匹配</p><p>2、实时性要求较高，延迟造成堆积</p><p>长轮询PULL模式</p><p>1、消息拉取：批量拉取，缓存到本地缓存队列</p><p>2、消息消费：取决于消费并发、消费耗时度</p><p>本地缓存队列达到上限，停止从服务端拉取消息</p><h3 id="消费耗时的深入分析"><a href="#消费耗时的深入分析" class="headerlink" title="消费耗时的深入分析"></a>消费耗时的深入分析</h3><p>主要耗时：外部IO代码</p><p>1、mysql 、redis访问</p><p>2、下游系统调用:dubbo的RPC远程调用、springcloud的http接口调用</p><p>下游系统服务异常等原因</p><p>消息堆积——消息消费——消息耗时——外部IO——下游DB、RPC、http调用——服务异常、容量限制——网络宽带等</p><h3 id="消息并发度的深入分析"><a href="#消息并发度的深入分析" class="headerlink" title="消息并发度的深入分析"></a>消息并发度的深入分析</h3><p>普通消息 并发度 = 单节点线程数 * 节点数（consumer）</p><p>顺序消息：topic的queue分区数量</p><p>全局顺序消息</p><p>分区顺序消息</p><p>单机线程数的计算</p><h3 id="避免消息堆积与消费延迟"><a href="#避免消息堆积与消费延迟" class="headerlink" title="避免消息堆积与消费延迟"></a>避免消息堆积与消费延迟</h3><p>消费耗时</p><p>1、避免循环、递归</p><p>2、IO操作是否可以本地缓存</p><p>3、是否可以异步化处理</p><p>设置消费并发度</p><h2 id="消息的清理"><a href="#消息的清理" class="headerlink" title="消息的清理"></a>消息的清理</h2><p>以commitlog为单位进行清理</p><p>文件过期、磁盘占用率</p><h1 id="4、RocketMQ的应用"><a href="#4、RocketMQ的应用" class="headerlink" title="4、RocketMQ的应用"></a>4、RocketMQ的应用</h1><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>同步发送消息：收到ack后继续发送</p><p>1、创建生产者、group名称</p><p>2、Nameserver配置</p><p>3、开启生产者，发送消息</p><p>4、关闭生产者</p><p>SendResult：状态、msgid</p><p>异步发送消息：无需等待mq的ack消息，发送的回调接口异步响应</p><p>指定回调函数</p><p>单向发送消息：不接收ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220358071.png" alt="image-20220127220358071"></p><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>顺序消息：</p><p>严格按发送顺序进行消费——只有一条queue——一个消费者消费</p><p>相同订单号消息放到同一queue中</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220514365.png" alt="image-20220127220514365"></p><h3 id="消息有序性的分类"><a href="#消息有序性的分类" class="headerlink" title="消息有序性的分类"></a>消息有序性的分类</h3><p>全局有序：只有一个queue</p><p>分区有序</p><p>生产者可以指定queue选择器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220623422.png" alt="image-20220127220623422"></p><h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>指定时长后才可被处理：实现定时任务</p><p>发送延迟消息：过时且判断未支付，放回票池</p><h3 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220640775.png" alt="image-20220127220640775"></p><p>1、先发给延迟topic延迟队列</p><p>2、根据定时管理器，时间到了——发送给commitlog——正常消息</p><p>写入commitqueue</p><p>原本Tage的hashcode改为消息投递时间（定时结束时间）</p><h3 id="再次投递"><a href="#再次投递" class="headerlink" title="再次投递"></a>再次投递</h3><p>1、定时管理器中有相应timertask——负责消息消费和投递</p><p>2、检测相应queue中第一条消息是否到期</p><p>3、若到期，投递</p><p>管理器作为生产者，重新写入commitlog</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220802767.png" alt="image-20220127220802767"></p><p>1、TM向TC发指令，开启全局事务</p><p>2、工行给TC发送事务消息M</p><p>3、TC给broker发送半事务消息（预提交）</p><p>4、Broker预提交返回执行结果</p><p>（1）失败——TC——TM，全局事务结束</p><p>5、成功——调用——预扣款——返回执行结果（本地事务）——TC——TM</p><p>（1）预扣款成功——commit——TC——broker（branch commit）——M可被建行看到</p><p>（2）预扣款失败——rollback——TC——broker（branch rollback）</p><h3 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h3><p>事务消息</p><p>半事务消息：暂不能被消费者看到</p><p>本地事务状态：生产者回调操作执行的结果——TC——TM——全局事务确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220933007.png" alt="image-20220127220933007"></p><p>消息回查：重新查看本地事务的执行状态</p><p>（1）状态（UNKNOWN）</p><p>（2）TC未收到TM的最终全局事务确认指令</p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>XA：分布式事务处理模式</p><p>三剑客</p><p>（1）TC：事务协调者（broker）维护全局事务</p><p>（2）TM：事务管理器（生产者）全局事务发起者</p><p>（3）RM：资源管理器（生产者、broker）报告事务状态</p><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221048552.png" alt="image-20220127221048552"></p><p>1、TM向TC发指令开启全局事务</p><p>2、RM向TC注册分支事务，TC——RM——预执行</p><p>3、RM执行结果返回，TC汇总结果——TM</p><p>（1）global commit——TC——RM</p><p>（2）Global rollback——TC——RM</p><p>事务消息：同步的，先broker再生产者</p><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>Topic、刷盘策略一样</p><p>不能是延时、事务消息</p><p>消息——字符串：topic、body、日志、properties相关属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221147787.png" alt="image-20220127221147787"></p><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>默认一次拉取32条消息</p><p>默认最大一次消费32条</p><p>分割器</p><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>tag过滤</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221233544.png" alt="image-20220127221233544"></p><p>SQL过滤：Properties中的属性，支持运算符</p><h2 id="消息重试机制"><a href="#消息重试机制" class="headerlink" title="消息重试机制"></a>消息重试机制</h2><h3 id="发送-1"><a href="#发送-1" class="headerlink" title="发送"></a>发送</h3><p>1、同步异步会重试，单向无法重试（只管发送）</p><p>2、顺序消息没有重试</p><p>3、可能消息重复、重复消息（负载变化、网络原因）</p><p>4、发送重试策略：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</p><p>同步发送失败</p><p>失败隔离：选择不同broker</p><p>异步发送失败</p><p>消息刷盘失败策略：刷盘失败，默认不会发送到其他broker</p><h3 id="消费-1"><a href="#消费-1" class="headerlink" title="消费"></a>消费</h3><p>顺序消息消费重试：不断重试直至消费成功</p><p>广播消费：消费失败——无消费重试</p><p>若重复完仍然失败——死信队列</p><p>需要重试消费的消息——&gt;重试队列（基于延时消息实现）</p><p>消息监听接口配置</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列：处理异常消息</p><p>详见RabbitMQ</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/01/25/RabbitMQ/"/>
      <url>/2022/01/25/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>消息队列</p><p>流量削峰</p><p>应用解耦：上游只需发送消息</p><p>异步处理：异步处理回调消息</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><p>生产者、交换机、队列、消费者</p><h2 id="六大核心模式"><a href="#六大核心模式" class="headerlink" title="六大核心模式"></a>六大核心模式</h2><p>简单、工作队列、发布订阅、路由、主题、发布确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223147422.png" alt="image-20220125223147422"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>Broker</strong></p><p><strong>Virtual host</strong></p><p><strong>Connection</strong></p><p><strong>Channel</strong></p><p><strong>Exchange</strong></p><p><strong>Queue</strong></p><p><strong>Binding</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223250580.png" alt="image-20220125223250580"></p><h1 id="2、核心"><a href="#2、核心" class="headerlink" title="2、核心"></a>2、核心</h1><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><strong>轮询</strong>分发消息</p><p>消息应答：消费者是否处理消息</p><p>自动应答、手动应答（批量应答）</p><p>消息自动重新入队</p><p>rabbitmq持久化：队列持久化、消息持久化</p><p>不公平分发</p><p>预取值：通道中堆积消息个数</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>单个确认发布</p><p>批量确认发布</p><p>异步确认发布：异步通知——交换机确认收到、未确认收到</p><p>并发链路式队列——发消息和监听线程之间传递消息——本质：map</p><p>1、发送消息时进记录队列</p><p>2、确认回调再删除</p><p>未删除的——未确认消息</p><p>跳表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224155047.png" alt="image-20220125224155047"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224048175.png" alt="image-20220125224048175"></p><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p><p>无名 exchange</p><p>临时队列</p><p>bindings</p><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h3><p>广播：路由key为空</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224517818.png" alt="image-20220125224517818"></p><h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>发送路由key对应队列——无论队列个数</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224644373.png" alt="image-20220125224644373"></p><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p>没有*和#：fanout、direct模式</p><p>*(星号)可以代替一个单词</p><p>#(井号)可以替代零个或多个单词</p><h1 id="3、高级"><a href="#3、高级" class="headerlink" title="3、高级"></a>3、高级</h1><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>发送异常消息——进入死信队列</p><p>死信队列的来源：</p><p>消息 TTL 过期</p><p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p><p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224938734.png" alt="image-20220125224938734"></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延迟队列——消息过期进入死信队列</p><p>存放需要在指定时间被处理的元素的队列</p><p>应用场景</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225016545.png" alt="image-20220125225016545"></p><p>缺陷：ttl不灵活</p><h3 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h3><p>QC队列不设置过期时间，由生产者设置ttl</p><p>缺陷：队列FIFO</p><h3 id="基于插件优化"><a href="#基于插件优化" class="headerlink" title="基于插件优化"></a>基于插件优化</h3><p>基于插件的交换机：在交换机处延迟</p><p>延迟交换机：类型、延迟类型（直接：路由key固定）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225256329.png" alt="image-20220125225256329"></p><p>其他延时队列：</p><p>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz，或者利用 kafka 的时间轮。RabbitMQ安全，完善。</p><h2 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h2><h3 id="交换机回调"><a href="#交换机回调" class="headerlink" title="交换机回调"></a>交换机回调</h3><p>交换机确认消息是否收到</p><p>写回调方法、注入</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225816018.png" alt="image-20220125225816018"></p><p>生产者只管给交换机消息，只接受交换机的接收结果</p><p>路由错误无法接收结果</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>无法路由时，消息回退给交换机，通知生产者</p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>无法投递的消息给备份交换机</p><p>没有什么是加一层解决不了的</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230021103.png" alt="image-20220125230021103"></p><p>备份优先级更高</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等性：重复提交</p><p>消费者ack中断，造成重新消费</p><p>解决思路：生成全局唯一id，消费之前判断是否被消费过</p><p>1、唯一ID + 指纹码机制（数据库）</p><p>2、Redis原子性：利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>设置优先级参数</p><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>消息存到磁盘中，消费者从磁盘取</p><p>内存占比非常小，取消息慢</p><h1 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h1><h2 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125221757500.png" alt="image-20220125221757500"></p><h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125222245390.png" alt="image-20220125222245390"></p><h2 id="高负载均衡"><a href="#高负载均衡" class="headerlink" title="高负载均衡"></a>高负载均衡</h2><p><strong>nginx、gateway</strong>、Haproxy等集群，进行反向代理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230327710.png" alt="image-20220125230327710"></p><p>以下暂用不到</p><h2 id="Shovel集群"><a href="#Shovel集群" class="headerlink" title="Shovel集群"></a>Shovel集群</h2><p>远程同步</p><h2 id="Federation-联邦集群"><a href="#Federation-联邦集群" class="headerlink" title="Federation 联邦集群"></a>Federation 联邦集群</h2><p>Federation Exchange、Federation Queue</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/acae23ba5952abdce66bb65e8b00a5a0.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ</title>
      <link href="/2022/01/24/ActiveMQ/"/>
      <url>/2022/01/24/ActiveMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221656632.png" alt="image-20220124221656632"></p><p>解耦、异步、削峰</p><p>分布式系统</p><p>只要消息发送，尽量异步</p><p>只要解耦，尽量引入消息中间件</p><h2 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h2><p>JMS编码架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221810182.png" alt="image-20220124221810182"></p><p>原生API：</p><p>生产者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息生产者</p><p>消息生产者发送消息</p><p>（1）创建消息</p><p>（2）通过生产者发送</p><p>关闭资源（倒序：生产者、session、连接）</p><p>消费者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息消费者</p><p>消费生产者接收消息——接收消息（一直型、定时型）、消息类型要一致</p><p>关闭资源（倒序：消费者、session、连接）</p><p>1、receive</p><p>2、监听</p><p>队列同时监听：轮询</p><p>主题：先订阅再有生产消息</p><h2 id="3、JMS"><a href="#3、JMS" class="headerlink" title="3、JMS"></a>3、JMS</h2><p>JavaEE</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222038405.png" alt="image-20220124222038405"></p><p>JMS：java消息服务</p><p>消息头</p><p>消息体</p><p>消息属性</p><p>可靠性：持久化、事务、签收、集群</p><h2 id="4、Broker"><a href="#4、Broker" class="headerlink" title="4、Broker"></a>4、Broker</h2><h2 id="5、spring-boot整合"><a href="#5、spring-boot整合" class="headerlink" title="5、spring boot整合"></a>5、spring boot整合</h2><p>间隔定投</p><p>注解监听</p><h2 id="6、传输协议"><a href="#6、传输协议" class="headerlink" title="6、传输协议"></a>6、传输协议</h2><p>种类</p><p>NIO + 多协议</p><h2 id="7、消息存储和持久化"><a href="#7、消息存储和持久化" class="headerlink" title="7、消息存储和持久化"></a>7、消息存储和持久化</h2><p>AMQ</p><p>KahaDB：事务日志 + 索引文件</p><p>Db.log：存储消息、Db.data：B树索引、Lock：文件锁</p><p>LevelDB：基于文件的本地数据库：redis aof</p><p>JDBC + Mysql：</p><p>建库，自动建表：消息表、订阅关系表、记录master表</p><p>JDBC With Journal：</p><p>存到高速缓存日志，减少数据库压力</p><h2 id="8、多节点集群"><a href="#8、多节点集群" class="headerlink" title="8、多节点集群"></a>8、多节点集群</h2><p>Zookeeper和Replicated LevelDB集群</p><p>原理：对外暴露master</p><p>主从复制 + Zookeeper集群</p><p>已被舍弃</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222731107.png" alt="image-20220124222731107"></p><h2 id="9、高级特性、面试考点"><a href="#9、高级特性、面试考点" class="headerlink" title="9、高级特性、面试考点"></a>9、高级特性、面试考点</h2><p>异步投递：</p><p>发送是否成功：写回调函数：成功、失败的信息</p><p>延时投递和定时投递：消息头属性中设置</p><p>分发策略</p><p>消息重试机制：消息侧回滚、消费侧没有commit等</p><p>有毒消息：重发超过6次，放到DLQ（死信队列）</p><p>死信队列：查看出错消息，人工干预修复，可自定义</p><p>防止重复调用，幂等性：数据库主键、redis key</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security</title>
      <link href="/2022/01/24/Spring%20Security/"/>
      <url>/2022/01/24/Spring%20Security/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h2><p>认证</p><p>授权</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220153579.png" alt="image-20220124220153579"></p><h2 id="2、web权限"><a href="#2、web权限" class="headerlink" title="2、web权限"></a>2、web权限</h2><p>查询数据库认证</p><p>自定义登录页面</p><p>方法注解</p><p>注销</p><p>原理分析</p><p>CSRF</p><h2 id="3、微服务权限"><a href="#3、微服务权限" class="headerlink" title="3、微服务权限"></a>3、微服务权限</h2><p>流程</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220433500.png" alt="image-20220124220433500"></p><p>数据库分表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220446710.png" alt="image-20220124220446710"></p><p>JWT：JWT 头、内容、签名哈希</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220917745.png" alt="image-20220124220917745"></p><h2 id="4、源码解析"><a href="#4、源码解析" class="headerlink" title="4、源码解析"></a>4、源码解析</h2><p><strong>Spring Security</strong> 采取<strong>过滤链</strong>实现认证与授权</p><p>认证流程</p><p>权限访问流程</p><p>请求间共享认证信息</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2022/01/24/nginx/"/>
      <url>/2022/01/24/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>nginx</p><p>正向代理</p><p>反向代理</p><p>负载均衡</p><p>动静分离</p><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>高可用集群（主从模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215235206.png" alt="image-20220124215235206"></p><p>高可用集群（双主模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215307904.png" alt="image-20220124215307904"></p><h2 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h2><p><img src="https://img-blog.csdnimg.cn/20191103213303224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hcml0aC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="Nginx 整体架构"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2022/01/24/zookeeper/"/>
      <url>/2022/01/24/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="1、入门"><a href="#1、入门" class="headerlink" title="1、入门"></a>1、入门</h2><p>概述：工作机制</p><p>数据结构：ZNode 树型文件系统</p><p>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下</p><p>线、软负载均衡等</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h2 id="3、集群"><a href="#3、集群" class="headerlink" title="3、集群"></a>3、集群</h2><p>选举机制：</p><p>第一次启动</p><p>非第一次启动：任期id——事务id——id</p><p>节点类型：</p><p>持久、短暂、有序号、无序号</p><p>监听器</p><p>写数据原理：</p><p>发给leader</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213707456.png" alt="image-20220124213707456"></p><p>发给follower</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213720276.png" alt="image-20220124213720276"></p><h2 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h2><p>服务器动态上下线</p><p>分布式锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213847011.png" alt="image-20220124213847011"></p><p>Curator框架实现分布式锁</p><h2 id="5、源码"><a href="#5、源码" class="headerlink" title="5、源码"></a>5、源码</h2><p>选举机制：第一次、非第一次</p><p>分布式一致性：</p><p>Paxos算法</p><p>ZAB协议：消息广播、崩溃恢复</p><p>异常发生——leader选举 + 数据恢复</p><p>数据恢复——一个follower所有事务提交之后才变为follower</p><p>CAP理论：保证CP</p><p>持久化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214406672.png" alt="image-20220124214406672"></p><p>序列化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214429678.png" alt="image-20220124214429678"></p><p>服务端初始化源码-启动脚本</p><p>初始化-解析参数</p><p>初始化-过期快照删除</p><p>初始化-通信初始化</p><p>服务端加载数据源码</p><p>选举-选举准备</p><p>选举-选举执行</p><p>Follower 和 Leader 状态同步源码</p><p>状态同步细节</p><p>Leader启动</p><p>Follower启动</p><p>客户端启动</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214747431.png" alt="image-20220124214747431"></p><p>选举</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo</title>
      <link href="/2022/01/24/dubbo/"/>
      <url>/2022/01/24/dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>分布式系统演变</p><p>RPC原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212540495.png" alt="image-20220124212540495"></p><p>dubbo核心原理</p><p>监控中心</p><h2 id="2、dubbo配置"><a href="#2、dubbo配置" class="headerlink" title="2、dubbo配置"></a>2、dubbo配置</h2><h2 id="3、高可用"><a href="#3、高可用" class="headerlink" title="3、高可用"></a>3、高可用</h2><p>zookeeper</p><p>集群负载均衡</p><p>hystrix、服务熔断、服务降级</p><h2 id="4、原理"><a href="#4、原理" class="headerlink" title="4、原理"></a>4、原理</h2><h3 id="RPC原理："><a href="#RPC原理：" class="headerlink" title="RPC原理："></a>RPC原理：</h3><p>一次完整的RPC调用流程（同步调用，异步另说）如下： </p><p><strong>1）服务消费方（client）调用以本地调用方式调用服务；</strong> </p><p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p><p>3）client stub找到服务地址，并将消息发送到服务端； </p><p>4）server stub收到消息后进行解码； </p><p>5）server stub根据解码结果调用本地的服务； </p><p>6）本地服务执行并将结果返回给server stub； </p><p>7）server stub将返回结果打包成消息并发送至消费方； </p><p>8）client stub接收到消息，并进行解码； </p><p><strong>9）服务消费方得到最终结果。</strong></p><p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h3 id="netty通信原理"><a href="#netty通信原理" class="headerlink" title="netty通信原理"></a>netty通信原理</h3><p>BIO</p><p>NIO</p><h3 id="dubbo原理"><a href="#dubbo原理" class="headerlink" title="dubbo原理"></a>dubbo原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212904106.png" alt="image-20220124212904106"></p><p>框架设计</p><p>启动解析、加载配置信息</p><p>服务暴露</p><p>服务引用</p><p>服务调用</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch</title>
      <link href="/2022/01/24/elasticsearch/"/>
      <url>/2022/01/24/elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="入门-HTTP"><a href="#入门-HTTP" class="headerlink" title="入门-HTTP"></a>入门-HTTP</h1><h1 id="入门-JavaAPI"><a href="#入门-JavaAPI" class="headerlink" title="入门-JavaAPI"></a>入门-JavaAPI</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>进阶：文档、字段、映射、分片、副本、分配</p><p>系统架构：</p><p>选举主节点，master调度管理集群</p><p>P1P2P3分片、R2R0R1副本，不在一个机器上</p><p>每一个分片就是底层的LUCENE的索引</p><p>分布式集群：</p><p>故障转移、水平扩容、应对故障</p><p>路由计算 &amp; 分片控制</p><p>数据写流程</p><p>数据读流程</p><p>更新流程 &amp; 批量操作流程</p><p>倒排索引</p><p>文档搜索</p><p>文档刷新 &amp; 文档刷写 &amp; 文档合并</p><p>文档分析</p><p>文档处理</p><p>文档展示-Kibana</p><h1 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h1><p>SpringData-整体介绍</p><p>文档搜索</p><p>Spark streaming</p><p>Flink</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>硬件选择</p><p>分片策略</p><p>路由选择</p><p>写入速度优化</p><p>重要配置</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>为什么使用elasticsearch</p><p>Master选举</p><p>集群脑裂</p><p>索引文档的流程</p><p>更新和删除文档</p><p>搜索流程</p><p>Linux设置部署优化</p><p>GC方面，注意</p><p>上亿数据的聚合实现</p><p>并发情况下，如何保证读写—致</p><p>监控</p><p>字典树</p><p>集群、节点、索引、文档、类型</p><p>倒排索引</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>为什么使用es</p><p>概念：集群、节点、索引、文档、类型</p><p>基本操作：索引、更新、删除、搜索</p><p>集群：master选举、脑裂</p><p>字典树</p><p>倒排索引</p><p>优化：linux部署设置、GC、</p><p>海量数据：如何聚合</p><p>高并发：如何保证读写一致</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/01/24/docker/"/>
      <url>/2022/01/24/docker/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/docker%E6%80%BB%E7%BB%93.png" alt="docker总结"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/01/24/redis/"/>
      <url>/2022/01/24/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h2><p>Memcache</p><p>Redis</p><p>MongoDB</p><h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>单线程+多路IO复用</p><p>应用场景：</p><p>缓存、session共享、持久化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124203929901.png" alt="image-20220124203929901"></p><h2 id="五大常用数据类型"><a href="#五大常用数据类型" class="headerlink" title="五大常用数据类型"></a>五大常用数据类型</h2><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><h2 id="三大新数据类型"><a href="#三大新数据类型" class="headerlink" title="三大新数据类型"></a>三大新数据类型</h2><h2 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h2><p>网络连接：心跳检测、连接时长</p><p>通用：日志级别、库</p><p>存储策略</p><h2 id="reids的发布和订阅"><a href="#reids的发布和订阅" class="headerlink" title="reids的发布和订阅"></a>reids的发布和订阅</h2><p>Bitmaps：统计</p><p>HyperLogLog：基数计算：不重复数据个数的计算</p><p>Geographic：地理</p><h2 id="Jedis、RedisTemplate"><a href="#Jedis、RedisTemplate" class="headerlink" title="Jedis、RedisTemplate"></a>Jedis、RedisTemplate</h2><h2 id="事务、锁机制、秒杀"><a href="#事务、锁机制、秒杀" class="headerlink" title="事务、锁机制、秒杀"></a>事务、锁机制、秒杀</h2><p>事务：</p><p>Multi、Exec、discard</p><p>悲观锁、乐观锁</p><p>监视key</p><p>特点：单独的隔离操作、没有隔离级别的概念、不保证原子性</p><p>秒杀：</p><p>乐观锁 + 连接池 + LUA脚本（原子化）  解决库存遗留问题</p><h2 id="持久化RDB、AOF"><a href="#持久化RDB、AOF" class="headerlink" title="持久化RDB、AOF"></a>持久化RDB、AOF</h2><p>RDB：临时文件 –&gt; 覆盖</p><p>AOF：只记录写的操作，只能追加，redis读取这些操作重写构建数据</p><p>写操作追加到缓存区，根据策略进行持久化同步，根据重写策略进行重写压缩</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>一主二仆</p><p>薪火相传：分组传递</p><p>宕机上位</p><p>连接时：全量复制</p><p>同步时：增量复制</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124205643714.png" alt="image-20220124205643714"></p><p>主从复制原理</p><p>哨兵模式：</p><p>Master down ，sentinel自动监控 —&gt; 选举某从机作为主机</p><p>Master 再次上线后 变为从机</p><p>选举规则：</p><p>1、Priority最小</p><p>2、偏移量最全</p><p>3、Runid最小的（随机生成）</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>无中心化</p><p>集群节点的插槽计算：计算key所属的插槽，平均分摊压力</p><p>哈希槽分区</p><h2 id="应用问题"><a href="#应用问题" class="headerlink" title="应用问题"></a>应用问题</h2><p>缓存穿透</p><p>解决方案：</p><p>缓存空值（设置过期时间）、设置白名单（bitmaps）</p><p>布隆过滤器（底层bitmap）、实时监控redis（设置黑名单）</p><p>缓存击穿</p><p>解决方案：</p><p>预先设置热门key（增加时长）、实时调整（频繁访问key增加时长）</p><p>锁（先上锁，查完数据库放锁）</p><p>缓存雪崩</p><p>构建多层缓存（多级缓存处理）、锁和队列（不适合高并发）</p><p>设置过期标志（更新时长）、分散缓存失效时间（过期时间不同）</p><p>分布式锁</p><p>reids分布式锁：</p><p>setnx  同时设置过期时间</p><p>Redisson</p><p>总结：</p><p>Uuid + 过期时间 + 加锁</p><p>Lua释放锁（uuid比较）</p><h2 id="Redis6新功能"><a href="#Redis6新功能" class="headerlink" title="Redis6新功能"></a>Redis6新功能</h2><p>Acl用户权限</p><p>Io多线程：网络数据读写和协议解析</p><p>工具支持cluster</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud + SpringCloud Alibaba分布式集群总结</title>
      <link href="/2022/01/24/SpringCoud%20Alibaba/"/>
      <url>/2022/01/24/SpringCoud%20Alibaba/</url>
      
        <content type="html"><![CDATA[<h2 id="eureka："><a href="#eureka：" class="headerlink" title="eureka："></a>eureka：</h2><p>单机eureka、集群eureka</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="zookeeper："><a href="#zookeeper：" class="headerlink" title="zookeeper："></a>zookeeper：</h2><p>linux docker部署zookeeper，配置注册地址</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="consul："><a href="#consul：" class="headerlink" title="consul："></a>consul：</h2><p>命令本地启动consul，8500端口页面</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="Ribbon："><a href="#Ribbon：" class="headerlink" title="Ribbon："></a>Ribbon：</h2><p>Irule配置或自定义负载均衡算法，@Ribbonclient配置调用的服务和算法</p><p>手写轮询算法，CAS锁</p><h2 id="Openfeign："><a href="#Openfeign：" class="headerlink" title="Openfeign："></a>Openfeign：</h2><p>接口注解调用，默认支持ribbon自带负载均衡</p><p>ribbon超时控制，日志显示</p><h2 id="Hystrix："><a href="#Hystrix：" class="headerlink" title="Hystrix："></a>Hystrix：</h2><p>服务降级：@HystrixCommand，调用中出现错误、超时、宕机等，启用兜底方法，fallback方法分离</p><p>服务熔断：配置熔断情况，时间窗口，请求阈值，错误百分比阈值等，half open</p><p>hystrixDashboard可视化监控，监控服务访问</p><h2 id="Zuul、Gataway："><a href="#Zuul、Gataway：" class="headerlink" title="Zuul、Gataway："></a>Zuul、Gataway：</h2><p>路由转发、断言匹配、执行过滤器链，支持负载均衡</p><p>作为中转站进行路由映射，过滤器生命周期pre、post，常用过滤器：请求头、参数匹配等，自定义过滤器</p><h2 id="Config："><a href="#Config：" class="headerlink" title="Config："></a>Config：</h2><p>服务端实时获取Github配置，文件配置映射，生产模式配置，客户端父子配置文件，设置文件映射和配置中心</p><p>Post请求动态刷新客户端配置</p><h2 id="Bus："><a href="#Bus：" class="headerlink" title="Bus："></a>Bus：</h2><p>支持RabbitMQ和kafka，自动进行消息监听配置中心变化，全局订阅实现配置更新，称为消息总线</p><p>加入bus依赖，rabbitmq配置，自动监听，一次发送处处生效</p><p>定点刷新，post附带服务端端口号</p><h2 id="Stream："><a href="#Stream：" class="headerlink" title="Stream："></a>Stream：</h2><p>统一底层差异，设置生产者、消费者、监听进行消息发送</p><p>分组消费，配置group，支持消息持久化</p><h2 id="Sleuth："><a href="#Sleuth：" class="headerlink" title="Sleuth："></a>Sleuth：</h2><p>zipkin可视化监控，本地命令启动，全局链路id关联调用链路</p><p>配置zikpin地址，采样率设置</p><h2 id="Nacos："><a href="#Nacos：" class="headerlink" title="Nacos："></a>Nacos：</h2><p>nacos服务注册中心，本地命令启动，支持CP、AP切换</p><p>作为配置中心，加入配置匹配格式，配置名称空间，分组等进行匹配，自带动态刷新</p><p>namespace：环境、group：分组，不同微服务模块、service：微服务模块、cluster：集群，杭州虚拟划分，实现容灾，instance：微服务实例</p><p>持久化配置，默认嵌入式数据库derby，连接到mysql即可</p><p>nacos集群，linux docker部署，请求到Nginx集群，nacos集群，底层db集群</p><h2 id="Sentinel："><a href="#Sentinel：" class="headerlink" title="Sentinel："></a>Sentinel：</h2><p>sentinel可视化控制台，本地命令启动，yaml配置地址，默认懒加载</p><p>流控规则，</p><p>统计规则：慢调用比例，异常比例、异常数，</p><p>流控模式：直接、关联，关联的资源达到阈值限流自己、链路，统计指定资源到当前资源，对请求来源限流，</p><p>流控效果：直接、预热，阈值从冷启动因子经过预热时长后达到正常阈值，秒杀应用、排队等待，匀速排队，阈值必须为qps，处理间隔突发的流量</p><p>服务降级，降级策略：RT平均响应时间、异常比例、异常数，分钟统计，支持半开状态</p><p>热点key限流，支持参数索引，排除特殊参数。系统规则，全局限流</p><p>@SentinelResource，blockhandler：限流兜底方法，自定义限流处理逻辑，代码分离</p><p>服务熔断，整合ribbon，加上fallback即可，整合feign，消费者侧接口注解处fallback</p><p>规则持久化，yaml配置datasource，地址指向nacos，文件匹配</p><h2 id="seata："><a href="#seata：" class="headerlink" title="seata："></a>seata：</h2><p>ID+三组件，TC全局事务协调器，TM事务提交回滚，RM分支事务、分支注册、状态汇报等</p><p>seata service本机命令启动，配置文件，数据库，nacos地址</p><p>mysql建表，seata事务表，业务数据库回滚日志表</p><p>微服务配置，文件nacos匹配，yaml配置，seata代理数据库，@GlobalTransactional，异常回滚</p><p>执行流程：一阶段加载：解析sql语句找到业务数据保存为before image，执行业务sql，保存after iamge，生成行锁，二阶段提交：顺利提交，seata删除快照和行锁，完成数据清理即可，二阶段回滚：回滚执行的业务sql，通过一阶段回滚日志进行反向补偿，用before image还原业务数据，脏写校验，对比当前和after image</p><h2 id="分布式全局唯一id："><a href="#分布式全局唯一id：" class="headerlink" title="分布式全局唯一id："></a>分布式全局唯一id：</h2><p>UUID，入库性能差、数据库自增主键，B+树索引分裂、reids集群增长步长，需要维护，雪花算法</p><p><img src="https://z3.ax1x.com/2021/07/27/WhcJM9.png" alt="WhcJM9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud Alibaba </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
