<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法——谷歌、微软、亚马逊等面试题</title>
      <link href="/2022/04/05/%E7%AE%97%E6%B3%95-%E8%B0%B7%E6%AD%8C%E3%80%81%E5%BE%AE%E8%BD%AF%E3%80%81%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/05/%E7%AE%97%E6%B3%95-%E8%B0%B7%E6%AD%8C%E3%80%81%E5%BE%AE%E8%BD%AF%E3%80%81%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="333、最大BST子树"><a href="#333、最大BST子树" class="headerlink" title="333、最大BST子树"></a>333、最大BST子树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405183659863.png" alt="image-20220405183659863"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 找到最大二叉搜索树子树</span><br><span class="line">+ 自顶向下（递归实现）</span><br><span class="line">    + 如果根节点不是BST</span><br><span class="line">        + 方法：判断root树是否为BST</span><br><span class="line">        + 方法：节点计数</span><br><span class="line">    + 递归左子树、右子树，返回max</span><br><span class="line">+ 递归重要的是想清楚方法的功能</span><br><span class="line">+ 自底向上（后序遍历）</span><br><span class="line">    + 如果下面子树不是BST</span><br><span class="line">        + 则所有父节点都不是BST</span><br><span class="line">        + 父节点的另一子树不一定</span><br><span class="line">    + 结合info信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405183759918.png" alt="image-20220405183759918"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 自底向上：从底部开始向上，记录收集信息</span><br><span class="line">    + 原理（向上递推）</span><br><span class="line">        + 左子树是BST，右子树也是BST，root符合条件</span><br><span class="line">            + root也是BST</span><br><span class="line">        + 利用子树的信息，向上递推</span><br><span class="line">    + 准备</span><br><span class="line">        + info类</span><br><span class="line">            + 最大BST子树的：根节点、节点数量、node的最大最小值</span><br><span class="line">    + 实现</span><br><span class="line">        + 返回根节点的info信息（递归）</span><br><span class="line">            + 结束条件：root为null</span><br><span class="line">            + 递归查找左子树info</span><br><span class="line">            + 递归查找右子树info</span><br><span class="line">            + 左右子树的info，四种情况</span><br><span class="line">                + 1、左右最大BST为本身，root大于左最大，root小于右最小</span><br><span class="line">                    + 整棵树为BST</span><br><span class="line">                + 2、左子树为空，右子树最大BST为本身，root小于右最小</span><br><span class="line">                + 3、左子树最大BST为本身，右子树为空，root大于左最大</span><br><span class="line">                + 4、左右都为空，root为BST</span><br><span class="line">                + 5、左右不为空（有BST子树），取size最大值</span><br><span class="line">+ li判断、赋值</span><br><span class="line">+ ri判断、赋值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405183847831.png" alt="image-20220405183847831"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>94、98、230、101、108、102、104</p><p>105、106、297、449</p><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>深度优先搜索：</p><p>解决排列组合问题</p><h2 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、电话号码的字母组合</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184008333.png" alt="image-20220405184008333"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 扫描字符</span><br><span class="line">    + DFS：回溯、剪枝 </span><br><span class="line">+ 画树状图，从上到下</span><br><span class="line">+ 实现</span><br><span class="line">    + dfs（递归）</span><br><span class="line">        + 枚举这一层可以做的选择</span><br><span class="line">            + 根据参数，获取每一层</span><br><span class="line">        + 遍历所有选择</span><br><span class="line">            + 保存当前选择到字符数组char[]（记录结果）</span><br><span class="line">            + 选择当前值进入下一层</span><br><span class="line">        + 结束条件：层数达到最底层，char[]结果加入list</span><br><span class="line">    + 递归天然特性，自动回溯</span><br><span class="line">        + 栈</span><br><span class="line">    + 原理</span><br><span class="line">        + 遍历 + 递归 + 回溯</span><br><span class="line">+ 优化</span><br><span class="line">    + 成员变量改为参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184046209.png" alt="image-20220405184046209"></p><h2 id="46、全排列"><a href="#46、全排列" class="headerlink" title="46、全排列"></a>46、全排列</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184057161.png" alt="image-20220405184057161"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ dfs</span><br><span class="line">    + 结束条件：到达最后一层</span><br><span class="line">        + 放入数组到list中</span><br><span class="line">    + 遍历（枚举当前一层的选择：boolean数组标识是否被选择）</span><br><span class="line">        + 存储当前选择到数组中</span><br><span class="line">        + 标记为已选择</span><br><span class="line">        + 递归到下一层</span><br><span class="line">        + 回溯回来-还原</span><br><span class="line">            + 设置为未标记</span><br><span class="line">+ 原理</span><br><span class="line">    + 遍历选择</span><br><span class="line">        + 判断是否使用</span><br><span class="line">        + 记录结果</span><br><span class="line">        + 往下递归</span><br><span class="line">        + 设置未使用</span><br><span class="line">    + 结束：递归到最后一层，添加结果</span><br><span class="line">+ 优化</span><br><span class="line">    + 用list存储结果，省略boolean[]</span><br><span class="line">        + 判断是否能用的选择？</span><br><span class="line">            + 查找是否list中contains这个元素：O(n)</span><br><span class="line">        + 回溯时，删除最后一个结果</span><br><span class="line">            + 保证后面的选择继续遍历</span><br><span class="line">+ 最理想做法</span><br><span class="line">    + 一个num[]数组即可，不需要result[]，不需要boolean[]</span><br><span class="line">        + 0、1、2分别放123层的选择</span><br><span class="line">        + 循环</span><br><span class="line">            + 让0号位置与0、1、2进行交换</span><br><span class="line">            + 进入下一层，1号位置分别与1、2交换</span><br><span class="line">            + 进入下一层，2号位置与2交换</span><br><span class="line">            + 最后的num[]数组即为结果，装入list</span><br><span class="line">            + 回溯到上一层</span><br><span class="line">            + 天然解决，不重复问题</span><br><span class="line">            + 后面的不能交换前面的，只能跟后面的交换</span><br><span class="line">    + 实现</span><br><span class="line">        + 循环（起始：层数）</span><br><span class="line">            + 交换：当前层数与后面每一位i</span><br><span class="line">                + 基于原数组，非交换后的数组</span><br><span class="line">            + 递归到下一层</span><br><span class="line">            + 回溯，恢复现场</span><br><span class="line">                + 再交换回来，恢复原数组！！！（恢复上层，以便上层下次交换）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184224725.png" alt="image-20220405184224725"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184211315.png" alt="image-20220405184211315"></p><h2 id="46、全排列2"><a href="#46、全排列2" class="headerlink" title="46、全排列2"></a>46、全排列2</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184239345.png" alt="image-20220405184239345"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 序列可重复</span><br><span class="line">    + 全排列，结果不可重复</span><br><span class="line">+ 去重</span><br><span class="line">    + 1、加入结果时，list的contains判断是否存在</span><br><span class="line">        + O(n)</span><br><span class="line">    + 2、位置交换时进行判断（有的交换后多个选择相同）</span><br><span class="line">        + 什么情况下排除？</span><br><span class="line">            + 遍历数组</span><br><span class="line">                + 判断交换位置之间是否存在相同的值</span><br><span class="line">                    + 从index开始（index本身也算交换，相同就和后面重复）</span><br><span class="line">                + 若存在相同的值，则说明已经交换过</span><br><span class="line">                    + 本位置再次交换，结果相同</span><br><span class="line">        + 不交换，跳过</span><br><span class="line">+ 前面的交换结果不一样，也被排除？</span><br><span class="line">    + 提前剪枝</span><br><span class="line">    + 本质上一样，后面进行排列组合的结果一样</span><br><span class="line">+ 保证index位置值只出现一次</span><br><span class="line">    + 若index一样，后面即使不一样，排列组合也一样</span><br><span class="line">    + 若index头不一样，后面必然不一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184319057.png" alt="image-20220405184319057"></p><h2 id="22、括号生成"><a href="#22、括号生成" class="headerlink" title="22、括号生成"></a>22、括号生成</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184331643.png" alt="image-20220405184331643"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 生成指定数量小括号</span><br><span class="line">    + 合法</span><br><span class="line">    + 排列组合</span><br><span class="line">+ 总量：左括号3个，右括号3个</span><br><span class="line">+ 限制：当剩余数量相同（已经匹配完），必须选左括号</span><br><span class="line">+ 实现</span><br><span class="line">    + 特殊情况</span><br><span class="line">    + dfs递归（传入左括号，右括号剩余情况）</span><br><span class="line">        + 结束条件：最后一层，添加结果</span><br><span class="line">        + 情况判断（拆开for循环的选择，分别判断）</span><br><span class="line">            + 左括号大于0</span><br><span class="line">                + 本层选择左括号</span><br><span class="line">                + 递归下一层，左括号-1</span><br><span class="line">            + 右括号大于0，右不等于左</span><br><span class="line">                + 本层选择右括号</span><br><span class="line">                + 递归下一层，右括号-1</span><br><span class="line">        + 回溯，不需要恢复</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184406890.png" alt="image-20220405184406890"></p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>51、52、112、113</p><p>39、93</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 路径总和2</span><br><span class="line">    + 结束条件</span><br><span class="line">        + 边界条件：达到叶子节点停止</span><br><span class="line">        + 添加结果：路径和是否满足，满足则添加</span><br><span class="line">    + 参数：剩余选择的值总和</span><br><span class="line">+ 组合总和</span><br><span class="line">    + 找出总和为target的组合</span><br><span class="line">    + 元素可以选择多次！！</span><br><span class="line">    + dfs</span><br><span class="line">        + 参数：剩余值</span><br><span class="line">        + 根据剩余值，枚举可选择值</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DFS：</p><p>1、结束条件：边界条件，添加结果</p><p>2、每一层，for枚举选择</p><ul><li>选择、情况筛选</li><li>递归</li><li>回溯修改</li></ul><h1 id="高频题"><a href="#高频题" class="headerlink" title="高频题"></a>高频题</h1><h2 id="283、移动零"><a href="#283、移动零" class="headerlink" title="283、移动零"></a>283、移动零</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184543330.png" alt="image-20220405184543330"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 一趟遍历 + 双指针（保证相对顺序）</span><br><span class="line">    + 遇到非0的挪到前面</span><br><span class="line">        + i和cur交换</span><br><span class="line">        + 同时后移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184556090.png" alt="image-20220405184556090"></p><h2 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184605349.png" alt="image-20220405184605349"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力 n²</span><br><span class="line">    + 枚举全部情况</span><br><span class="line">+ 一次遍历</span><br><span class="line">    + 扫描到每一个数，判断前面有没有target-i的数（O(1)查找）</span><br><span class="line">        + map</span><br><span class="line">+ sort&amp;双指针（头尾）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184623995.png" alt="image-20220405184623995"></p><h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184632963.png" alt="image-20220405184632963"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力 O(n3)</span><br><span class="line">    + 枚举每个三元组</span><br><span class="line">    + 去重</span><br><span class="line">+ 暴力优化</span><br><span class="line">    + 1、sort排序</span><br><span class="line">    + 2、i遍历每个元素</span><br><span class="line">        + 去重</span><br><span class="line">            + 若i与前面重复，则跳过</span><br><span class="line">        + l和r指针指向后面区间的头尾</span><br><span class="line">        + while循环查找和</span><br><span class="line">            + 偏小</span><br><span class="line">                + 跳过相同元素</span><br><span class="line">                + l++</span><br><span class="line">            + 偏大</span><br><span class="line">                + 跳过相同元素</span><br><span class="line">                + r--</span><br><span class="line">    + 原理</span><br><span class="line">        + 定一值，获取新的target</span><br><span class="line">            + 在剩下区间搜索和为target，双指针法</span><br><span class="line">        + 区间</span><br><span class="line">+ 偏门做法（复杂）</span><br><span class="line">    + 尽可能排除不必要扫描</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184713294.png" alt="image-20220405184713294"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184717053.png" alt="image-20220405184717053"></p><h2 id="50、pow-x-n"><a href="#50、pow-x-n" class="headerlink" title="50、pow(x,n)"></a>50、pow(x,n)</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184726470.png" alt="image-20220405184726470"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力O(n)</span><br><span class="line">    + while循环</span><br><span class="line">+ 快速幂（分治）</span><br><span class="line">    + O(logn)</span><br><span class="line">    + 递归法</span><br><span class="line">        + 结束条件：n为0</span><br><span class="line">        + 递归拆分</span><br><span class="line">        + 结果相乘</span><br><span class="line">+ 递归：复杂度计算</span><br><span class="line">    + 非递归法</span><br><span class="line">        + 循环</span><br><span class="line">            + x——x2——x4——x8——x16</span><br><span class="line">            + 结果相乘，需要的参数为1，不需要的参数为0</span><br><span class="line">            + 根据n的二进制位判断0/1</span><br><span class="line">                + 负数的/2和&gt;&gt;1不同</span><br><span class="line">+ 快速幂补充</span><br><span class="line">    + 不能先算x的y次方再模（可能溢出）</span><br><span class="line">    + 使用公式</span><br><span class="line">        + 每次相乘之前都模z，相乘之后模z</span><br><span class="line">    + 非递归</span><br><span class="line">    + 递归</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184821403.png" alt="image-20220405184821403"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184832719.png" alt="image-20220405184832719"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184837058.png" alt="image-20220405184837058"></p><h2 id="面试题62、圆圈中最后剩下的数字"><a href="#面试题62、圆圈中最后剩下的数字" class="headerlink" title="面试题62、圆圈中最后剩下的数字"></a>面试题62、圆圈中最后剩下的数字</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184849853.png" alt="image-20220405184849853"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ 约瑟夫环问题</span><br><span class="line">    + 循环数n个数，删除</span><br><span class="line">    + 求最后一个数</span><br><span class="line">    + 环形链表解决</span><br><span class="line">        + 环形链表不好实现</span><br><span class="line">+ 数学公式解决</span><br><span class="line">    + 递归实现（自顶向下）</span><br><span class="line">        + 结束条件：n为1，返回0（需要剩下一个人）</span><br><span class="line">        + 公式递归</span><br><span class="line">    + 非递归实现（自底向上）</span><br><span class="line">        + 遍历人数</span><br><span class="line">            + 使用公式，从小到大递推</span><br><span class="line">+ 公式推导</span><br><span class="line">    + 先杀一个元素</span><br><span class="line">    + 剩下n-1个元素和n个元素，最后的元素相同</span><br><span class="line">        + 开始的索引不同，n-1个相比n偏移了m个位置</span><br><span class="line">        + 防止越界，最后模上长度</span><br><span class="line">    + 编号不从0开始：</span><br><span class="line">        + 正常算出最后元素，加上偏移位置即可</span><br><span class="line">            + 中间删除位置都是相对的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184935987.png" alt="image-20220405184935987"></p><h2 id="54、螺旋矩阵"><a href="#54、螺旋矩阵" class="headerlink" title="54、螺旋矩阵"></a>54、螺旋矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184942786.png" alt="image-20220405184942786"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 顺时针列出矩阵元素</span><br><span class="line">+ 思路</span><br><span class="line">    + 标识每一圈</span><br><span class="line">    + while循环每一圈</span><br><span class="line">        + 遍历top行：left到right</span><br><span class="line">            + top++</span><br><span class="line">        + 遍历right列：top到bottom</span><br><span class="line">            + right--</span><br><span class="line">        + 特殊处理：奇数行、偶数列情况</span><br><span class="line">            + top&gt;bottom || left &gt; right</span><br><span class="line">        + 遍历bottom行：right到left</span><br><span class="line">            + bottom--</span><br><span class="line">        + 遍历left列：bottom到top</span><br><span class="line">            + left++</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185000309.png" alt="image-20220405185000309"></p><h2 id="146、LRU缓存机制"><a href="#146、LRU缓存机制" class="headerlink" title="146、LRU缓存机制"></a>146、LRU缓存机制</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185011387.png" alt="image-20220405185011387"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+ LRU：最近最少使用</span><br><span class="line">    + 操作系统页面置换算法，选择LRU的页面淘汰</span><br><span class="line">+ 常用实现方式</span><br><span class="line">    + 哈希表 + 双向链表</span><br><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + hashmap(capacity)</span><br><span class="line">    + get()</span><br><span class="line">        + 元素存在</span><br><span class="line">            + 链表插入：</span><br><span class="line">            + 返回元素</span><br><span class="line">    + put()</span><br><span class="line">        + 条件判断</span><br><span class="line">            + 是否已经存在？更新值</span><br><span class="line">        + 容量达到capacity，淘汰算法：</span><br><span class="line">            + List存储最近使用的key</span><br><span class="line">                + 尾插，删除头元素</span><br><span class="line">            + 双向链表</span><br><span class="line">        + put</span><br><span class="line">+ 自己实现双向链表</span><br><span class="line">    + 准备</span><br><span class="line">        + 虚拟头、尾节点</span><br><span class="line">        + node类</span><br><span class="line">            + key、value、双向指针</span><br><span class="line">    + 节点被get、put修改、添加之后：更新优先级</span><br><span class="line">        + 头插法，插入到头结点的后面</span><br><span class="line">            + 删除节点deleteNode</span><br><span class="line">                + 后面的pre指向前面的node</span><br><span class="line">                + 前面的next指向后面的node</span><br><span class="line">            + 添加到头结点后面insertFirst</span><br><span class="line">                + 先指向后面的节点，再连接头节点</span><br><span class="line">    + put新元素，且容量已满：淘汰最后节点</span><br><span class="line">        + 删除最后一个node节点、删除map中的值</span><br><span class="line">            + map remove</span><br><span class="line">            + deleteNode</span><br><span class="line">        + insertFirst</span><br><span class="line">+ 主流原理</span><br><span class="line">    + 哈希表 + 双向链表（自己实现）</span><br><span class="line">    + 哈希表</span><br><span class="line">        + 存储k-v</span><br><span class="line">    + 双向链表</span><br><span class="line">        + 维护元素的使用优先级</span><br><span class="line">        + 新元素插到最前面</span><br><span class="line">        + 淘汰链表的最后一个元素</span><br><span class="line">    + get</span><br><span class="line">        + get时提升优先级（插入到链表最前面）</span><br><span class="line">    + put</span><br><span class="line">        + 修改</span><br><span class="line">            + 提升优先级</span><br><span class="line">        + 添加新元素，未满</span><br><span class="line">            + 直接put到map</span><br><span class="line">            + 提升优先级</span><br><span class="line">        + 添加新元素，已满</span><br><span class="line">            + 淘汰链表末尾元素</span><br><span class="line">            + 提升新元素的优先级</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185119211.png" alt="image-20220405185119211"></p><h2 id="7、整数反转"><a href="#7、整数反转" class="headerlink" title="7、整数反转"></a>7、整数反转</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185130224.png" alt="image-20220405185130224"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 1、转为字符串 + 双指针</span><br><span class="line">+ 2、取各个位数</span><br><span class="line">    + 循环倒序取出每一位（取模）</span><br><span class="line">        + 正序组合新的数</span><br><span class="line">        + 防止溢出（计算回去判断是否是之前的值），返回0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185144721.png" alt="image-20220405185144721"></p><h2 id="252、会议室"><a href="#252、会议室" class="headerlink" title="252、会议室"></a>252、会议室</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185152025.png" alt="image-20220405185152025"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 判断区间是否重叠</span><br><span class="line">    + 排序sort（开始时间）</span><br><span class="line">    + 判断前后两个区间</span><br><span class="line">        + 前面结束时间和后面开始时间是否符合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185203239.png" alt="image-20220405185203239"></p><h2 id="252、会议室2"><a href="#252、会议室2" class="headerlink" title="252、会议室2"></a>252、会议室2</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185209314.png" alt="image-20220405185209314"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ 避免会议冲突，至少需要多少间会议室</span><br><span class="line">    + 贪心算法</span><br><span class="line">+ 1、最小堆（小顶堆：获取最小值O(1)）</span><br><span class="line">    + 思路</span><br><span class="line">        + 排序</span><br><span class="line">        + 结束时间放到堆中</span><br><span class="line">        + 开始时间比较堆顶的结束时间</span><br><span class="line">            + 符合，则移除堆顶，结束时间进入堆</span><br><span class="line">            + 每次拿最小值：越小结束的越先利用</span><br><span class="line">    + 实现</span><br><span class="line">        + 准备：</span><br><span class="line">            + priorityqueue最小堆</span><br><span class="line">            + sort开始时间</span><br><span class="line">            + 添加0号会议结束时间</span><br><span class="line">    + 遍历每个会议</span><br><span class="line">        + 判断i的开始时间是否大于堆顶</span><br><span class="line">            + 堆顶：占用一个会议室的最早会议结束时间</span><br><span class="line">            + 大于</span><br><span class="line">                + 堆顶移除</span><br><span class="line">                + i的结束时间进入堆</span><br><span class="line">            + 小于</span><br><span class="line">                + 再开一间会议室</span><br><span class="line">                + i的结束时间进入堆</span><br><span class="line">+ 原理</span><br><span class="line">    + 排排序开始时间</span><br><span class="line">    + 堆中排序结束时间</span><br><span class="line">+ 2、分开排序（相当于提前排好堆）</span><br><span class="line">    + 分别排序开始、结束时间</span><br><span class="line">    + 扫描会议开始时间</span><br><span class="line">        + 只关心结束时间最短的</span><br><span class="line">        + 小于结束时间最小值，开一个房间</span><br><span class="line">        + 大于结束时间最小值，结束时间后移（堆顶变化）</span><br><span class="line">+ 原理：贪心 + 一次遍历</span><br><span class="line">    + 按照会议（排序好）进行遍历</span><br><span class="line">        + 维护全部会议室最小结束时间</span><br><span class="line">            + 若小于全部会议室结束时间，加会议室</span><br><span class="line">            + 若大于一间的结束时间，可以利用会议室</span><br><span class="line">                + 最小结束时间更新（上一个时间已被使用）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185315742.png" alt="image-20220405185315742"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185320766.png" alt="image-20220405185320766"></p><h2 id="11、盛最多水的容器"><a href="#11、盛最多水的容器" class="headerlink" title="11、盛最多水的容器"></a>11、盛最多水的容器</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185336392.png" alt="image-20220405185336392"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力</span><br><span class="line">    + 枚举任意两根柱子</span><br><span class="line">    + 维护最大值</span><br><span class="line">+ 双指针（首尾） + 一次遍历</span><br><span class="line">    + 小的指针移动</span><br><span class="line">        + 大柱子不动，为了求出最大值</span><br><span class="line">        + 减少不必要、小的组合</span><br><span class="line">    + 实现</span><br><span class="line">        + 循环（左指针小于右指针）</span><br><span class="line">            + 小于移动</span><br><span class="line">            + 求面积</span><br><span class="line">                + 宽度、高度（小的）</span><br><span class="line">+ 优化：跳过不必要组合</span><br><span class="line">    + 维护左右算过的min</span><br><span class="line">    + 小于min直接跳过</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185405367.png" alt="image-20220405185405367"></p><h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185415324.png" alt="image-20220405185415324"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ 1、求每一行能接多少</span><br><span class="line">+ 2、求每根柱子i上接多少水</span><br><span class="line">    + 思路</span><br><span class="line">        + i接的水取决于min（左、右柱子最大值）</span><br><span class="line">            + 左边右边必须有比i大的柱子</span><br><span class="line">        + 接水量：高度减去当前柱子高度</span><br><span class="line">    + 实现</span><br><span class="line">        + 准备</span><br><span class="line">            + 左、右最大柱子数组</span><br><span class="line">        + 求左边最大值数组（一次遍历 or 动态规划）</span><br><span class="line">            + 动态规划dp[i]：i左边的最大值</span><br><span class="line">                + dp[i] = max(high[i],dp[i-1])</span><br><span class="line">                    + i-1左边柱子最大值、i-1柱子</span><br><span class="line">            + 一次遍历：max记录最大值</span><br><span class="line">                + 遍历每个值，进行比较，维护max</span><br><span class="line">        + 求右边最大值数组</span><br><span class="line">        + 遍历每个柱子求接水量（第二个到倒数第二个）</span><br><span class="line">            + 获取左右大柱子最小的高度</span><br><span class="line">            + 若大于当前高度</span><br><span class="line">                + 接水：减去当前高度</span><br><span class="line">+ 优化</span><br><span class="line">    + 放到一个循环中</span><br><span class="line">    + 只记录前面的max，省略数组</span><br><span class="line">+ 3、双指针（左右边界） + 一次遍历</span><br><span class="line">    + while循环</span><br><span class="line">        + 取出较小的柱子lower</span><br><span class="line">            + 高度小的往前移动</span><br><span class="line">        + 维护每次较小的柱子的lowerMax</span><br><span class="line">        + 每个柱子能放多少水：lowerMax - lower</span><br><span class="line">    + 原理</span><br><span class="line">        + 往中间移动过程中，若小于外围的（两个柱子中的最小值）的最大值</span><br><span class="line">            + 说明这个柱子可以盛水</span><br><span class="line">        + lowermax一直更新，所以必是外围最大值（两边最小那个）</span><br><span class="line">+ 双指针相比之前</span><br><span class="line">    + 之前：先搞清楚了每个柱子左右最大值是多少</span><br><span class="line">        + 所以直接可以遍历取值计算</span><br><span class="line">    + 一次遍历：边遍历，边维护左边右边最大值</span><br><span class="line">        + 没有必要把每个位置左右都求出来</span><br><span class="line">        + 只需要遍历过程中max记录就行</span><br><span class="line">        + 因为每次都是取左右最小的那个</span><br><span class="line">            + 所以另一边一定大于当前最大值</span><br><span class="line">            + 所以只需要维护当前边的最大值进行计算即可 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185842638.png" alt="image-20220405185842638"></p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p>215、315、4、149、200</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ 刷题建议</span><br><span class="line">    + 10-15分钟没思路，看答案</span><br><span class="line">        + 读懂答案，照抄一遍（自己思路 + 作者思路）</span><br><span class="line">        + 自己手写一遍</span><br><span class="line">    + 每道题所有解法都看一遍！！</span><br><span class="line">    + 英文版讨论区靠前的代码（全世界大神写的）</span><br><span class="line">        + 优雅、精简</span><br><span class="line">    + 观摩中文、英文打败时间100%的提交代码</span><br><span class="line">+ 面试建议</span><br><span class="line">    + 沟通题目细节</span><br><span class="line">        + 时间、空间复杂度</span><br><span class="line">    + 口述：把能想到的专业术语关键词、解法都可以说出来</span><br><span class="line">        + 每种解法空间、时间复杂度</span><br><span class="line">    + 笔试、机试</span><br><span class="line">        + 写思路比代码更重要</span><br><span class="line">        + 写出空间时间复杂度</span><br><span class="line">+ 联想关键词</span><br><span class="line">    + 数组：</span><br><span class="line">        + 排序、双指针、三指针、扫描方向、一次遍历</span><br><span class="line">    + 链表：</span><br><span class="line">        + 虚拟头结点、双指针、快慢指针、翻转、中间节点</span><br><span class="line">    + 排列组合</span><br><span class="line">        + DFS</span><br><span class="line">    + 最值</span><br><span class="line">        + 贪心、排序、动态优化</span><br><span class="line">    + 对称\顺序</span><br><span class="line">        + 栈\队列</span><br><span class="line">    + 二叉树</span><br><span class="line">        + 递归、遍历</span><br><span class="line">    + 搜索数据要求O(1)时间</span><br><span class="line">        + 哈希表</span><br><span class="line">+ 完结撒花</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——贪心算法&amp;分治&amp;递归&amp;回溯&amp;动态规划</title>
      <link href="/2022/04/03/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95&amp;%E5%88%86%E6%B2%BB&amp;%E9%80%92%E5%BD%92&amp;%E5%9B%9E%E6%BA%AF&amp;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/04/03/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95&amp;%E5%88%86%E6%B2%BB&amp;%E9%80%92%E5%BD%92&amp;%E5%9B%9E%E6%BA%AF&amp;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1、贪心策略，也称为贪婪策略。</p><p>每一步都采取当前状态下最优的选择（局部最优解），从而希望推导出全局最优解。</p><p>2、贪心的应用：</p><p>哈夫曼树</p><p>最小生成树算法：Prim、Kruskal</p><p>最短路径算法：Dijkstra</p><h2 id="练习-最优装载问题（加勒比海盗）"><a href="#练习-最优装载问题（加勒比海盗）" class="headerlink" title="练习-最优装载问题（加勒比海盗）"></a>练习-最优装载问题（加勒比海盗）</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174436167.png" alt="image-20220403174436167"></p><p>贪心策略：每次选择最轻的上去（局部最优）</p><h2 id="练习-零钱兑换"><a href="#练习-零钱兑换" class="headerlink" title="练习-零钱兑换"></a>练习-零钱兑换</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174514977.png" alt="image-20220403174514977"></p><p>贪心策略：每次最优选择最大的（每次最优选择）</p><p>结果不一定全局最优。</p><h2 id="练习-01背包"><a href="#练习-01背包" class="headerlink" title="练习-01背包"></a>练习-01背包</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174509161.png" alt="image-20220403174509161"></p><p>贪心策略：</p><p>1、优先价值（价值最大）</p><p>2、优先重量（重量最轻）</p><p>3、优先价值密度（价值/重量）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174531358.png" alt="image-20220403174531358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + 物品类（价值、重量、价值密度）</span><br><span class="line">        + 物品数组（sort：根据价值密度排序！！！）</span><br><span class="line">        + 总重量、当前重量、总价值、装入物品list</span><br><span class="line">    + 遍历物品数组</span><br><span class="line">        + 装入物品（更新背包重量、价值、物品等）</span><br><span class="line">        + 结束条件：装满</span><br><span class="line">+ 动态规划：严谨做法</span><br><span class="line">+ 贪心算法很多时候作为辅助（直接用不一定是最优的）！！！</span><br><span class="line">+ 哈夫曼树</span><br><span class="line">    + 贪心策略：每次选择最小的两个作为子节点！！！（放到最下面）</span><br><span class="line">    + 保证距离远的权值小，权值大的距离进，实现最终结果小</span><br><span class="line">+ 最小生成树</span><br><span class="line">    + 普利姆（选路径小的相邻节点）、克鲁斯卡尔（选边，连成树）</span><br><span class="line">    + 贪心策略：每次选择最小的边！！！（在生成树的前提下）</span><br><span class="line">+ 最短路径</span><br><span class="line">    + 克鲁斯卡尔（到每个节点最短的距离）</span><br><span class="line">    + 贪心策略：找到最短路径！！！</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>递归：函数（方法）直接或间接调用自身。</p><p>栈空间：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173517519.png" alt="image-20220403173517519"></p><p>拆解问题：同类型小问题</p><p>1、把规模大的问题变成规模较小的同类型问题</p><p>2、由最小规模问题的解得出较大规模问题的解</p><p>3、很多链表、二叉树相关的问题都可以使用递归来解决</p><ul><li>因为链表、二叉树本身就是递归的结构（链表中包含链表，二叉树中包含二叉树）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173604958.png" alt="image-20220403173604958"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 使用套路</span><br><span class="line">    + 函数功能</span><br><span class="line">    + 原问题和子问题的关系</span><br><span class="line">        + f(n)和f(n-1)</span><br><span class="line">    + 结束条件</span><br><span class="line">        + 什么情况下直接得出解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173727258.png" alt="image-20220403173727258"></p><h2 id="练习-斐波那契数列"><a href="#练习-斐波那契数列" class="headerlink" title="练习-斐波那契数列"></a>练习-斐波那契数列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 斐波那契数列</span><br><span class="line">    + 结束条件：n&lt;2</span><br><span class="line">    + 递归：两个函数之和 </span><br><span class="line">    + 时间复杂度较大</span><br><span class="line">    + 调用过程</span><br><span class="line">        + 重复计算</span><br><span class="line">        + 自顶向下的调用过程</span><br><span class="line">+ 优化1</span><br><span class="line">    + 数组存放计算过的结果（临时缓存）</span><br><span class="line">        + 避免重复计算</span><br><span class="line">    + list[i]放斐波那契第i位的结果</span><br><span class="line">        + 简易缓存</span><br><span class="line">            + 若缓存不存在，则计算</span><br><span class="line">            + 若存在则直接返回</span><br><span class="line">+ 优化2</span><br><span class="line">    + 去除递归</span><br><span class="line">    + 遍历填数组即可</span><br><span class="line">+ 优化3</span><br><span class="line">    + 每次运算只需用到数组中的两个元素</span><br><span class="line">        + 滚动数组</span><br><span class="line">            + 减少空间利用</span><br><span class="line">    + 取模（&amp;）效率更高、求余</span><br><span class="line">+ 优化4</span><br><span class="line">    + 两个int保存数据</span><br><span class="line">    + 双指针</span><br><span class="line">+ 优化5</span><br><span class="line">+ 公式</span><br></pre></td></tr></table></figure><h2 id="递归转非递归"><a href="#递归转非递归" class="headerlink" title="递归转非递归"></a>递归转非递归</h2><p>100%可以转非递归。</p><p>模拟栈。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174118410.png" alt="image-20220403174118410"></p><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>最后一个动作是调用自身。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174144620.png" alt="image-20220403174144620"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174156578.png" alt="image-20220403174156578"></p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>选择不同的岔路口来通往目的地。很适合递归。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174233069.png" alt="image-20220403174233069"></p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>1、分治，也就是分而治之。</p><ul><li>将原问题分解成若干个规模较小的子问题（子问题和原问题的结构一样，只是规模不一样）</li><li>子问题又不断分解成规模更小的子问题，直到不能再分解（直到可以轻易计算出子问题的解）</li><li>利用子问题的解推导出原问题的解</li></ul><p>因此，分治策略非常适合用递归</p><p>2、子问题相互独立——分治</p><p>子问题有关系——动态规划</p><p>3、应用：</p><p>快排（不断分两个子问题）</p><p>归并（分开排序）</p><p>Karatsuba算法（大数乘法）</p><p>4、分治策略：</p><p>分成子问题</p><p>合并子问题</p><h2 id="练习-最大子序列"><a href="#练习-最大子序列" class="headerlink" title="练习-最大子序列"></a>练习-最大子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174854284.png" alt="image-20220403174854284"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力穷举（所有区间）：</span><br><span class="line">    + 双指针划子序列区间</span><br><span class="line">    + 暴力优化：</span><br><span class="line">        + 利用上一次sum统计和</span><br><span class="line">+ 分治</span><br><span class="line">    + 若在mid中间（左右延伸）</span><br><span class="line">        + 从mid加到左边，统计max</span><br><span class="line">        + 从mid加到右边，统计max</span><br><span class="line">    + 若在两边（取最大值）</span><br><span class="line">        + 递归mid，begin</span><br><span class="line">        + 递归mid，end</span><br><span class="line">    + 从三者取最大值</span><br><span class="line">+ 类似归并排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174933841.png" alt="image-20220403174933841"></p><h2 id="练习-大数乘法"><a href="#练习-大数乘法" class="headerlink" title="练习-大数乘法"></a>练习-大数乘法</h2><p>字符串一个一个相乘，一个一个相加</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175015229.png" alt="image-20220403175015229"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>1、求解最优化问题</p><p>2、通常的使用套路（一步一步优化）</p><p>暴力递归（自顶向下，出现了重叠子问题）</p><p>记忆化搜索（自顶向下）</p><p>递推（自底向上）</p><h2 id="练习-找零钱"><a href="#练习-找零钱" class="headerlink" title="练习-找零钱"></a>练习-找零钱</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175202831.png" alt="image-20220403175202831"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ dp(i)：凑到i最少硬币数</span><br><span class="line">+ 状态转移方程</span><br><span class="line">    + 考虑所有情况</span><br><span class="line">    + 每次选择都有四种情况</span><br><span class="line">+ 暴力递归</span><br><span class="line">    + 问题</span><br><span class="line">        + 自顶向下</span><br><span class="line">        + 子问题重复</span><br><span class="line">+ 记忆化搜索（临时缓存数组）</span><br><span class="line">    + 递归时携带数组（边界等写入数组）</span><br><span class="line">    + 问题</span><br><span class="line">        + 自顶向下</span><br><span class="line">        + 防止坐标越界</span><br><span class="line">+ 动态规划！！！</span><br><span class="line">    + 从第一个值往后推！！！（每个值都计算）</span><br><span class="line">        + 后面的值借助前面的结果！！！</span><br><span class="line">    + 所有的情况考虑进去</span><br><span class="line">    + 自底向上递推</span><br><span class="line">+ 求出方案所选硬币</span><br><span class="line">    + 借助数组记录（arr[n]：总价为n，最后选的硬币）！！！</span><br><span class="line">        + 若是最小值，修改数组（记录为本次选的硬币）</span><br><span class="line">    + 遍历查找数组</span><br><span class="line">        + 根据数组的值（选的硬币）确定前面的索引</span><br><span class="line">+ 用数组存储硬币面值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175220167.png" alt="image-20220403175220167"></p><h2 id="常规流程"><a href="#常规流程" class="headerlink" title="常规流程"></a>常规流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 定义状态（状态是原问题、子问题的解！！！）</span><br><span class="line">        + dp[i]的含义等</span><br><span class="line">    + 设置初始状态（边界）</span><br><span class="line">        + dp[0]的值等</span><br><span class="line">    + 确定状态转移方程</span><br><span class="line">        + 确定dp[i]和dp[i-1]的关系等！！！</span><br><span class="line">+ 题目特点</span><br><span class="line">    + 最优子结构</span><br><span class="line">        + 求解子问题的最优解，可以得到原问题的最优解</span><br><span class="line">    + 无后效性！！！</span><br><span class="line">        + 后面状态的演变不受前面的影响（未来与过去无关）</span><br><span class="line">        + 推导状态只关心前面状态的值，不关心推导过程（只关心值：状态转移方程！！！）</span><br></pre></td></tr></table></figure><h2 id="练习-最大连续子序列和"><a href="#练习-最大连续子序列和" class="headerlink" title="练习-最大连续子序列和"></a>练习-最大连续子序列和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 1、状态定义</span><br><span class="line">    + dp[i]：以nums[i]结尾的最大连续子序列的和</span><br><span class="line">+ 2、初始条件（边界：底层、最前面的值）</span><br><span class="line">    + dp[0] = num[0]</span><br><span class="line">+ 3、状态转移方程（由前面值推出来，后面推导与前面无关）</span><br><span class="line">    + 若前面的最大子序列大于0，则加上末尾</span><br><span class="line">    + 若前面最大小于0，只取末尾</span><br><span class="line">+ 步骤</span><br><span class="line">+ dp[i]</span><br><span class="line">+ dp[0]（前推后最底层）</span><br><span class="line">+ 遍历dp（转移条件！！！）</span><br><span class="line">    + 记录max</span><br><span class="line">+ 求dp(n)只关心前面的dp(n-1)，更前面的不关心，且没有作用了</span><br><span class="line">    + 优化</span><br><span class="line">        + 只用一个空间（后面的覆盖前面的值）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175339285.png" alt="image-20220403175339285"></p><h2 id="练习-最长上升子序列"><a href="#练习-最长上升子序列" class="headerlink" title="练习-最长上升子序列"></a>练习-最长上升子序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 求最大递增长度（非连续）</span><br><span class="line">+ 解法1：动态规划 </span><br><span class="line">    + 状态定义 dp[i]以num[i]结尾的长度</span><br><span class="line">    + 初始状态</span><br><span class="line">        + 每个dp[i]为1</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 遍历前面所有dp[j]</span><br><span class="line">            + 若大于num[j]，则dp[i] = dp[j] + 1</span><br><span class="line">            + 若小于，跳过</span><br><span class="line">+ 解法2：二分搜索★</span><br><span class="line">    + 遍历数组</span><br><span class="line">        + 若某一牌顶元素大于当前，放到其牌顶</span><br><span class="line">        + 最终牌堆数量就是最长上升子序列长度</span><br><span class="line">    + 原理</span><br><span class="line">        + 保证从左往右，牌顶的大小一定是从小到大的！！！</span><br><span class="line">        + 大的数（大于牌顶）往右移 </span><br><span class="line">        + 小的数（大于之前的牌顶，小于之后的牌顶）放到合适的前面合适的位置</span><br><span class="line">    + 牌堆数组</span><br><span class="line">        + 遍历每个元素时遍历牌堆数组，判断、赋值即可</span><br><span class="line">    + 优化</span><br><span class="line">        + 二分查找（数组有序），找到合适牌堆</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175410310.png" alt="image-20220403175410310"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175920416.png" alt="image-20220403175920416"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175942401.png" alt="image-20220403175942401"></p><h2 id="练习-最长公共子序列"><a href="#练习-最长公共子序列" class="headerlink" title="练习-最长公共子序列"></a>练习-最长公共子序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ 最长公共子序列（可以不连续）</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp(i,j) 前i个和前j个 公共子序列最大长度</span><br><span class="line">    + 初始化</span><br><span class="line">        + dp i 0 、dp j 0 初始值均为0</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 如果i j最后一个元素相等，则dp(i-1,j-1) + 1</span><br><span class="line">        + 如果不相等，最后一位元素对方前面元素是否有子序列</span><br><span class="line">            + i-1和j的公共子序列、i 和 j-1的公共子序列 的最大值</span><br><span class="line">+ 状态转移方程</span><br><span class="line">    + 总之最后一个dp(i,j) 或者dp(i)</span><br><span class="line">    + 要由前面的推出来i-1，j-1等之类的</span><br><span class="line">    + 必须到考虑所有情况</span><br><span class="line">+ 本次dp i j</span><br><span class="line">    + 往前推 i-1,j-1，可以比较最后一位，若相等则构成子序列，直接+1</span><br><span class="line">    + 若等于的情况，还不能确定是否有子序列</span><br><span class="line">        + 最后一位往前继续比较</span><br><span class="line">        + 则可以拿两个的最后一位分别和对面的前面进行比较</span><br><span class="line">+ 实现</span><br><span class="line">    + 递归解决</span><br><span class="line">        + 结束条件（i=0,j=0）</span><br><span class="line">        + 若相等，直接+1</span><br><span class="line">        + 若不相等，获取最大值（i-1,j和i,j-1两个公共子序列，是否有构成新的序列）</span><br><span class="line">+ 动态规划</span><br><span class="line">    + 保证表格的每个格子都能由前面推出来</span><br><span class="line">    + 一个格子一个格子推导</span><br><span class="line">+ 一个格子只跟前面三个格子有关</span><br><span class="line">    + 滚动数组</span><br><span class="line">        + 一维数组（记住一行数据即可！！！）</span><br><span class="line">    + 三个变量 ×</span><br><span class="line">        + 表是一行一行计算的，并非斜着计算</span><br><span class="line">+ 使用一维数组，需要提前保留左上角的值，否则被下面的覆盖</span><br><span class="line">    + 计算左边的数之前，保留左上角的值</span><br><span class="line">    + cur保存上面的值，给下次使用（当做左上角）</span><br><span class="line">+ 优化</span><br><span class="line">    + 使用长度小的作为一维数组</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175550122.png" alt="image-20220403175550122"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175537146.png" alt="image-20220403175537146"></p><h2 id="练习-最长公共子串"><a href="#练习-最长公共子串" class="headerlink" title="练习-最长公共子串"></a>练习-最长公共子串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义：dp(i,j) 以i-1、j-1结尾的长度</span><br><span class="line">        + 不存在则为0</span><br><span class="line">    + 状态初始化</span><br><span class="line">        + (i,0)、(j,0)均为0</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 若i-1 == j-1，dp ij = dp i-1,j-1 + 1</span><br><span class="line">            + 下一个两个字符相等</span><br><span class="line">        + 若不相等，则为0（结尾不相等则为0）</span><br><span class="line">    + 结果：max(dp i j )</span><br><span class="line">+ 每一行进行遍历</span><br><span class="line">+ 实现</span><br><span class="line">+ 画表，容易理解流程，配合参数</span><br><span class="line">    + 格子由左上角推得</span><br><span class="line">+ 一维数组优化</span><br><span class="line">    + 保留一行的左上角</span><br><span class="line">    + 先保留上面，作为下一个的左上角</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175645678.png" alt="image-20220403175645678"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175700075.png" alt="image-20220403175700075"></p><h2 id="练习-01背包-1"><a href="#练习-01背包-1" class="headerlink" title="练习-01背包"></a>练习-01背包</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175736475.png" alt="image-20220403175736475"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp(i,j) 前i件物品，承重为j的可以选的最大价值</span><br><span class="line">    + 状态初始化</span><br><span class="line">        + i,0 、j,0 为0</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 目标放在最后一件物品选还是不选：0/1</span><br><span class="line">        + 如果j&lt;weights[i]，无法选</span><br><span class="line">            + 则最后选择：dp(i,j) = dp(i-1,j)</span><br><span class="line">        + 如果可以选</span><br><span class="line">            + 如果最后一件物品不选，dp(i,j) = dp(i-1,j)</span><br><span class="line">            + 如果选最后一件，dp(i,j) = dp(i-1,j-weights[i-1]) + values[i-1]</span><br><span class="line">            + 则最后选择：dp(i,j) = max&#123; i 件商品0/1&#125;</span><br><span class="line">+ 实现</span><br><span class="line">+ 一行一行计算</span><br><span class="line">+ 一维数组优化</span><br><span class="line">    + 每行从右往左算（左右不依赖，只依赖上面、左上的某一个值）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175742522.png" alt="image-20220403175742522"></p><p>01背包-恰好装满：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 初始状态</span><br><span class="line">    + dp(i,0) = 0 dp(0,j) = 负无穷</span><br><span class="line">+ 必须从已经凑齐的格子过来（非负无穷），且下一个重量必须也凑齐（正数）</span><br><span class="line">    + 才能计算出正数</span><br><span class="line">+ 前面已经凑齐（只要值），只要这次凑齐就行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175823680.png" alt="image-20220403175823680"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、步骤</p><p>定义状态（状态是原问题、子问题的解）：比如定义 dp(i) 的含义</p><p>设置初始状态（边界）比如设置 dp(0) 的值</p><p>确定状态转移方程：比如确定 dp(i) 和 dp(i – 1) 的关系</p><p>2、可以用动态规划来解决的问题，通常具备2个特点。</p><p>最优子结构（最优化原理）</p><ul><li>通过求解子问题的最优解，可以获得原问题的最优解</li></ul><p>无后效性</p><ul><li><p>某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响（未来与过去无关）</p></li><li><p>在推导后面阶段的状态时，只关心前面阶段的具体状态值，不关心这个状态是怎么一步步推导出来的</p></li></ul><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>1、字符串 thank 的前缀（prefix）、真前缀（proper prefix）、后缀（suffix）、真后缀（proper suffix）</p><p>2、串匹配算法</p><p>蛮力（Brute Force） </p><p>KMP</p><p>Boyer-Moore</p><p>Karp-Rabin</p><p>Sunday</p><p>3、tlen 代表文本串 text 的长度，plen 代表模式串 pattern 的长度</p><h2 id="暴力1"><a href="#暴力1" class="headerlink" title="暴力1"></a>暴力1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + 循环 pi ti &lt; plen tlen 有一个成立</span><br><span class="line">        + 匹配成功</span><br><span class="line">            + pi++</span><br><span class="line">            + ti++</span><br><span class="line">        + 匹配失败</span><br><span class="line">            + ti -= pi - 1</span><br><span class="line">            + pi = 0</span><br><span class="line">    + true（pi == plen）</span><br><span class="line">+ 优化</span><br><span class="line">    + t 后面长度小于 p的长度</span><br><span class="line">    + 没有必要比较了，直接失败</span><br><span class="line">        + ti - pi &lt;= tlen - plen</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180344492.png" alt="image-20220403180344492"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180331607.png" alt="image-20220403180331607"></p><h2 id="暴力2"><a href="#暴力2" class="headerlink" title="暴力2"></a>暴力2</h2><p>ti含义：每一轮比较中，文本串首个比较字符的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + 双循环 ti、pi</span><br><span class="line">        + 匹配成功</span><br><span class="line">            + pi++</span><br><span class="line">        + 匹配失败</span><br><span class="line">            + pi = 0</span><br><span class="line">            + ti++</span><br><span class="line">        + pi == plen</span><br><span class="line">            + true</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180511861.png" alt="image-20220403180511861"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180459122.png" alt="image-20220403180459122"></p><p>暴力性能分析</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180517162.png" alt="image-20220403180517162"></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>next表的使用：</p><p>1、KMP会预先根据pattern生成一张next表</p><p>2、在哪个地方失败，pi设为next[]相应的值</p><p>3、ti不变</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180558819.png" alt="image-20220403180558819"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180608761.png" alt="image-20220403180608761"></p><p>得到next表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180622269.png" alt="image-20220403180622269"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180638917.png" alt="image-20220403180638917"></p><p>优化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180654371.png" alt="image-20220403180654371"></p><p>性能分析</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180707021.png" alt="image-20220403180707021"></p><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180758846.png" alt="image-20220403180758846"></p><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180847224.png" alt="image-20220403180847224"></p><h2 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180840183.png" alt="image-20220403180840183"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——百度、阿里、腾讯、京东等面试题</title>
      <link href="/2022/04/03/%E7%AE%97%E6%B3%95-%E7%99%BE%E5%BA%A6%E3%80%81%E9%98%BF%E9%87%8C%E3%80%81%E8%85%BE%E8%AE%AF%E3%80%81%E4%BA%AC%E4%B8%9C%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/03/%E7%AE%97%E6%B3%95-%E7%99%BE%E5%BA%A6%E3%80%81%E9%98%BF%E9%87%8C%E3%80%81%E8%85%BE%E8%AE%AF%E3%80%81%E4%BA%AC%E4%B8%9C%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="面试题01-09-字符串轮转"><a href="#面试题01-09-字符串轮转" class="headerlink" title="面试题01.09.字符串轮转"></a>面试题01.09.字符串轮转</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170011293.png" alt="image-20220403170011293"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 旋转词</span><br><span class="line">    + 特点</span><br><span class="line">        + 拼接两个相同的词</span><br><span class="line">        + 滑动窗口，每个窗口都包含全部词</span><br><span class="line">        + 判断是否为其子串</span><br><span class="line">            + contains()方法</span><br><span class="line">            + KMP</span><br><span class="line">+ 两个数据结构拼接</span><br><span class="line">    + 旋转</span><br><span class="line">    + 链表相交</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170035618.png" alt="image-20220403170035618"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170044049.png" alt="image-20220403170044049"></p><h2 id="572、另一个树的子树"><a href="#572、另一个树的子树" class="headerlink" title="572、另一个树的子树"></a>572、另一个树的子树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170053397.png" alt="image-20220403170053397"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ 判断一棵树是否是另一棵树的子树</span><br><span class="line">    + 遍历（非层次遍历）</span><br><span class="line">+ 暴力</span><br><span class="line">    + 找到子树</span><br><span class="line">    + 判断是否所有子节点都相等</span><br><span class="line">+ 二叉树序列化</span><br><span class="line">    + 遍历，序列化为字符串</span><br><span class="line">        + 如果序列化后是其子串</span><br><span class="line">            + 则为其子树</span><br><span class="line">+ 序列化</span><br><span class="line">    + 每个节点结束后加！（连在一起位数都无法判断）</span><br><span class="line">    + 空节点值为#（保证构建的二叉树唯一）</span><br><span class="line">        + 只有一个后序遍历无空节点，构建无数棵树</span><br><span class="line">+ 如何反序列化？</span><br><span class="line">+ 实现</span><br><span class="line">    + 两个树序列化</span><br><span class="line">        + 序列化（递归）</span><br><span class="line">            + 结束条件：节点为空，序列化#</span><br><span class="line">            + 序列化当前左子树</span><br><span class="line">            + 序列化右子树</span><br><span class="line">            + 拼接当前子树</span><br><span class="line">                + StringBuilder拼接字符串</span><br><span class="line">    + 判断是否为子串</span><br><span class="line">        + contains()</span><br><span class="line">+ 打印树</span><br><span class="line">+ 测试KMP</span><br><span class="line">    + contains改为KMP</span><br><span class="line">+ 前序遍历bug</span><br><span class="line">    + 解决：最前面再加个符号</span><br><span class="line">+ 二叉树序列化字符串</span><br><span class="line">    + 判断两个树的结构方面的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170155652.png" alt="image-20220403170155652"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170204117.png" alt="image-20220403170204117"></p><h2 id="242、有效的字母异位词"><a href="#242、有效的字母异位词" class="headerlink" title="242、有效的字母异位词"></a>242、有效的字母异位词</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170225236.png" alt="image-20220403170225236"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 两个字符串，所有字母都一样，字母的顺序不一样</span><br><span class="line">+ 1、map统计字符</span><br><span class="line">    + 统计每个字符的kv</span><br><span class="line">    + 判断map中是否还有值</span><br><span class="line">+ 2、数组统计字符（都是小写）轻量级</span><br><span class="line">    + askii码进行计算</span><br><span class="line">    + arr[26]统计所有字符的数量</span><br><span class="line">    + 实现</span><br><span class="line">        + 扫描数组</span><br><span class="line">            + 一个字符串，进行相加</span><br><span class="line">            + 一个字符串，进行相减</span><br><span class="line">                + 若数量小于0，则直接返回false</span><br><span class="line">        + 最后判断是否数组元素都为0</span><br><span class="line">+ 优化</span><br><span class="line">    + 继续空间换时间</span><br><span class="line">        + charAt()一直在调方法</span><br><span class="line">        + 字符串转为char[]数组</span><br><span class="line">        + 直接用索引进行取值，效率很快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170303602.png" alt="image-20220403170303602"></p><h2 id="151、翻转字符串里的单词"><a href="#151、翻转字符串里的单词" class="headerlink" title="151、翻转字符串里的单词"></a>151、翻转字符串里的单词</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170533557.png" alt="image-20220403170533557"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 1、消除字符串中多余空格</span><br><span class="line">    + 双指针</span><br><span class="line">        + 若为字符，赋值到前面</span><br><span class="line">        + 若为空格，且前面为字符，赋值空格</span><br><span class="line">            + flag标记：前一个字符是否为空格</span><br><span class="line">+ 2、获取字符串有效长度</span><br><span class="line">    + 若最后为空格，则为cur的位置-1</span><br><span class="line">    + 若最后为字符，则cur位置</span><br><span class="line">+ 3、方法：翻转指定范围字符串</span><br><span class="line">    + 左右边界为两个指针</span><br><span class="line">    + 循环（指针不重合）</span><br><span class="line">        + 左右交换指针值，指针归中</span><br><span class="line">+ 4、对整个字符串逆序</span><br><span class="line">+ 5、对每个单词进行逆序</span><br><span class="line">    + 扫描数组，记录前一个空格位置pre（哨兵）</span><br><span class="line">        + 发现空格时，结束了一个单词</span><br><span class="line">        + 单词在前一个空格和后一个空格之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170618225.png" alt="image-20220403170618225"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170624055.png" alt="image-20220403170624055"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170632372.png" alt="image-20220403170632372"></p><h2 id="3、无重复字符的最长子串"><a href="#3、无重复字符的最长子串" class="headerlink" title="3、无重复字符的最长子串"></a>3、无重复字符的最长子串</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170644411.png" alt="image-20220403170644411"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ 类似动态规划</span><br><span class="line">    + 以i结尾的最长无重复串</span><br><span class="line">    + 维护最大值即为结果</span><br><span class="line">+ 扫描字符</span><br><span class="line">    + 求以i结尾的最长不重复串</span><br><span class="line">        + 假设i-1的子串已经求出来（li到i-1不重复）</span><br><span class="line">            + li为i-1子串的起始位置，pi为i字符上一次出现的位置</span><br><span class="line">                + 如果li在pi右边</span><br><span class="line">                    + i的子串：li到i</span><br><span class="line">                + 如果li在pi左边</span><br><span class="line">                    + i的子串：pi+1到i</span><br><span class="line">                + 如果li==pi</span><br><span class="line">                    + i的子串：pi+1到i</span><br><span class="line">    + 记录每个字符上一次出现的位置（map：k-v、arr[]）</span><br><span class="line">    + 实现</span><br><span class="line">        + map</span><br><span class="line">        + 扫描每个字符（从1开始）</span><br><span class="line">            + 如果pi不存在（map中不存在），设置pi为-1，直接li为起始</span><br><span class="line">                + getOrDefault()</span><br><span class="line">            + 如果pi存在</span><br><span class="line">                + li小于或等于pi才改li的值为li+1</span><br><span class="line">                + 其他情况都li不变（li在右边）</span><br><span class="line">            + 维护max记录i到li子串的长度</span><br><span class="line">+ 优化</span><br><span class="line">    + arr[26] + ascii</span><br><span class="line">+ 想出来？</span><br><span class="line">    + 之前有经验！！</span><br><span class="line">    + 经历过，刷题越来越多</span><br><span class="line">        + 扫一眼就知道用什么思路！ </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170757314.png" alt="image-20220403170757314"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170803833.png" alt="image-20220403170803833"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>5、最长回文子串</p><p>72、编辑距离</p><p>1143、32、1048</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 二叉树序列化</span><br><span class="line">    + 序列化反序列化</span><br><span class="line">    + 判断两棵树的的相同结构</span><br><span class="line">+ 字符串查找子串</span><br><span class="line">    + KMP</span><br><span class="line">    + contains()</span><br><span class="line">+ 字符统计</span><br><span class="line">    + map</span><br><span class="line">    + 数组</span><br><span class="line">+ 结构拼接</span><br><span class="line">    + 字符串拼接</span><br><span class="line">        + 判断翻转</span><br><span class="line">    + 链表拼接</span><br><span class="line">        + 查找相交位置</span><br><span class="line">+ 翻转字符串</span><br><span class="line">+ 分割单词</span><br><span class="line">+ 哨兵pre</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170831008.png" alt="image-20220403170831008"></p><h2 id="面试题47、礼物的最大价值"><a href="#面试题47、礼物的最大价值" class="headerlink" title="面试题47、礼物的最大价值"></a>面试题47、礼物的最大价值</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170842706.png" alt="image-20220403170842706"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义：dp[i][j]：走到ij的最大价值</span><br><span class="line">    + 初始条件：首行首列，不能放在在循环递推</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 一行一行求</span><br><span class="line">        + 依靠上和左的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170858115.png" alt="image-20220403170858115"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170902652.png" alt="image-20220403170902652"></p><h2 id="121、买卖股票的最佳时机"><a href="#121、买卖股票的最佳时机" class="headerlink" title="121、买卖股票的最佳时机"></a>121、买卖股票的最佳时机</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171107378.png" alt="image-20220403171107378"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 求前面最低买入，和后面最高卖出</span><br><span class="line">+ 从卖的角度思考</span><br><span class="line">    + 每一天都有可能卖，求其最大利润</span><br><span class="line">        + 维护最大利润</span><br><span class="line">    + 扫描一遍 + 双指针</span><br><span class="line">        + 一个指针维护最小值</span><br><span class="line">        + 一个指针遍历</span><br><span class="line">            + 计算与最小值的利润</span><br><span class="line">+ 动态规划</span><br><span class="line">    + 求出相邻两天的价格差</span><br><span class="line">        + 转为：求最大连续子序列和问题</span><br><span class="line">            + dp[i]：以i结尾的最大子序列和</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171147347.png" alt="image-20220403171147347"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171154871.png" alt="image-20220403171154871"></p><h2 id="72、编辑距离"><a href="#72、编辑距离" class="headerlink" title="72、编辑距离"></a>72、编辑距离</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171206720.png" alt="image-20220403171206720"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp i j ：s1 [0,i)转为s2 [0,j)最少操作数</span><br><span class="line">            + s1 的前i个字符转为 s2 前j个字符 最少操作数</span><br><span class="line">    + 初始化</span><br><span class="line">        + [0][j]、[i][0]</span><br><span class="line">            + 最小操作数：i次（全部删除、插入）</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 按行推导</span><br><span class="line">            + dp[i][j]</span><br><span class="line">            + 上、左、左上三种情况推得</span><br><span class="line">        + 四种情况</span><br><span class="line">            + dp[i-1][j]转换过来：差一个字符，+ 1</span><br><span class="line">                + aa-&gt;bb = aaa -&gt; bb + 1</span><br><span class="line">                + 删除一个字符</span><br><span class="line">            + dp[i][j-1]转换过来：差一个字符，+ 1</span><br><span class="line">                + aa -&gt; b = aa -&gt; bb + 1</span><br><span class="line">                + 插入一个字符</span><br><span class="line">            + dp[i-1][j-1]转换过来：</span><br><span class="line">                + 如果最后一个字符相等：相比之前操作一次，替换一个字符，+1</span><br><span class="line">                    + aa -&gt; bb = aaa -&gt; bbb + 1 </span><br><span class="line">                        + bba -&gt; bbb + 1</span><br><span class="line">                    + 换掉一个字符</span><br><span class="line">                + 如果最后一个字符不相等：不操作</span><br><span class="line">                    + 最后一个字符不用动，只用操作前面的</span><br><span class="line">                    + aa -&gt; bb = aab + bbb</span><br><span class="line">                    + 不用操作</span><br><span class="line">        + 遍历，每次求最小转换情况</span><br><span class="line">+ 状态转移方程</span><br><span class="line">    + 考虑所有情况，可以从前面推导来的情况</span><br><span class="line">+ 优化</span><br><span class="line">    + 一维数组</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171325888.png" alt="image-20220403171325888"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171336257.png" alt="image-20220403171336257"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171344200.png" alt="image-20220403171344200"></p><h2 id="5、最长回文子串"><a href="#5、最长回文子串" class="headerlink" title="5、最长回文子串"></a>5、最长回文子串</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171355598.png" alt="image-20220403171355598"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力</span><br><span class="line">    + 双指针遍历所有子串n²</span><br><span class="line">        + 判断回文n</span><br><span class="line">    + 记录最大长度</span><br><span class="line"></span><br><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp[i][j]：s[i,j]是否为回文串</span><br><span class="line">    + 初始化</span><br><span class="line">        + i = j : T</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 子串长度为2，判断元素是否相同</span><br><span class="line">        + 子串长度大于2</span><br><span class="line">            + 如果[i+1,j-1]是回文串，且元素相等，那么是回文串</span><br><span class="line">                + 左右都减去一个元素且为回文串，判断最后元素</span><br><span class="line">    + 遍历方式</span><br><span class="line">        + 无法从左往右</span><br><span class="line">            + 由左下角推导的</span><br><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + str转换为char[]</span><br><span class="line">        + dp[i][j]</span><br><span class="line">    + 遍历（从下达到上，从左到右）</span><br><span class="line">        + 最后一个字符必须两个相等 &amp;&amp; （长度&lt;=2 或者 子串已经回文）</span><br><span class="line">        + 维护max</span><br><span class="line">+ 优化</span><br><span class="line">    + 一维数组</span><br><span class="line"></span><br><span class="line">+ 扩展中心法</span><br><span class="line">    + 以i为中心，向外拓展</span><br><span class="line">    + 以字符间隙为中心，向外拓展</span><br><span class="line">+ 实现</span><br><span class="line">    + 遍历扫描</span><br><span class="line">        + 不管是间隙为中心还是元素为中心，只要给左右元素的位置就行</span><br><span class="line">        + 扫描字符为中心的回文子串</span><br><span class="line">        + 扫描间隙为中心的回文子串</span><br><span class="line">            + 左右扫描回文子串方法</span><br><span class="line">                + 循环，条件（双指针移动且相等）</span><br><span class="line">                    + 双指针向外扩散（到边界出退出）</span><br><span class="line">        + 维护最大值</span><br><span class="line">+ 优化</span><br><span class="line">    + 1、减少没必要的扫描</span><br><span class="line">        + 已求得的最长子串长度大于剩下的字符长度</span><br><span class="line">    + 2、中间有很多没必要的扩散</span><br><span class="line">        + 实现</span><br><span class="line">            + l和r左右扩散</span><br><span class="line">                + 找到右边第一个不相等的元素为r</span><br><span class="line">                + 左边相邻元素为l</span><br><span class="line">            + 下一次i跳到r（跳到下一个不相等元素）</span><br><span class="line">                + 中间的元素已经相等，没必要扩散</span><br><span class="line">                    + 可能是1个、2个、3个，中间相等的元素（不管多少个）已经构成了回文串</span><br><span class="line">                + 只用从r和l的位置进行扩散就行！！！</span><br><span class="line">        + 原理：</span><br><span class="line">            + 核心：如果元素连续相等，变成一个拓展中心</span><br><span class="line">            + 可以省去间隙的拓展中心</span><br><span class="line">                + 因为每个都找右边第一个不相等的位置</span><br><span class="line">        + 代码</span><br><span class="line">            + 遍历数组</span><br><span class="line">                + 找到右边第一个不相等的位置r</span><br><span class="line">                    + while 判断</span><br><span class="line">                + 向左向右扩散</span><br><span class="line">                    + i -1、r</span><br><span class="line">                    + 循环双指针比较</span><br><span class="line">                + 拓展结束。计算长度，开始索引位置</span><br><span class="line"></span><br><span class="line">+ 马拉车算法</span><br><span class="line">    + 原理</span><br><span class="line">        + O(n)</span><br><span class="line">        + 预处理</span><br><span class="line">            + 头尾加特殊字符，元素之间加特殊字符</span><br><span class="line">        + m[i]</span><br><span class="line">            + 以i为拓展中心的最大回文子串的长度（不含#）</span><br><span class="line">            + 以i为拓展中心的最大回文子串的右半部分或左半部分的长度（包含#）</span><br><span class="line">        + 核心</span><br><span class="line">            + l、r、c：前一个回文串，li回文串对称位置，i当前位置</span><br><span class="line">            + 根据前面的回文串，进行对称，获取后面的回文串长度</span><br><span class="line">                + 根据对称性，前面的回文长度等于后面的长度</span><br><span class="line">                + 前提 i + m[i] &lt; r，不能超过对称范围</span><br><span class="line">                    + 超过对称范围，外面的元素不一定对称</span><br><span class="line">                    + 对称范围内的，若前半部分是回文，则后半部分是回文且相等的</span><br><span class="line">                        + 可以保证范围内的都对称，超出的不知道</span><br><span class="line">                    + 如果恰好 i + m[i] = r</span><br><span class="line">                        + 不一定等于前面的（最少情况），r右边的元素不知，也可能回文</span><br><span class="line">                        + 拓展中心法，继续比较</span><br><span class="line">            + 更新c、r、l等</span><br><span class="line">            + 维护max</span><br><span class="line">        + 总结：对称性质</span><br><span class="line">            + 对称范围内的，和对称的回文串长度相等</span><br><span class="line">            + 对称范围外的，需要拓展比较</span><br><span class="line">            + 四种情况</span><br><span class="line">                + i==r，拓展中心法</span><br><span class="line">                + i &lt; r</span><br><span class="line">                    + i + m[i] &lt; r，相等</span><br><span class="line">                    + i + m[i] = r，最少值，拓展计算</span><br><span class="line">                    + i + m[i] &gt; r，最少值，拓展计算</span><br><span class="line">    + 实现</span><br><span class="line">        + 预处理字符</span><br><span class="line">        + 遍历，从第一个元素到最后一个元素</span><br><span class="line">            + i==r</span><br><span class="line">            + i&lt;r，求出根据c求出li（对称）</span><br><span class="line">                + 直接赋值，至少是m[li]</span><br><span class="line">                + 拓展中心法</span><br><span class="line">                    + 双指针</span><br><span class="line">                + 更新c、r等</span><br><span class="line">            + 维护max：m[i]</span><br></pre></td></tr></table></figure><p>暴力</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171759900.png" alt="image-20220403171759900"></p><p>动态规划</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171835548.png" alt="image-20220403171835548"></p><p>拓展中心</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171805084.png" alt="image-20220403171805084"></p><p>拓展中心优化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171901259.png" alt="image-20220403171901259"></p><p>马拉车</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171915978.png" alt="image-20220403171915978"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171920775.png" alt="image-20220403171920775"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171927194.png" alt="image-20220403171927194"></p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>47、72、5优化</p><p>1143、53、42、322、面试08.11</p><p>300、70、198、213、674、63、122、123、188、714</p><p>1235、943、516、376</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 三步</span><br><span class="line">+ 状态定义</span><br><span class="line">+ 初始值</span><br><span class="line">+ 状态转移方程</span><br><span class="line">+ 优化</span><br><span class="line">+ 一维——&gt;变量</span><br><span class="line">+ 二维——&gt;变量、数组</span><br><span class="line">+ 注意递推关系</span><br><span class="line">+ 后无效性、前推后</span><br><span class="line">+ 考虑所有情况，可以从前面推导来的情况</span><br><span class="line">+ 拓展中心法</span><br><span class="line">+ 拓展中心法优化</span><br><span class="line">+ 右边第一个不同元素</span><br><span class="line">+ 马拉车算法</span><br><span class="line">+ 回文串对称</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>绝大多数题目解决：</p><p>递归 + 遍历（前序、中序、后序、层次）</p><h2 id="236、二叉树的最近公共祖先"><a href="#236、二叉树的最近公共祖先" class="headerlink" title="236、二叉树的最近公共祖先"></a>236、二叉树的最近公共祖先</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172009431.png" alt="image-20220403172009431"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ 两个节点最近的公共祖先</span><br><span class="line">    + 可以为节点本身</span><br><span class="line">    + 递归实现</span><br><span class="line">        + 方法功能：查找以root为根节点的p、q的最近公共祖先</span><br><span class="line">        + 递归</span><br><span class="line">            + 去左子树为根节点找</span><br><span class="line">            + 去右子树为根节点找</span><br><span class="line">        + 结束条件</span><br><span class="line">            + 根节点为空，或者根节点为目标元素</span><br><span class="line">                + 直接返回根节点</span><br><span class="line">            + 错误</span><br><span class="line">                + 如果左子树找到</span><br><span class="line">                    + 返回左子树</span><br><span class="line">                + 如果右子树找到</span><br><span class="line">                    + 返回右子树</span><br><span class="line">                + 如果左右子树都找不到，说明p、q节点在两个子树</span><br><span class="line">                    + root节点即为公共祖先，直接返回root</span><br><span class="line">            + 分析递归方法</span><br><span class="line">                + 如果pq在两边，递归左右子树不能返回null</span><br><span class="line">                    + 只有一个节点，应该直接返回该节点</span><br><span class="line">                    + 两边同时找到，说明根节点为公共祖先</span><br><span class="line">                + 如果pq都存在，返回公共祖先</span><br><span class="line">            + 正确</span><br><span class="line">                + 左右子树都找到，返回root</span><br><span class="line">                + 左子树或右子树找到，返回找到的节点</span><br><span class="line">                + 都没找到，返回null</span><br><span class="line">+ 原理</span><br><span class="line">    + 向下找到节点就返回节点，找不到就返回null</span><br><span class="line">    + 如果左右都找到，返回root</span><br><span class="line">    + 如果找到一个，说明找到的是节点，继续向上返回</span><br><span class="line">    + 如果为父子节点，父节点返回，其他路没有节点返回，父节点为祖先，符合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172108264.png" alt="image-20220403172108264"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172113711.png" alt="image-20220403172113711"></p><h2 id="99、恢复二叉搜索树"><a href="#99、恢复二叉搜索树" class="headerlink" title="99、恢复二叉搜索树"></a>99、恢复二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172122402.png" alt="image-20220403172122402"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ 二叉搜素树</span><br><span class="line">    + 中序遍历升序</span><br><span class="line">+ 错误交换后</span><br><span class="line">    + 中序遍历，找到一个或两个逆序对</span><br><span class="line">+ 实现</span><br><span class="line">    + 递归中序遍历，找到错误节点</span><br><span class="line">        + 退出条件：root为空</span><br><span class="line">        + 递归左子树</span><br><span class="line">        + 比较当前节点和上次遍历节点大小是否逆序</span><br><span class="line">            + 准备两个指针标记错误节点</span><br><span class="line">        + 递归右子树</span><br><span class="line">    + 交换node</span><br><span class="line">        + 交换值</span><br><span class="line">+ 二叉树的Morris遍历</span><br><span class="line">    + 使用前驱节点连线，进行回溯</span><br><span class="line">    + 线索二叉树</span><br><span class="line">+ Morris中序遍历</span><br><span class="line">    + 动态线索二叉树</span><br><span class="line">    + 把原来栈里的指针存放在了node里面</span><br><span class="line">    + 实现</span><br><span class="line">        + 循环（node不为空）</span><br><span class="line">            + 若左子树不为空</span><br><span class="line">                + 找到前驱节点</span><br><span class="line">                    + 左子树最右边</span><br><span class="line">                + 判断前驱节点右指针</span><br><span class="line">                    + 为空（第一次）</span><br><span class="line">                        + 前驱节点指向当前node</span><br><span class="line">                        + 移动到左子树</span><br><span class="line">                    + 不为空（第二次来）</span><br><span class="line">                        + 打印当前节点，清空指针</span><br><span class="line">                        + 移动到右子树</span><br><span class="line">            + 若左子树为空</span><br><span class="line">                + 打印当前节点</span><br><span class="line">                + 移动到右子树</span><br><span class="line">+ Morris查找错误节点</span><br><span class="line">    + 把打印改成find</span><br><span class="line">+ Morris前序、中序、后序遍历</span><br><span class="line">    + 空间复杂度O(1)</span><br><span class="line">        + 动态线索树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172244094.png" alt="image-20220403172244094"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172251620.png" alt="image-20220403172251620"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173035837.png" alt="image-20220403173035837"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——字节、美团、滴滴等面试题</title>
      <link href="/2022/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E8%8A%82%E3%80%81%E7%BE%8E%E5%9B%A2%E3%80%81%E6%BB%B4%E6%BB%B4%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E8%8A%82%E3%80%81%E7%BE%8E%E5%9B%A2%E3%80%81%E6%BB%B4%E6%BB%B4%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数组-amp-排序"><a href="#数组-amp-排序" class="headerlink" title="数组&amp;排序"></a>数组&amp;排序</h1><h2 id="88、合并两个有序数组"><a href="#88、合并两个有序数组" class="headerlink" title="88、合并两个有序数组"></a>88、合并两个有序数组</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132218661.png" alt="image-20220402132218661"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 双指针 + 倒排</span><br><span class="line">    + while循环（条件：下面退出）</span><br><span class="line">        + 上指针未结束，且大于下指针</span><br><span class="line">        + 上指针结束（提前走完）或者小于下面指针</span><br><span class="line">+ 其他方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132335462.png" alt="image-20220402132335462"></p><h2 id="75、颜色分类"><a href="#75、颜色分类" class="headerlink" title="75、颜色分类"></a>75、颜色分类</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132349617.png" alt="image-20220402132349617"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 对数组排序（只包含0、1、2），原地排序（常数空间），一趟扫描</span><br><span class="line">+ sort ×</span><br><span class="line">+ 排序算法 ×</span><br><span class="line">+ 双、三指针（扫描一趟常用解法）</span><br><span class="line">    + 左边两个指针（放0、遍历扫描），右边一个指针（放2），判断左边元素</span><br><span class="line">    + 遍历（条件：扫描退出）</span><br><span class="line">        + 扫描到1跳过</span><br><span class="line">            + 扫描移动</span><br><span class="line">        + 扫描到0与左指针交换</span><br><span class="line">            + 左指针移动</span><br><span class="line">            + 扫描移动（交换来的值已经被扫描过，无需判断）</span><br><span class="line">        + 扫描到2与右指针交换</span><br><span class="line">            + 右指针移动</span><br><span class="line">            + 扫描再次判断（交换来的值未被判断过）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132456943.png" alt="image-20220402132456943"></p><h2 id="16、部分排序"><a href="#16、部分排序" class="headerlink" title="16、部分排序"></a>16、部分排序</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132511409.png" alt="image-20220402132511409"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 找到中间未排序的区间（两边已排序）</span><br><span class="line">    + 寻找逆序对</span><br><span class="line">    + 找到最后一个逆序对</span><br><span class="line"></span><br><span class="line">+ 花时间思考值得</span><br><span class="line">    + 类似的问题就容易解决了</span><br><span class="line">    + 总结、思考</span><br><span class="line"></span><br><span class="line">+ 双指针</span><br><span class="line">    + 两边同时扫描</span><br><span class="line">        + 记录扫描过程的最大值</span><br><span class="line">            + 若比最大值小，则记录位置（逆序）</span><br><span class="line">            + 统计最大逆序位置</span><br><span class="line">        + 记录最左和最右的最大逆序位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132528787.png" alt="image-20220402132528787"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132725332.png" alt="image-20220402132725332"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>977、164-hard</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>双指针（常用）</p><p>左右扫描</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="203、移除链表元素"><a href="#203、移除链表元素" class="headerlink" title="203、移除链表元素"></a>203、移除链表元素</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133042094.png" alt="image-20220402133042094"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 删除节点</span><br><span class="line">+ 想象成一个全新的链表</span><br><span class="line">    + 如果是要删除的，跳过</span><br><span class="line">    + 如果不是，连接节点</span><br><span class="line">+ 双指针 + 遍历一遍</span><br><span class="line">    + 一指针遍历，一指针指向尾节点</span><br><span class="line">        + 若为删除节点，尾节点不动（非尾部）</span><br><span class="line">        + 若为正常节点，尾节点指向当前</span><br><span class="line">+ 虚拟头结点</span><br><span class="line">    + 方便删除第一个节点</span><br><span class="line">    + 遍历将next作为头</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133048665.png" alt="image-20220402133048665"></p><h2 id="2、两数相加"><a href="#2、两数相加" class="headerlink" title="2、两数相加"></a>2、两数相加</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133107021.png" alt="image-20220402133107021"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 虚拟头结点</span><br><span class="line">+ 遍历 + 进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133120030.png" alt="image-20220402133120030"></p><h2 id="160、相交链表"><a href="#160、相交链表" class="headerlink" title="160、相交链表"></a>160、相交链表</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133130614.png" alt="image-20220402133130614"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 快慢指针？</span><br><span class="line">+ 拼接链表</span><br><span class="line">    + 方法</span><br><span class="line">        + 下一个为null时移动到另一个头结点</span><br><span class="line">    + 原理</span><br><span class="line">        + 两个链表长度相同</span><br><span class="line">        + 最后的节点必然相同——相交之处（开始相同的地方）</span><br><span class="line">+ 遍历（相同时结束）</span><br><span class="line">    + 走完时到另一个节点头部</span><br><span class="line">    + 结束时指向第一个相同位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133157555.png" alt="image-20220402133157555"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133206604.png" alt="image-20220402133206604"></p><h2 id="86、分隔链表"><a href="#86、分隔链表" class="headerlink" title="86、分隔链表"></a>86、分隔链表</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133222815.png" alt="image-20220402133222815"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 两个虚拟头结点lhead、rhead</span><br><span class="line">    + lhead</span><br><span class="line">        + 小于的串进来</span><br><span class="line">        + ltai指向末尾</span><br><span class="line">    + rhead</span><br><span class="line">        + 大于的串进来</span><br><span class="line">        + rtail指向末尾</span><br><span class="line">+ 配合last指针记录每条链表尾部</span><br><span class="line">+ 遍历链表head指针</span><br><span class="line">    + 判断值进行链表串接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133249278.png" alt="image-20220402133249278"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133300887.png" alt="image-20220402133300887"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133346850.png" alt="image-20220402133346850"></p><h2 id="234、回文联表"><a href="#234、回文联表" class="headerlink" title="234、回文联表"></a>234、回文联表</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133354186.png" alt="image-20220402133354186"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 1、链表反转</span><br><span class="line">    + 1、创建新链表翻转</span><br><span class="line">    + 2、后半部分原地翻转</span><br><span class="line">        + 两个链表头</span><br><span class="line">        + 双指针比较</span><br><span class="line">        + 移动到null结束</span><br><span class="line">+ 实现</span><br><span class="line">    + 找到中间节点（常用操作）</span><br><span class="line">        + 奇数-中间的</span><br><span class="line">        + 偶数-左边的</span><br><span class="line">        + 快慢指针</span><br><span class="line">            + 快指针一次两步，慢指针一次一步</span><br><span class="line">            + 快指针到头，慢指针到中间节点</span><br><span class="line">    + 翻转链表（常用操作）</span><br><span class="line">        + 指针逆序</span><br><span class="line">    + 双指针遍历比较</span><br><span class="line">    + 若需不改变原结构</span><br><span class="line">        + 再次翻转</span><br><span class="line">+ 这些基本操作100%快速手写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133431358.png" alt="image-20220402133431358"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133439442.png" alt="image-20220402133439442"></p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>138、708、237、141、206、21、23</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 99%题目画图</span><br><span class="line">+ 虚拟头结点</span><br><span class="line">+ 快慢指针</span><br><span class="line">+ 求中心节点</span><br><span class="line">+ 判断环</span><br><span class="line">+ 多指针</span><br><span class="line">+ 链表翻转</span><br></pre></td></tr></table></figure><h1 id="栈-amp-队列"><a href="#栈-amp-队列" class="headerlink" title="栈&amp;队列"></a>栈&amp;队列</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133800668.png" alt="image-20220402133800668"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 栈</span><br><span class="line">    + 解决问题：对称</span><br><span class="line">        + 回文链表</span><br><span class="line">            + 前面半部分入栈</span><br><span class="line">            + 后面半部分出栈判断是否相等</span><br><span class="line">        + 有效的括号</span><br><span class="line">            + 左右括号对称</span><br><span class="line">+ 队列</span><br><span class="line">    + 解决问题：顺序</span><br><span class="line">+ 双端队列</span><br><span class="line">    + 头尾都可添加、删除元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133845463.png" alt="image-20220402133845463"></p><h2 id="155、最小栈"><a href="#155、最小栈" class="headerlink" title="155、最小栈"></a>155、最小栈</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133857251.png" alt="image-20220402133857251"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 获取栈中最小元素</span><br><span class="line">    + 要求常数时间</span><br><span class="line">    + 空间换时间</span><br><span class="line">+ 1、两个栈</span><br><span class="line">    + 正常栈、最小栈（只存放当前及以下层最小数据）</span><br><span class="line">    + 两个栈同步 入栈、出栈</span><br><span class="line">        + 最小栈入栈只放最小值</span><br><span class="line">+ 核心思想</span><br><span class="line">    + push的时候知道当前栈的最小值</span><br><span class="line">    + 维护一个最小值</span><br><span class="line">+ 优化</span><br><span class="line">    + 链表</span><br><span class="line">        + head节点始终保存最小值</span><br><span class="line">        + 头插法</span><br><span class="line">    + 实现</span><br><span class="line">        + 创建node类</span><br><span class="line">            + 保存当前值和最小值</span><br><span class="line">        + 初始化创建虚拟头结点</span><br><span class="line">            + 值为最大</span><br><span class="line">        + push</span><br><span class="line">            + 维护当前值和最小值（比较head）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133938307.png" alt="image-20220402133938307"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134001226.png" alt="image-20220402134001226"></p><h2 id="239、滑动窗口最大值"><a href="#239、滑动窗口最大值" class="headerlink" title="239、滑动窗口最大值"></a>239、滑动窗口最大值</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134021286.png" alt="image-20220402134021286"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">+ 为什么想不到方法？</span><br><span class="line">    + 做的题太少！！！</span><br><span class="line">    + 刷题</span><br><span class="line">    + 套路总结</span><br><span class="line">    </span><br><span class="line">+ 1:暴力</span><br><span class="line">    + 遍历，每次往后找k个元素</span><br><span class="line">+ 2:动态规划</span><br><span class="line"></span><br><span class="line">+ 3:双端队列</span><br><span class="line">    + 准备</span><br><span class="line">        + i指向滑动窗口最后一个元素</span><br><span class="line">        + w指向第一个元素</span><br><span class="line">        + node</span><br><span class="line">            + 索引和对应的值</span><br><span class="line">    + 实现</span><br><span class="line">        + 从队尾入队，前面小的都移除</span><br><span class="line">            + 队列中头元素最大</span><br><span class="line">        + 当w合法时，获取队列头元素（滑动窗口最大值）</span><br><span class="line">        + 移动后，判断队列头部元素索引是否有效</span><br><span class="line">        + 队列按索引、从大到小排列</span><br><span class="line">            + 只需遍历一遍O(n)</span><br><span class="line">    + 原理</span><br><span class="line">        + 索引判断节点位置，是否在滑动窗口</span><br><span class="line">        + 值进行大小比较，前面永远是滑动窗口最大值</span><br><span class="line">+ 思考每一步都是为了什么？</span><br><span class="line">    + 为什么这么做</span><br><span class="line">+ 必须要弄明白原理</span><br><span class="line">+ 双端队列（linkedlist双向链表）</span><br><span class="line">    + 遍历数组</span><br><span class="line">        + while判断队头元素和当前元素</span><br><span class="line">            + 删除全部比当前元素小的</span><br><span class="line">        + 将i加入队尾</span><br><span class="line">        + 检查窗口的索引是否合法</span><br><span class="line">            + 最后k-1个元素结束遍历</span><br><span class="line">        + 检查队头索引是否合法</span><br><span class="line">            + 不合法移除</span><br><span class="line">            + 最多只需删掉一个（每次移动都会删除）</span><br><span class="line">        + 设置窗口的最大值</span><br><span class="line">        + 队头元素设置到最大值数组中</span><br><span class="line">    + 为什么使用双端队列？</span><br><span class="line">        + 单调队列</span><br><span class="line">            + 递减</span><br><span class="line">        + 整体目的</span><br><span class="line">            + 一次遍历找到滑动窗口最值</span><br><span class="line">            + 找到最值：保证对头元素是当前滑动窗口的最大值</span><br><span class="line">                + 大的元素往前靠</span><br><span class="line">                + 小的元素没有意义</span><br><span class="line">                + 队列单调</span><br><span class="line">                </span><br><span class="line">+ 4:双指针</span><br><span class="line">    + 实现</span><br><span class="line">        + 先扫描前k个元素找到最值的索引</span><br><span class="line">        + 遍历数组</span><br><span class="line">            + 每次移动，维护最大值索引</span><br><span class="line">                + 若最值索引在滑动窗口内</span><br><span class="line">                    + 若最后元素大于最大值索引，设为最值</span><br><span class="line">                    + 若最后元素不大于，继续</span><br><span class="line">                + 若不在窗口内，则重新扫描k个窗口元素，找到最值，更新最大值索引</span><br><span class="line">            + 设置最大值索引为窗口最值</span><br><span class="line">    + 性能</span><br><span class="line">        + 对于递减数列，需要不断重新扫描最值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134322988.png" alt="image-20220402134322988"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134342003.png" alt="image-20220402134342003"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134406537.png" alt="image-20220402134406537"></p><h2 id="654、最大二叉树"><a href="#654、最大二叉树" class="headerlink" title="654、最大二叉树"></a>654、最大二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134420556.png" alt="image-20220402134420556"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ 先找最值</span><br><span class="line">    + 左边元素：左子树构建最大二叉树</span><br><span class="line">    + 右边元素：右子树构件最大二叉树</span><br><span class="line">+ 递归</span><br><span class="line">    + 找到指定范围中的根节点（最大值node）</span><br><span class="line">        + 结束条件：范围左右重合，直接返回</span><br><span class="line">            + 创建节点</span><br><span class="line">                + 遍历扫描</span><br><span class="line">                    + 找到最值的索引i</span><br><span class="line">        + 左子树递归找到根节点（left，i）</span><br><span class="line">        + 右子树递归找到根节点（i，right）</span><br><span class="line">        </span><br><span class="line">+ 变种题目</span><br><span class="line">+ 返回父节点索引数组</span><br><span class="line">+ 每个元素，两边找（都有可能）</span><br><span class="line">    + 往右找第一个比当前元素大的为父节点</span><br><span class="line">        + 当前为左子树</span><br><span class="line">    + 往左找第一个比当前元素大的为父节点</span><br><span class="line">        + 当前为右子树</span><br><span class="line">    + 取小的那个父节点</span><br><span class="line">        + 大的是上层的</span><br><span class="line"></span><br><span class="line">+ 单调栈</span><br><span class="line">    + 暴力，每个位置扫两遍</span><br><span class="line">    + 栈，扫描一遍</span><br><span class="line">    + 用栈求左、右边第一个比它大的数</span><br><span class="line">        + 实现</span><br><span class="line">            + 栈从下往上，维护单调递减</span><br><span class="line">            + 扫描元素</span><br><span class="line">                + 判断栈顶元素是否大于当前</span><br><span class="line">                    + 小于栈顶，入栈</span><br><span class="line">                        + 栈顶元素为当前元素的左边第一个比它大的数</span><br><span class="line">                    + 大于栈顶，弹出栈顶元素</span><br><span class="line">                        + 当前元素设置为栈顶元素的右边第一个比它大的数</span><br><span class="line">                        + 小的元素全部出栈</span><br><span class="line">                        + 保证大的入栈</span><br><span class="line">        + 原理</span><br><span class="line">            + 能push进去，下面的元素比它大</span><br><span class="line">            + 能pop出去，即将push的元素比它大</span><br><span class="line"></span><br><span class="line">+ 反过来求？</span><br><span class="line">    + 左小，右小</span><br><span class="line"></span><br><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + 栈、两个数组（左大右大）</span><br><span class="line">    + 扫描元素，维护两个数组</span><br><span class="line">        + 栈顶小，循环弹出</span><br><span class="line">            + 设置栈顶右大为当前元素</span><br><span class="line">        + 栈顶大，入栈</span><br><span class="line">            + 设置栈顶为当前元素左大</span><br><span class="line">            + 若栈顶为空，不设置</span><br><span class="line">    + 设置父节点索引</span><br><span class="line">        + 比较两个数组，找出最小的作为父节点</span><br><span class="line">+ 两个for循环跟一个一样</span><br><span class="line">+ 执行的东西一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134743050.png" alt="image-20220402134743050"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134753678.png" alt="image-20220402134753678"></p><h2 id="739、每日温度"><a href="#739、每日温度" class="headerlink" title="739、每日温度"></a>739、每日温度</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134834567.png" alt="image-20220402134834567"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ 找到下次升温天数（和右大索引距离）</span><br><span class="line">+ 直接复制过来，单调栈</span><br><span class="line">    + 只记录右大</span><br><span class="line">    + 设置结果为 右大索引-当前索引</span><br><span class="line">+ 倒推法</span><br><span class="line">+ 思路</span><br><span class="line">        + 从右往左遍历元素</span><br><span class="line">        + 类似动态规划</span><br><span class="line">            + 如果j&gt;i的值</span><br><span class="line">                + j是右大</span><br><span class="line">            + 如果j&lt;i的值</span><br><span class="line">                + 寻找j的右大继续判断</span><br><span class="line">                    + 找到j的右大作为新值</span><br><span class="line">                        + 找到j对应升温的天数</span><br><span class="line">                    + 如果仍然小，则继续移动，重新进入判断</span><br><span class="line">                    + 若找不到，则设为0</span><br><span class="line">            + 如果j=i的值</span><br><span class="line">                + 同样寻找j的右大</span><br><span class="line">    + 实现</span><br><span class="line">        + 倒序遍历数组</span><br><span class="line">            + 循环（true）：必然会结束</span><br><span class="line">                + 如果j比当前元素大的</span><br><span class="line">                    + j设为当前元素右大</span><br><span class="line">                    + 结束循环</span><br><span class="line">                + 如果不存在右大</span><br><span class="line">                    + 设为0</span><br><span class="line">                    + 结束循环</span><br><span class="line">                + 如果j与当前元素相等</span><br><span class="line">                    + 找到j的右大就是当前元素的右大</span><br><span class="line">                    + 结束循环</span><br><span class="line">                + 如果j小于当前元素</span><br><span class="line">                    + j的右大作为新j</span><br><span class="line">                    + 继续循环</span><br><span class="line">    + 原理</span><br><span class="line">        + 动态规划的思想</span><br><span class="line">        + 从后往前推</span><br><span class="line">            + 前面的值依靠后面的值进行计算</span><br><span class="line">    + 代码简化</span><br><span class="line">        + 等于情况和小于情况合并</span><br><span class="line">            + 等于也要找后面的元素，小于也要找后面的元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402135055695.png" alt="image-20220402135055695"></p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p>42接雨水、232…</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 单调栈</span><br><span class="line">    + 求左大右大</span><br><span class="line">+ 双端队列、单调队列</span><br><span class="line">    + 滑动窗口最值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——跳表、B+树</title>
      <link href="/2022/03/30/%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E3%80%81B+%E6%A0%91/"/>
      <url>/2022/03/30/%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E3%80%81B+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>有序链表搜索、添加、删除</p><ul><li>时间复杂度较高</li><li>二分搜索无法应用</li></ul><p>需要搜索、添加、删除快速的数据结构！！</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330225401357.png" alt="image-20220330225401357"></p><h2 id="跳表-1"><a href="#跳表-1" class="headerlink" title="跳表"></a>跳表</h2><p>相比较于红黑树</p><ul><li>实现、维护更加简单</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330225513786.png" alt="image-20220330225513786"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330225733600.png" alt="image-20220330225733600"></p><p>跳表：增加多层快速路线</p><p>一个node有多层</p><ul><li>每层每层都有一个指针</li><li>最下层指向下一个节点</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> P = <span class="number">0.25</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Comparator&lt;K&gt; comparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效层数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不存放任何K-V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">(Comparator&lt;K&gt; comparator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">first = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, MAX_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// first.nexts[3] == 21节点</span></span><br><span class="line"><span class="comment">// first.nexts[2] == 9节点</span></span><br><span class="line"><span class="comment">// first.nexts[1] == 6节点</span></span><br><span class="line"><span class="comment">// first.nexts[0] == 3节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key = 30</span></span><br><span class="line"><span class="comment">// level = 4</span></span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node.nexts[i].key &gt;= key</span></span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node.nexts[i].value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line">Node&lt;K, V&gt;[] prevs = <span class="keyword">new</span> Node[level];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123; <span class="comment">// 节点是存在的</span></span><br><span class="line">V oldV = node.nexts[i].value;</span><br><span class="line">node.nexts[i].value = value;</span><br><span class="line"><span class="keyword">return</span> oldV;</span><br><span class="line">&#125;</span><br><span class="line">prevs[i] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新节点的层数</span></span><br><span class="line"><span class="keyword">int</span> newLevel = randomLevel();</span><br><span class="line"><span class="comment">// 添加新节点</span></span><br><span class="line">Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value, newLevel);</span><br><span class="line"><span class="comment">// 设置前驱和后继</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newLevel; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= level) &#123;</span><br><span class="line">first.nexts[i] = newNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newNode.nexts[i] = prevs[i].nexts[i];</span><br><span class="line">prevs[i].nexts[i] = newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点数量增加</span></span><br><span class="line">size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算跳表的最终层数</span></span><br><span class="line">level = Math.max(level, newLevel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line">Node&lt;K, V&gt;[] prevs = <span class="keyword">new</span> Node[level];</span><br><span class="line"><span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line">prevs[i] = node;</span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) exist = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!exist) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要被删除的节点</span></span><br><span class="line">Node&lt;K, V&gt; removedNode = node.nexts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量减少</span></span><br><span class="line">size--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置后继</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; removedNode.nexts.length; i++) &#123;</span><br><span class="line">prevs[i].nexts[i] = removedNode.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新跳表的层数</span></span><br><span class="line"><span class="keyword">int</span> newLevel = level;</span><br><span class="line"><span class="keyword">while</span> (--newLevel &gt;= <span class="number">0</span> &amp;&amp; first.nexts[newLevel] == <span class="keyword">null</span>) &#123;</span><br><span class="line">level = newLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> removedNode.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (Math.random() &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyCheck</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;key must not be null.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(K k1, K k2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> comparator != <span class="keyword">null</span> </span><br><span class="line">? comparator.compare(k1, k2)</span><br><span class="line">: ((Comparable&lt;K&gt;)k1).compareTo(k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K, V&gt;[] nexts;</span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; right;</span></span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; down;</span></span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; top;</span></span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; left;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">nexts = <span class="keyword">new</span> Node[level];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> key + <span class="string">&quot;:&quot;</span> + value + <span class="string">&quot;_&quot;</span> + nexts.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">&quot;一共&quot;</span> + level + <span class="string">&quot;层&quot;</span>).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(node.nexts[i]);</span><br><span class="line">sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ 跳表</span><br><span class="line">    + 初始化</span><br><span class="line">        + node&lt;K,V&gt;：k、v、next[32]（最高）</span><br><span class="line">        + k：comparable</span><br><span class="line">        + head首节点</span><br><span class="line">            + 当前next[]有效层数</span><br><span class="line">    + get（查找）</span><br><span class="line">    + 顶层开始，每一层</span><br><span class="line">            + 找到大于目标元素为止！！！</span><br><span class="line">            + 退回到前一个元素</span><br><span class="line">                + 转到下一层</span><br><span class="line">            + 若node值相等，则返回</span><br><span class="line">    + put（添加）</span><br><span class="line">        + 查找前驱节点（插入位置）</span><br><span class="line">        + 创建新节点</span><br><span class="line">            + 设置层数</span><br><span class="line">                + 随机、抛硬币</span><br><span class="line">            + 每层指针修改</span><br><span class="line">                + 查找每层前驱节点</span><br><span class="line">                    + 每个往下走一层的节点！！！（与后面没有其他元素）</span><br><span class="line">                + 每层插入节点指向前驱的后继</span><br><span class="line">                + 每层的前驱指向插入节点</span><br><span class="line">            + 特殊情况（节点高度比全部都高！！！）</span><br><span class="line">                + 首节点响应层数指向插入节点</span><br><span class="line">                + 修改跳表高度</span><br><span class="line">    + remove（删除）</span><br><span class="line">        + 查找每层前驱节点</span><br><span class="line">            + 一直找到最后一层（保证找到每层前驱）</span><br><span class="line">        + 设置前驱节点指向删除节点的后继</span><br></pre></td></tr></table></figure><h2 id="跳表的层数"><a href="#跳表的层数" class="headerlink" title="跳表的层数"></a>跳表的层数</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230137119.png" alt="image-20220330230137119"></p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>b树的变体</p><p>b树：</p><ul><li><strong>平衡多路搜索树</strong></li><li>n阶，n个分叉，n-1个节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230448597.png" alt="image-20220330230448597"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230501240.png" alt="image-20220330230501240"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ b+树</span><br><span class="line">    + 分为内部节点和叶子节点</span><br><span class="line">        + 内部节点只存储key，不存储数据</span><br><span class="line">        + 叶子节点存储key和具体数据</span><br><span class="line">    + 所有叶子节点形成一条有序链表！！！</span><br></pre></td></tr></table></figure><h2 id="磁盘IO流程"><a href="#磁盘IO流程" class="headerlink" title="磁盘IO流程"></a>磁盘IO流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ 硬盘的分类</span><br><span class="line">    + 固态硬盘</span><br><span class="line">    + 机械硬盘</span><br><span class="line">        + 多个盘片</span><br><span class="line">            + 两个盘面（每个盘片）</span><br><span class="line">                + 一个读写磁头（每个盘面）</span><br><span class="line">                + 磁道（盘面中灰色圆环）</span><br><span class="line">                    + 扇区（每条磁道上的一个弧段）</span><br><span class="line">                        + 磁盘的最小读写单位</span><br><span class="line">                        + 通常512字节、4096字节</span><br><span class="line">                    + 扇区数相同</span><br><span class="line">                    + 外圈扇区面积大，记录数据密度小，浪费空间</span><br><span class="line">        + 存储容量计算</span><br><span class="line">        + 柱面（相同编号的磁道的圆柱）</span><br><span class="line">        + 磁盘块</span><br><span class="line">            + 操作系统最小读写单位（相邻多个扇区的组合）</span><br><span class="line">            + 一般4096字节</span><br><span class="line">            + 操作系统虚拟概念</span><br><span class="line">    + 查看硬盘信息</span><br><span class="line">+ 操作系统读取磁盘数据过程</span><br><span class="line">    + 操作系统将LBA（逻辑块地址：设备、磁头、磁道、扇区）传送给磁盘驱动器并启动读取命令</span><br><span class="line">    + 磁盘驱动器将磁头移动到正确的磁道，盘片开始旋转，将目标扇区旋转到磁头下</span><br><span class="line">    + 磁盘控制器将扇区数据等信息传送到一个处于磁盘界面的缓冲区</span><br><span class="line">    + 磁盘驱动器向操作系统发出“数据就绪”的信号</span><br><span class="line">    + 操作系统从磁盘界面的缓冲区读取数据</span><br><span class="line">+ 磁盘IO时间</span><br><span class="line">    + 寻道时间</span><br><span class="line">        + 操作系统软件层面可以优化</span><br><span class="line">        + 合理安排磁头移动，磁盘调度算法！！！</span><br><span class="line">    + 旋转延迟时间</span><br><span class="line">    + 数据传输时间</span><br></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>对比b树的优势：</p><ul><li>每个节点存储的key数量更多，树的高度更低！！！</li><li>所有具体数据都存储在叶子节点上，所以每次查询都要查到叶子节点，查询速度比较稳定</li><li>所有的叶子节点构成了一个有序链表，做区间查询时比较方便</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>给内部节点增加了指向兄弟节点的指针</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230746979.png" alt="image-20220330230746979"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——并查集、布隆过滤器</title>
      <link href="/2022/03/29/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2022/03/29/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>设计一个数据结构，能够快速执行2个操作</p><p>1、查询</p><p>2、连接</p><p>数组、链表、平衡二叉树、集合（Set）？</p><p>查询、连接的时间复杂度都是：O(n) </p><h2 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h2><p>并查集也叫作不相交集合（Disjoint Set）</p><p>并查集有2个核心操作 </p><ul><li><p>查找（Find）：查找元素所在的集合（这里的集合并不是特指Set这种数据结构，是指广义的数据集合） </p></li><li><p>合并（Union）：将两个元素所在的集合合并为一个集合</p></li></ul><p>有2种常见的实现思路：</p><p>Quick Find </p><ul><li><p>查找（Find）的时间复杂度：O(1) </p></li><li><p>合并（Union）的时间复杂度：O(n)</p></li></ul><p>Quick Union </p><ul><li><p>查找（Find）的时间复杂度：O(logn)，可以优化至 O （𝛼 （𝑛）） ，α(𝑛) &lt; 5 </p></li><li><p>合并（Union）的时间复杂度：O(logn)，可以优化至 O （𝛼 （n）） ，α(𝑛) &lt; 5</p></li></ul><p>如何存储数据：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121343572.png" alt="image-20220330121343572"></p><p>可以用数组实现的树形结构</p><h2 id="Quick-find"><a href="#Quick-find" class="headerlink" title="Quick find"></a>Quick find</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121553568.png" alt="image-20220330121553568"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121559153.png" alt="image-20220330121559153"></p><p>连接节点</p><ul><li>树的高度最多是2</li></ul><p>查找节点</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121814330.png" alt="image-20220330121814330"></p><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ 准备</span><br><span class="line">    + 父节点数组</span><br><span class="line">    + 初始化</span><br><span class="line">        + 每个节点单独一个集合（父节点为本身！！！）</span><br><span class="line">+ find查找所属的集合（根节点）</span><br><span class="line">    + 参数校验！！！</span><br><span class="line">    + 直接返回查找元素的父节点</span><br><span class="line">+ issame（查找是否同一集合）</span><br><span class="line">    + 判断父节点是否相等！！</span><br><span class="line">+ union（合并节点所属的集合！！）</span><br><span class="line">    + 参数校验（若已经是同一集合，直接返回）</span><br><span class="line">    + 遍历数组（查找父节点）！！！</span><br><span class="line">        + 将所有父节点为p1的改为父节点为p2！！（包括p1节点本身）</span><br><span class="line">+ 时间效率</span><br><span class="line">Find O(1)</span><br><span class="line">Union O(n)</span><br></pre></td></tr></table></figure><h2 id="Quick-union"><a href="#Quick-union" class="headerlink" title="Quick union"></a>Quick union</h2><p>时间效率：都是logn</p><p>连接原理：找到最根的节点进行连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ Union（node1，node2）</span><br><span class="line">    + （左边根节点）跟随（右边根节点）！！！</span><br><span class="line">        + 将v1的根节点嫁接到v2的根节点上</span><br><span class="line">    + 找到两个节点的根节点</span><br><span class="line">    + 根节点1父节点指向根节点2</span><br><span class="line"></span><br><span class="line">+ Find（找到集合根节点）</span><br><span class="line">    + 参数校验</span><br><span class="line">    + 向上循环查找即可（while）</span><br></pre></td></tr></table></figure><p>优化（基于quick union）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ 树不平衡、甚至链表情况</span><br><span class="line"></span><br><span class="line">+ 优化方案</span><br><span class="line">    + 1、基于size的优化</span><br><span class="line">        + 元素少的数 嫁接到 元素多的树！！！</span><br><span class="line">    + 2、基于rank的优化</span><br><span class="line">        + 矮的数 嫁接到 高的树！！！</span><br><span class="line"></span><br><span class="line">+ 基于size的优化</span><br><span class="line">    + 初始化</span><br><span class="line">        + size为1</span><br><span class="line">    + union</span><br><span class="line">        + 连接时判断根节点size</span><br><span class="line">            + size小的连接到size大的下面</span><br><span class="line">        + 修改size！！！</span><br><span class="line">            + 大的根节点size相应增加</span><br><span class="line">    + 问题</span><br><span class="line">        + 树不平衡无法解决</span><br><span class="line"></span><br><span class="line">+ 基于rank的优化！！！</span><br><span class="line">    + 初始化</span><br><span class="line">        + 每个集合rank（高度）为1</span><br><span class="line">        + 在union时修改即可</span><br><span class="line">    + union</span><br><span class="line">        + 连接时判断根节点rank</span><br><span class="line">            + rank小的根节点连接到rank大的下面</span><br><span class="line">            + rank相等时！！！</span><br><span class="line">                + 左边嫁接到右边</span><br><span class="line">                + 修改rank（其他情况下嫁接后rank不变）</span><br><span class="line">                    + 右边的rank+1即可！！</span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 树的高度越来越高</span><br><span class="line">    + find效率变慢</span><br><span class="line"></span><br><span class="line">+ find时路径上的所有节点都指向根节点</span><br><span class="line">    + 降低树的高度</span><br><span class="line">    + 查找越多，越接近2层</span><br><span class="line">    + union、find时效率提升</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122034632.png" alt="image-20220330122034632"></p><p>find实现（每个节点指向其祖父）</p><ul><li>保存父节点继续循环</li></ul><h2 id="路径分裂"><a href="#路径分裂" class="headerlink" title="路径分裂"></a>路径分裂</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122107739.png" alt="image-20220330122107739"></p><h2 id="路径减半"><a href="#路径减半" class="headerlink" title="路径减半"></a>路径减半</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122117242.png" alt="image-20220330122117242"></p><p>find（路径减半）</p><ul><li>保存祖父，继续循环（跳过父节点）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122131976.png" alt="image-20220330122131976"></p><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>实现</p><p>1、hash计算</p><p>2、链表+映射（map）</p><ul><li>node(value、parent、rank)</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Quick Union - 基于rank的优化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind_QU_R</span> <span class="keyword">extends</span> <span class="title">UnionFind_QU</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind_QU_R</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(capacity);</span><br><span class="line"></span><br><span class="line">ranks = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ranks.length; i++) &#123;</span><br><span class="line">ranks[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p1 = find(v1);</span><br><span class="line"><span class="keyword">int</span> p2 = find(v2);</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ranks[p1] &lt; ranks[p2]) &#123;</span><br><span class="line">parents[p1] = p2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[p1] &gt; ranks[p2]) &#123;</span><br><span class="line">parents[p2] = p1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parents[p1] = p2;</span><br><span class="line">ranks[p2] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quick Union - 基于rank的优化 - 路径压缩(Path Compression)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPC</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// v == 1, parents[v] == 2</span></span><br><span class="line">rangeCheck(v);</span><br><span class="line"><span class="keyword">if</span> (parents[v] != v) &#123;</span><br><span class="line">parents[v] = find(parents[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parents[v];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quick Union - 基于rank的优化 - 路径减半(Path Halving)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPH</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">rangeCheck(v);</span><br><span class="line"><span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">parents[v] = parents[parents[v]];</span><br><span class="line">v = parents[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quick Union - 基于rank的优化 - 路径分裂(Path Spliting)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">rangeCheck(v);</span><br><span class="line"><span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line"><span class="keyword">int</span> p = parents[v];</span><br><span class="line">parents[v] = parents[parents[v]];</span><br><span class="line">v = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">搭配建议：</span><br><span class="line"></span><br><span class="line">1、Quick Union</span><br><span class="line"></span><br><span class="line">2、基于 rank 的优化</span><br><span class="line"></span><br><span class="line">3、Path Halving 或 Path Spliting</span><br></pre></td></tr></table></figure><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h2><p>如果要经常判断 1 个元素是否存在，你会怎么做？</p><p>1、很容易想到使用哈希表（HashSet、HashMap），将元素作为 key 去查找</p><p>时间复杂度：O(1)，但是空间利用率不高，需要占用比较多的内存资源</p><p>2、是否存在时间复杂度低、占用内存较少的方案？</p><p>布隆过滤器（Bloom Filter）</p><h2 id="布隆过滤器-1"><a href="#布隆过滤器-1" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>1970年由布隆提出</p><ul><li>它是一个空间效率高的概率型数据结构，可以用来告诉你：一个元素一定不存在或者可能存在</li><li><strong>二进制向量 + hash函数组成</strong></li></ul><p>优缺点</p><ul><li><p>优点：空间效率和查询时间都远远超过一般的算法</p></li><li><p>缺点：有一定的误判率、删除困难</p></li></ul><p>它实质上是一个很长的二进制向量和一系列随机映射函数（Hash函数）</p><p>常见应用：</p><p>网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统、解决缓存穿透问题</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122743580.png" alt="image-20220330122743580"></p><p><strong>二进制向量 + hash函数组成</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 查找元素是否存在</span><br><span class="line">    + 全部哈希函数索引有一个不为1，不存在 √</span><br><span class="line">    + 全部哈希函数都为1，存在（有一定概率不存在）</span><br><span class="line"></span><br><span class="line">+ 索引：二进制</span><br><span class="line">+ 降低误判率：减少哈希冲突</span><br><span class="line">    + 数组加长</span><br><span class="line">    + hash函数增加</span><br></pre></td></tr></table></figure><p>误判率计算</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122812353.png" alt="image-20220330122812353"></p><p>根据误判率、数据规模</p><ul><li>推导二进制位、hash函数个数</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>Guava: Google Core Libraries For Java</p><p><a href="https://mvnrepository.com/artifact/com.google.guava/guava">https://mvnrepository.com/artifact/com.google.guava/guava</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制向量的长度(一共有多少个二进制位)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> bitSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] bits;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希函数的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数据规模</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 误判率, 取值范围(0, 1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span> || p &lt;= <span class="number">0</span> || p &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;wrong n or p&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ln2 = Math.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 求出二进制向量的长度</span></span><br><span class="line">bitSize = (<span class="keyword">int</span>) (- (n * Math.log(p)) / (ln2 * ln2));</span><br><span class="line"><span class="comment">// 求出哈希函数的个数</span></span><br><span class="line">hashSize = (<span class="keyword">int</span>) (bitSize * ln2 / n);</span><br><span class="line"><span class="comment">// bits数组的长度</span></span><br><span class="line">bits = <span class="keyword">new</span> <span class="keyword">long</span>[(bitSize + Long.SIZE - <span class="number">1</span>) / Long.SIZE];</span><br><span class="line"><span class="comment">// 每一页显示100条数据, pageSize</span></span><br><span class="line"><span class="comment">// 一共有999999条数据, n</span></span><br><span class="line"><span class="comment">// 请问有多少页 pageCount = (n + pageSize - 1) / pageSize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">nullCheck(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用value生成2个整数</span></span><br><span class="line"><span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line"><span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line"><span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">combinedHash = ~combinedHash;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 生成一个二进位的索引</span></span><br><span class="line"><span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line"><span class="comment">// 设置index位置的二进位为1</span></span><br><span class="line"><span class="keyword">if</span> (set(index)) result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   101010101010010101</span></span><br><span class="line"><span class="comment">// | 000000000000000100   1 &lt;&lt; index</span></span><br><span class="line"><span class="comment">//   101010111010010101</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个元素是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">nullCheck(value);</span><br><span class="line"><span class="comment">// 利用value生成2个整数</span></span><br><span class="line"><span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line"><span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line"><span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">combinedHash = ~combinedHash;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 生成一个二进位的索引</span></span><br><span class="line"><span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line"><span class="comment">// 查询index位置的二进位是否为0</span></span><br><span class="line"><span class="keyword">if</span> (!get(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置index位置的二进位为1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line"><span class="keyword">int</span> bitValue = <span class="number">1</span> &lt;&lt; (index % Long.SIZE);</span><br><span class="line">bits[index / Long.SIZE] = value | bitValue;</span><br><span class="line"><span class="keyword">return</span> (value &amp; bitValue) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看index位置的二进位的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true代表1, false代表0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line"><span class="keyword">return</span> (value &amp; (<span class="number">1</span> &lt;&lt; (index % Long.SIZE))) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nullCheck</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Value must not be null.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 不提供删除功能（保证查询高效）</span><br><span class="line"></span><br><span class="line">+ 布隆过滤器</span><br><span class="line">    + 构造</span><br><span class="line">        + 利用long[]作为二进制向量</span><br><span class="line">        + 求出二进制位数、hash函数个数</span><br><span class="line">        + 根据数据规模、误判率</span><br><span class="line">+ 添加元素</span><br><span class="line">        + 原始</span><br><span class="line">            + hashcode()得到元素的hash值</span><br><span class="line">            + hash函数计算生成索引</span><br><span class="line">        + 采用谷歌的实现</span><br><span class="line">            + 生成哈希，并将索引设为1</span><br><span class="line">    + 判断元素是否存在</span><br><span class="line">        + 查询哈希的index是否为1</span><br><span class="line">            + 若有0，则返回false</span><br><span class="line">+ 设置指定索引为1！！！</span><br><span class="line">    + 找到long数组对应的位置</span><br><span class="line">    + 按位或</span><br><span class="line">+ 查看index位置的二进制值！！！</span><br><span class="line">    + 找到long数组对应的位置</span><br><span class="line">    + 按位与</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——读写锁原理&amp;乐观读锁&amp;CHM原理&amp;阻塞队列原理</title>
      <link href="/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86&amp;%E4%B9%90%E8%A7%82%E8%AF%BB%E9%94%81&amp;CHM%E5%8E%9F%E7%90%86&amp;%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86&amp;%E4%B9%90%E8%A7%82%E8%AF%BB%E9%94%81&amp;CHM%E5%8E%9F%E7%90%86&amp;%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ReentrantReadWriteLock原理"><a href="#ReentrantReadWriteLock原理" class="headerlink" title="ReentrantReadWriteLock原理"></a>ReentrantReadWriteLock原理</h1><p>t1 w.lock t2 r.lock</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145600222.png" alt="image-20220320145600222"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145619378.png" alt="image-20220320145619378"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145624167.png" alt="image-20220320145624167"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">+ 读写锁原理</span><br><span class="line">    + 使用的同一个sycn同步器</span><br><span class="line">    + t1 w.lock 写锁</span><br><span class="line">        + 与可重入锁基本相同</span><br><span class="line">        + state低16位写锁，高16位读锁</span><br><span class="line">        + tryacquire</span><br><span class="line">            + 这段看书没懂，现在终于懂了</span><br><span class="line">            + 判断有无：读锁、写锁（非本线程）</span><br><span class="line">    + t2 r.lock</span><br><span class="line">        + 读源码最好的办法是写个小栗子然后通过idea调试阅读，直接读太慢，还容易理解错了</span><br><span class="line">        + 判断有无写锁、当前线程的写锁</span><br><span class="line">        + 阻塞，和独占锁差不多</span><br><span class="line">            + 只是节点类型不同：node类型为shared</span><br><span class="line">            + 判断是否为老二</span><br><span class="line">                + 重试尝试获取</span><br><span class="line">            + 前驱设为-1（哨兵）</span><br><span class="line">            + 再次进入循环，尝试获取</span><br><span class="line">                + 一共三次尝试</span><br><span class="line">            + park阻塞</span><br><span class="line">    + t3 r.lock  t4 w.lock</span><br><span class="line">        + 进入阻塞队列</span><br><span class="line">            + 读锁类型为shared</span><br><span class="line">            + 写锁为独占</span><br><span class="line">            + node state</span><br><span class="line">                + 前面为-1</span><br><span class="line">                + 最后为0</span><br><span class="line">    + t1 w.unlock</span><br><span class="line">        + tryrelease</span><br><span class="line">            + state--</span><br><span class="line">            + 检查是否有读锁</span><br><span class="line">            + 唤醒节点</span><br><span class="line">            + 老二唤醒</span><br><span class="line">                + 非公平锁体现在持有锁的线程释放锁后，外来线程直接去尝试获取锁，而不会去判断队列是否有线程，这时队列中的线程和外来线程争抢锁，就是非公平的</span><br><span class="line">                + 公平锁体现在外来线程要获取锁时，会先判断队列有没有线程阻塞，有就自己去队列排队，不会去尝试获取锁</span><br><span class="line">            + 老二继续循环，tryacquire获取读锁</span><br><span class="line">                + state高位变成1</span><br><span class="line">                + 讲到也不细，必须自己调试源码</span><br><span class="line">                + 关键是思考，多读源码</span><br><span class="line">                + setHead(node)之后的代码的意思是，当阻塞队列中有多个连续的读线程时，会传播式地逐一唤醒，if(s.isShared())&#123;doReleaseShared()&#125;这段代码是关键</span><br><span class="line">            + 拿到下个node，若为shared</span><br><span class="line">                + 把哨兵节点状态改为0</span><br><span class="line">                    + 避免其他线程干扰</span><br><span class="line">                + 继续唤醒shared node</span><br><span class="line">                    + 继续循环，获取锁tryacquire</span><br><span class="line">                    + 读锁计数（高位）+1</span><br><span class="line">                    + 循环唤醒节点方法</span><br><span class="line">                        + 判断下一个node是否为shared</span><br><span class="line">                        ...</span><br><span class="line">    + t2 r.unlock t3 r.unlock</span><br><span class="line">        + tryreleaseshare</span><br><span class="line">            + 状态-1</span><br><span class="line">                + 若不为0，其他读锁继续-1</span><br><span class="line">            + 读state为0</span><br><span class="line">                + 解锁流程</span><br><span class="line">                    + 哨兵节点状态-1改为0</span><br><span class="line">                    + 后继节点唤醒unpark</span><br><span class="line">                        + 循环继续，当前是老二，获取锁tryacquire</span><br><span class="line">                        + 当前node作为哨兵</span><br><span class="line">                        + 写state状态修改</span><br></pre></td></tr></table></figure><h1 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145720741.png" alt="image-20220320145720741"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ StamedLock</span><br><span class="line">    + 作用</span><br><span class="line">        + 增加读的性能</span><br><span class="line">        + 配合戳使用</span><br><span class="line">            + 加锁返回戳</span><br><span class="line">            + 用戳解锁</span><br><span class="line">            + 乐观读</span><br><span class="line">                + 验戳，锁升级</span><br><span class="line">    + 演示</span><br><span class="line">        + 乐观读，戳不变，未被修改读取成功</span><br><span class="line">        + 戳改变，锁升级</span><br><span class="line">            + 真正加读锁，与写锁互斥</span><br><span class="line">        + 读读</span><br><span class="line">            + 乐观读等于无锁读取</span><br><span class="line">        + 读写</span><br><span class="line">            + 乐观读锁验证戳失败</span><br><span class="line">            + 加读锁，进入阻塞</span><br><span class="line">            + 写锁释放后，读锁加成功</span><br><span class="line">                + 读取最新值</span><br><span class="line">        + 缺点：</span><br><span class="line">            + 无条件变量</span><br><span class="line">            + 不支持可重入</span><br></pre></td></tr></table></figure><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145742093.png" alt="image-20220320145742093"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+ Semaphore</span><br><span class="line">    + 作用</span><br><span class="line">        + 信号量</span><br><span class="line">            + 限制同时访问共享资源的线程上限</span><br><span class="line">    + 演示</span><br><span class="line">        + acquire获取信号量</span><br><span class="line">    + 应用</span><br><span class="line">        + 简单限流（单机）</span><br><span class="line">        + 限制线程数，而非资源数</span><br><span class="line">            + 适合一个线程一个连接：数据库连接池</span><br><span class="line">        + 改进数据库连接池</span><br><span class="line">            + 获取连接</span><br><span class="line">                + 获取信号量</span><br><span class="line">                    + 获取成功才能获取连接</span><br><span class="line">                    + 没有信号量，阻塞</span><br><span class="line">            + 归还连接</span><br><span class="line">                + 归还后，release信号量</span><br><span class="line">    + 原理</span><br><span class="line">        + 构造方法</span><br><span class="line">            + 信号量给同步器sync，赋值信号量给state</span><br><span class="line">        + acquire</span><br><span class="line">            + tryacquireshare</span><br><span class="line">                + 获取state</span><br><span class="line">                + 判断state--是否小于0</span><br><span class="line">                    + 无信号量，AQS阻塞队列</span><br><span class="line">                    + 老二try获取，cas</span><br><span class="line">                    + 前驱改为-1</span><br><span class="line">                    + 最后park线程</span><br><span class="line">                + cas修改state--</span><br><span class="line">        + release</span><br><span class="line">            + tryreleaseshare</span><br><span class="line">                + 获取state</span><br><span class="line">                + cas state++</span><br><span class="line">            + doreleaseshare</span><br><span class="line">                + 哨兵节点是否-1</span><br><span class="line">                    + 改为0</span><br><span class="line">                + 唤醒后序节点</span><br><span class="line">                    + 老二 tryacquire，成功</span><br><span class="line">                        + cas state</span><br><span class="line">                    + 自己设为哨兵</span><br><span class="line">                    + 唤醒后序共享节点</span><br><span class="line">                        + 由于信号量不够，又被阻塞</span><br><span class="line">                    + 这里有个双unpark机制，就是运行结束后的线程会释放锁去唤醒，另外一个刚获得释放的锁的线程也会去唤醒，不过被唤醒后的线程不能获得锁还是会park住</span><br></pre></td></tr></table></figure><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145822476.png" alt="image-20220320145822476"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145829350.png" alt="image-20220320145829350"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ CountDownLatch</span><br><span class="line">    + 简介</span><br><span class="line">        + 倒计时锁，线程间同步协作</span><br><span class="line">            + await()等待计数归零，countdown()计数-1</span><br><span class="line">        + aqs同步器</span><br><span class="line">            + acquire：state为0获得锁</span><br><span class="line">            + release：计数-1</span><br><span class="line">        + 主线程等待，其他线程计数减完，主线程继续运行</span><br><span class="line">    + 改进</span><br><span class="line">        + 线程池等不能用join等待线程结束</span><br><span class="line">            + 可以用countdownlatch</span><br><span class="line">    + 应用</span><br><span class="line">        + 等待多线程准备完毕</span><br><span class="line">            + 加载完毕计数-1</span><br><span class="line">            + 计数结束，主线程运行</span><br><span class="line">        + 等待多个远程调用结束</span><br><span class="line">            + CompletableFuture异步编排</span><br><span class="line">            + 倒计时锁</span><br><span class="line">            + 我选择AsyncTool</span><br><span class="line">            + 使用future获取返回值</span><br><span class="line">+ Cyclicbarrier</span><br><span class="line">    + 问题</span><br><span class="line">        + countdownlatch不能被重用</span><br><span class="line">        + Cyclicbarrier</span><br><span class="line">    + 使用</span><br><span class="line">        + await</span><br><span class="line">            + state-1 阻塞</span><br><span class="line">            + 当state为0，全部唤醒继续</span><br><span class="line">        + 当全部执行完，运行参数中的任务</span><br><span class="line">        + 计数为0后，再次调用await又重新开始</span><br><span class="line">    + 注意</span><br><span class="line">        + 线程数要跟计数一样</span><br></pre></td></tr></table></figure><h1 id="JUC-Collection"><a href="#JUC-Collection" class="headerlink" title="JUC-Collection"></a>JUC-Collection</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145839640.png" alt="image-20220320145839640"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 线程安全集合类</span><br><span class="line">    + 概述</span><br><span class="line">        + 遗留的</span><br><span class="line">            + hahtable、vector：都用synchronize修饰</span><br><span class="line">        + 修饰的安全集合</span><br><span class="line">            + collections中类的包装</span><br><span class="line">            + 装饰器模式</span><br><span class="line">        + juc安全集合</span><br><span class="line">            + blocking类</span><br><span class="line">                + 大部分基于锁（可重用锁），阻塞方法</span><br><span class="line">            + copyonwrite类</span><br><span class="line">                + 修改时拷贝的方式</span><br><span class="line">                + cow写时复制</span><br><span class="line">            + concurrent类</span><br><span class="line">                + 内部很多采用cas优化，提高吞吐</span><br><span class="line">                + 弱一致性</span><br><span class="line">                    + 遍历时，其他线程修改，迭代器继续运行（旧内容）</span><br><span class="line">                    + 求大小、读取</span><br><span class="line">                    + 这里的弱一致性，其实是安全失败机制（fail-safe）实现原理：获得原集合的一份拷贝，在拷贝而来的集合上进行遍历，原集合发生的改变时，不会抛出CME异常</span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145853898.png" alt="image-20220320145853898"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ ConcurrentHashMap</span><br><span class="line">    + 面试的神!CHM</span><br><span class="line">    + 错误用法</span><br><span class="line">        + 统计单词个数</span><br><span class="line">            + 线程不安全</span><br><span class="line">        + hm改为chm</span><br><span class="line">            + 仍然不行</span><br><span class="line">                + 每个方法原子</span><br><span class="line">                + 组合起来非原子</span><br><span class="line">            + 解决：</span><br><span class="line">                + 直接加synchronize重量级锁</span><br><span class="line">                + CAS</span><br><span class="line">    + computeIfAbsent</span><br><span class="line">        + 跟我在极客时间学的一样，哈哈哈哈</span><br><span class="line">        + 这个demo感觉信息量好大，学到很多编程思路和手段</span><br><span class="line">        + 第一次若key不存在，则生成key和累加器（原子性）</span><br><span class="line">        + 后面直接返回累加器，进行累加（原子性）</span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150154452.png" alt="image-20220320150154452"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150213295.png" alt="image-20220320150213295"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">+ ConcurrentHashMap原理</span><br><span class="line">    + hashmap</span><br><span class="line">        + 回顾</span><br><span class="line">            + 数组+链表+红黑树</span><br><span class="line">            + hash地址冲突，链地址法</span><br><span class="line">                + jdk7放到链表头部</span><br><span class="line">                + jdk8放到链表尾部</span><br><span class="line">            + 超过3/4，扩容，重新计算桶下标</span><br><span class="line">                + 低位的下标不变，高位的加个oldSize就是新下标</span><br><span class="line">                + 为什么数组扩容后，链表长度会减半？因为我们确定桶位置是数组长度与hash进行&amp;操作，长度扩为2倍，桶位置正好会改为2倍</span><br><span class="line">            + 多线程下扩容，并发死链问题</span><br><span class="line">        + 死链</span><br><span class="line">            + 两个线程同时触发扩容</span><br><span class="line">            + 出现环形链表</span><br><span class="line">                + 第一次扩容结束后，线程再进行扩容的时候链表上出现了环。导致程序不能再往下继续运行</span><br><span class="line">            + jdk8，尾插法</span><br><span class="line">                + 仍有其他问题（扩容丢数据）</span><br><span class="line">+ concurrenthashmap-jdk8</span><br><span class="line">    + 原理</span><br><span class="line">        + 属性&amp;内部类&amp;方法</span><br><span class="line">            + 迁移</span><br><span class="line">                + 从后往前处理</span><br><span class="line">                + 处理完加fnode节点</span><br><span class="line">            + 红黑树</span><br><span class="line">                + 扩容到64</span><br><span class="line">                + 链表转换成红黑树</span><br><span class="line">        + 构造</span><br><span class="line">            + 初始容量、负载因子（3/4）、并发度</span><br><span class="line">                + 最少初始容量等于并发度</span><br><span class="line">            + 懒惰初始化</span><br><span class="line">            + 计算容量大小（变成为2的n次方）</span><br><span class="line">        + get</span><br><span class="line">            + 这个地方说的不清楚，看完也不知道为什么不加锁，实际上是用了volatile关键字</span><br><span class="line">            + 不加锁就是volatile带来的好处，即使写操作更新了也可见不会脏读</span><br><span class="line">            + 遍历链表，用equals比较key，返回val</span><br><span class="line">        + put</span><br><span class="line">            + 默认覆盖旧值</span><br><span class="line">            + 不允许null</span><br><span class="line">            + 若table为空</span><br><span class="line">                + cas创建table</span><br><span class="line">            + 若链表无头结点（桶下标不冲突）</span><br><span class="line">                + cas添加链表头</span><br><span class="line">                + 头结点被占，再循环一遍，这个结点会加在刚刚那个头结点的后面</span><br><span class="line">            + 帮忙扩容</span><br><span class="line">                + 锁住当前链表帮忙扩容</span><br><span class="line">            + 桶下标冲突</span><br><span class="line">                + 加锁synchronize，锁住链表头结点</span><br><span class="line">                + 再次校验链表头节点是否被移动</span><br><span class="line">                + 节点hash&gt;0</span><br><span class="line">                    + key找到相同的，更新操作</span><br><span class="line">                        + 更新value</span><br><span class="line">                    + key不存在，添加操作</span><br><span class="line">                        + 已经是最后的节点了</span><br><span class="line">                        + 新增node链表尾插</span><br><span class="line">                + 节点hash&lt;0，判断是否为红黑树</span><br><span class="line">                    + 往红黑树中添加node</span><br><span class="line">                + 释放锁，判断链表长度是否大于树化阈值</span><br><span class="line">            + 计数器计数</span><br><span class="line">        + initTable</span><br><span class="line">            + 懒惰初始化</span><br><span class="line">            + table若没被创建，进入循环</span><br><span class="line">                + 双重校验是否被创建</span><br><span class="line">                    + 第一次并发</span><br><span class="line">                + cas将sizeCtl设为-1（正在创建hash表）</span><br><span class="line">                + 成功cas，准备创建hash表</span><br><span class="line">                    + 根据初始容量sc，创建node数组</span><br><span class="line">                    + sc赋值给sizeCtl，恢复到正数</span><br><span class="line">                + 并发线程都在循环中退出</span><br><span class="line">        + addcount</span><br><span class="line">            + 增加元素计数</span><br><span class="line">            + 多个累加单元，保证多线程效率</span><br><span class="line">            + 没有累加单元，cas向basecount累加</span><br><span class="line">            + 有了累加单元，cas累加++</span><br><span class="line">                + @Contended注解防止数据伪共享</span><br><span class="line">                + 之前讲LongAdder原理的时候讲过，说的是@Contened注解，这个注解是在对象或变量前后加padding，就是占位，为了避免多CPU缓存行伪共享问题</span><br><span class="line">                + 元素个数若大于sizeCtl，进入循环，扩容操作</span><br><span class="line">                    + 校验sc是否为负数</span><br><span class="line">                        + 若newtable已创建</span><br><span class="line">                            + 帮忙扩容</span><br><span class="line">                    + cas将sizeCtl设为负数</span><br><span class="line">                    + cas成功，进入transfer，传入table</span><br><span class="line">        + size</span><br><span class="line">            + 没有竞争发生，basecount累加</span><br><span class="line">            + 有竞争发生，用累加单元计数</span><br><span class="line">                + sum 累加单元的值和basecount</span><br><span class="line">            + 很明显在sumCount计算的过程中无法防止别的线程进行一些累加和删除操作</span><br><span class="line">        + transfer</span><br><span class="line">            + 若nexttable为null，创建nexttable</span><br><span class="line">                + 原有容量&lt;&lt;1</span><br><span class="line">            + 节点搬迁</span><br><span class="line">                + 以链表为单位移动</span><br><span class="line">                + 若链表处理完，替换为forwardingnode</span><br><span class="line">                + 若已经为fwd，处理下一个链表</span><br><span class="line">                + 若链表头有元素</span><br><span class="line">                    + synchronize锁住当前链表</span><br><span class="line">                    + 节点hash&gt;0（普通节点）</span><br><span class="line">                    + 节点hash&lt;0且类型为treebin，树节点搬迁</span><br><span class="line">+ concurrenthashmap-jdk7</span><br><span class="line">    + 结构</span><br><span class="line">        + 维护segment数组（每个继承可重用锁）</span><br><span class="line">            + 多把锁</span><br><span class="line">            + jdk8：锁加在链表头</span><br><span class="line">        + 缺点：</span><br><span class="line">            + 锁数组大小固定</span><br><span class="line">            + 非懒惰初始化</span><br><span class="line">        + 构造时就创建</span><br><span class="line">        + 每个segment（分段锁）对应小的hashentry</span><br><span class="line">            + 不同锁，锁的内容不一样</span><br><span class="line">    + 定位segment</span><br><span class="line">        + 多看两遍，JUC的东西还是连续性很强的</span><br><span class="line">        + 根据hash求segment位置（位运算），获取segment</span><br><span class="line">    + put</span><br><span class="line">        + 计算key的hash，找到segment下标</span><br><span class="line">        + 获取segment，进入segment的put方法</span><br><span class="line">            + 可重入锁加锁</span><br><span class="line">            + hashentry，求桶下标</span><br><span class="line">                + 链表：更新/新增</span><br><span class="line">                    + key找到相等，更新值</span><br><span class="line">                    + 找不到key，新增</span><br><span class="line">                        + 创建node节点</span><br><span class="line">                        + 扩容等</span><br><span class="line">                        + 做为链表头</span><br><span class="line">    + rehash扩容</span><br><span class="line">        + 在外层已经加锁</span><br><span class="line">        + 旧容量移位，创建newtable</span><br><span class="line">        + 遍历搬迁</span><br><span class="line">            + 如果只有头节点，直接搬迁</span><br><span class="line">            + 链表多个节点，遍历链表</span><br><span class="line">                + 记录node改变后位置</span><br><span class="line">                + 把不变的node重用</span><br><span class="line">        + 新增时才rehash</span><br><span class="line">            + 新的node在扩容完才加入new table</span><br><span class="line">    + get</span><br><span class="line">        + unsafe方法保证可见性</span><br><span class="line">        + 定位segment、桶下标</span><br><span class="line">        + 遍历key，找到直接返回value</span><br><span class="line">    + size</span><br><span class="line">        + 循环，遍历segment</span><br><span class="line">            + sum累加count</span><br><span class="line">                + 期间若被修改（不等于上次计数），则重新计数</span><br><span class="line">                + 最多循环计数三次，加锁处理统计操作</span><br><span class="line">        + 先不加锁计算2次，认为个数正确返回</span><br><span class="line">        + 如果不一样，重试，超过3次，锁住所有segment</span><br></pre></td></tr></table></figure><h1 id="LinkedBlockingQueue原理"><a href="#LinkedBlockingQueue原理" class="headerlink" title="LinkedBlockingQueue原理"></a>LinkedBlockingQueue原理</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150052835.png" alt="image-20220320150052835"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ LinkedBlockingQueue</span><br><span class="line">    + 入队出队</span><br><span class="line">        + 阻塞队列</span><br><span class="line">        + node（item、next）</span><br><span class="line">        + 初始化链表</span><br><span class="line">            + 指向哨兵节点</span><br><span class="line">        + 节点入队</span><br><span class="line">            + 尾插</span><br><span class="line">        + 节点出队</span><br><span class="line">            + 哨兵节点垃圾回收</span><br><span class="line">            + 获取老二的值，老二变成哨兵节点</span><br><span class="line">            + 占位哨兵在数构设计中的作用是，一开始头有所指，尾有所向。进出队时或者查找，少大约n次的if else</span><br><span class="line">    + 加锁分析</span><br><span class="line">        + 用了两把锁和哨兵</span><br><span class="line">            + 两把锁允许两个线程执行</span><br><span class="line">                + 生产者（队列尾）消费者（队列头）</span><br><span class="line">                + 允许同时get和put</span><br><span class="line">        + 线程安全</span><br><span class="line">            + 节点大于2</span><br><span class="line">                + 队尾队头两把锁（一个哨兵），保证入队出队无竞争</span><br><span class="line">            + 节点等于2</span><br><span class="line">                + 仍然两把锁（一个哨兵），锁两个对象</span><br><span class="line">            + 节点为1</span><br><span class="line">                + 就一个哨兵，队列为空，take会被阻塞</span><br><span class="line">    + put</span><br><span class="line">        + 非空判断</span><br><span class="line">        + 创建node</span><br><span class="line">        + 拿到put锁</span><br><span class="line">            + 若队列满容量，等待</span><br><span class="line">            + 若有空位，入队方法，计数++</span><br><span class="line">            + 若队列容量仍不满，叫醒put线程（signal一个）</span><br><span class="line">        + 解锁</span><br><span class="line">        + 如果队列只有一个元素，通知消费take线程（signal一个）</span><br><span class="line">        + 消费者也会唤醒，只是不是唤醒全部，只会唤醒一个，唤醒完一个后再由生产者自己唤醒生产者</span><br><span class="line">        + 如果有多个元素，那么take线程肯定是在执行的，如果只有一个元素，表示是我这次put进去的，需要唤醒take线程来取</span><br><span class="line">        + take，take锁</span><br><span class="line">            + 为空，等待</span><br><span class="line">            + 出队</span><br><span class="line">            + 队列有容量，叫醒一个消费者</span><br><span class="line">        + 解锁</span><br><span class="line">        + 如果队列只有一个空位，叫醒put生产者线程（signal）</span><br><span class="line">    + vs arrayblockingqueue</span><br><span class="line">        + linked懒惰的，初始不创建</span><br><span class="line">        + linked入队才生成node，array提前创建好的</span><br><span class="line">        + linked两把锁，array一把锁</span><br></pre></td></tr></table></figure><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150125092.png" alt="image-20220320150125092"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ ConcurrentLinkedQueue</span><br><span class="line">    + 与linked像，两把锁，队列头尾，哨兵</span><br><span class="line">    + 使用cas实现锁</span><br><span class="line">        + cas保证线程安全</span><br><span class="line">+ CopyOnWriteArrayList</span><br><span class="line">    + copyonwrite：写入时拷贝思想</span><br><span class="line">        + 增删改，在新数组上执行</span><br><span class="line">            + 不影响其他线程并发读</span><br><span class="line">            + 读写分离、读写并发</span><br><span class="line">    + add</span><br><span class="line">        + 加锁（写写互斥）</span><br><span class="line">            + 旧数组拷贝（长度+1）新数组</span><br><span class="line">            + 添加新元素</span><br><span class="line">            + 替换旧数组</span><br><span class="line">    + 读使用旧数组（新数组还未替换完）</span><br><span class="line">    + 读未加锁</span><br><span class="line">    + get弱一致性</span><br><span class="line">        + 线程同时读和remove，仍能读到</span><br><span class="line">        + 迭代器弱一致性</span><br><span class="line">            + 即使remove，迭代器仍拿到旧数组引用</span><br><span class="line">            + 优点</span><br><span class="line">                + 数据库的MVCC都是弱一致性表现</span><br><span class="line">                + 并发度高</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——手写线程池&amp;AQS原理&amp;可重入锁原理&amp;读写锁</title>
      <link href="/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;AQS%E5%8E%9F%E7%90%86&amp;%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86&amp;%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;AQS%E5%8E%9F%E7%90%86&amp;%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86&amp;%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h1><p>结构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320135837804.png" alt="image-20220320135837804"></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 任务队列</span></span><br><span class="line"><span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">// 2. 锁</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 3. 生产者条件变量</span></span><br><span class="line"><span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line"><span class="comment">// 4. 消费者条件变量</span></span><br><span class="line"><span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"><span class="comment">// 5. 容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ blocking queue</span><br><span class="line">    + 任务队列-双向链表</span><br><span class="line">    + 可重入锁</span><br><span class="line">        + 生产者条件变量</span><br><span class="line">            + 队列容量限制</span><br><span class="line">        + 消费者条件变量</span><br><span class="line">            + 队列空限制</span><br><span class="line">    + 容量上限</span><br><span class="line">    + 阻塞获取</span><br><span class="line">        + 上锁</span><br><span class="line">            + 队列不为空，获取队列头元素</span><br><span class="line">            + 唤醒队列满条件变量</span><br><span class="line">    + 阻塞添加</span><br><span class="line">        + 上锁</span><br><span class="line">            + 队列不满，进入队列尾部</span><br><span class="line">            + 唤醒队列空条件变量</span><br><span class="line">+ poll增强</span><br><span class="line">    + 带超时阻塞获取</span><br><span class="line">    + await返回的是：被唤醒后剩余时间</span><br><span class="line">        + 剩余时间赋值给下一个等待时间</span><br><span class="line">        + 剩余时间用完，退出</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + TheadPool</span><br><span class="line">        + blockqueue</span><br><span class="line">        + hashset：线程worker</span><br><span class="line">            + 如果任务数没超过最大，交给线程执行</span><br><span class="line">            + 如果任务数超过最大，任务进入阻塞队列</span><br><span class="line">        + MAX</span><br><span class="line">        + timeout</span><br><span class="line">+ 执行任务</span><br><span class="line">+ worker执行</span><br><span class="line">    + 从传过来的task、任务队列中的task不断获取执行</span><br><span class="line">    + 执行完毕，移除线程</span><br><span class="line">    + 现在这个好像一旦没任务就扔掉，这不是享元模式啊</span><br><span class="line">    + 并不会移除，因为taskQueue的take方法是阻塞的，也就是说线程会一直活在休息室</span><br><span class="line">+ take死等&amp;poll超时</span><br><span class="line">    + take()死等</span><br><span class="line">        + 不会停止线程池中的线程</span><br><span class="line">+ 采用poll超时</span><br><span class="line">        + 没有任务，超时结束线程</span><br><span class="line">+ 当任务队列已满</span><br><span class="line">    + 阻塞等待添加任务队列</span><br><span class="line">+ offer增强</span><br><span class="line">    + 带超时时间，阻塞添加队列</span><br><span class="line">+ 拒绝策略</span><br><span class="line">    + 策略模式</span><br><span class="line">        + tryput</span><br><span class="line">+ 拒绝策略测试</span><br><span class="line">    + 面试手写线程池不慌了</span><br><span class="line">    + 等待、放弃、自己执行</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>构造方法</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320141145740.png" alt="image-20220320141145740"></p><p>执行流程</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320141746086.png" alt="image-20220320141746086"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+ JDK的线程池</span><br><span class="line">+ 线程池状态</span><br><span class="line">    + 存在原子变量中</span><br><span class="line">        + 一个整数同时保存了状态和线程个数</span><br><span class="line">+ 构造方法</span><br><span class="line">    + 工作方式</span><br><span class="line">        + 救急线程</span><br><span class="line">            + 阻塞队列满了之后，开启</span><br><span class="line">            + 执行完毕销毁</span><br><span class="line">            + 可设置生存时间</span><br><span class="line">        + 核心线程一直保存</span><br><span class="line">        + 救急线程都满了</span><br><span class="line">            + 执行拒绝策略</span><br><span class="line">    + 执行流程</span><br><span class="line">        + 拒绝策略：四种</span><br><span class="line">            + 抛出异常</span><br><span class="line">            + 调用者执行任务</span><br><span class="line">            + 放弃任务</span><br><span class="line">            + 放弃队列中最早的任务，本任务取代</span><br><span class="line">        + 其他框架</span><br><span class="line">            + 站在架构角度思考问题</span><br><span class="line">            + dubbo</span><br><span class="line">                + 抛异常前记录日志，线程栈信息</span><br><span class="line">            + netty</span><br><span class="line">                + 创建新线程</span><br><span class="line">            + activemq</span><br><span class="line">                + 带超时放入队列</span><br><span class="line">            + pinpoint</span><br><span class="line">                + 拒绝策略链，逐一尝试每种策略</span><br><span class="line">    + 将框架拆解开，从自己实现到带逐一分析别人怎么实现，思路清晰。</span><br><span class="line">+ 工厂方法创建线程池</span><br><span class="line">    + 固定大小线程池</span><br><span class="line">        + 没有救急线程，线程不会结束</span><br><span class="line">        + 无界队列</span><br><span class="line">        + 厉害，底层使用到了许多设计模式</span><br><span class="line">    + 带缓冲线程池</span><br><span class="line">        + 全部救急线程，60s回收</span><br><span class="line">        + 队列：没有容量</span><br><span class="line">            + 没有线程取是放不进去的</span><br><span class="line">            + 队列的put只有其他线程take才会被执行</span><br><span class="line">    + 单线程线程池</span><br><span class="line">        + 保证线程池始终有一个可用的线程</span><br><span class="line">        + 装饰器模式</span><br><span class="line">            + 只能调用返回包装对象中的方法</span><br><span class="line">+ submit（带返回结果）</span><br><span class="line">    + execute（runnable）</span><br><span class="line">    + submit（callable）</span><br><span class="line">        + 返回结果</span><br><span class="line">        + 保护性暂停模式</span><br><span class="line">    + TODO 异步编排和ThreadLocal</span><br><span class="line">    + 测试</span><br><span class="line">+ invokeAll（执行任务集合、超时时间）</span><br><span class="line">+ invokeAny</span><br><span class="line">    + 执行完一个即可（最先执行完毕）</span><br><span class="line">+ 停止</span><br><span class="line">    + shutdown（执行完毕所有任务（队列）停止）</span><br><span class="line">        + 主线程异步，不会等待</span><br><span class="line">    + showdownnow</span><br><span class="line">        + STOP立即停止</span><br><span class="line">        + 返回队列</span><br><span class="line">    + 判断暂停，等待结束等</span><br><span class="line">+ 测试</span><br><span class="line">    + 结束</span><br><span class="line">    + 等待</span><br></pre></td></tr></table></figure><h1 id="设计模式-工作线程"><a href="#设计模式-工作线程" class="headerlink" title="设计模式-工作线程"></a>设计模式-工作线程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 异步模式之工作线程</span><br><span class="line">    + 定义</span><br><span class="line">        + 工作线程：线程池、享元模式</span><br><span class="line">            + 不同任务类型采用不同线程池</span><br><span class="line">                + 不同类型的任务 执行时间不一样 所以同一个线程池可能导致有些线程很难或者很迟被执行  而且每个task的优先级不同</span><br><span class="line">    + 饥饿</span><br><span class="line">        + 现象</span><br><span class="line">            + 线程数量不足导致饥饿（固定大小线程池）</span><br><span class="line">                + 线程数不足，无法处理任务</span><br><span class="line">        + 解决</span><br><span class="line">            + 不同任务类型，应该使用不同线程池</span><br><span class="line">    + 池大小</span><br><span class="line">        + 过小、过大都不合适</span><br><span class="line">        + 运算类型</span><br><span class="line">            + IO密集型公式</span><br></pre></td></tr></table></figure><h1 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ timer的缺点</span><br><span class="line">    + timer：一个线程调度，串行执行</span><br><span class="line">    + 前面任务执行时间会影响、终止后面的任务</span><br><span class="line">+ ScheduledThreadPoolExecutor</span><br><span class="line">    + 延时执行</span><br><span class="line">        + 改变线程池大小</span><br><span class="line">        + 出现异常，不影响下面的运行</span><br><span class="line">    + 定时执行</span><br><span class="line">        + 按照间隔不断执行一次任务</span><br><span class="line">            + 一个任务开始为起点的</span><br><span class="line">        + delay</span><br><span class="line">            + 结束时间算</span><br><span class="line">        + 这些还是属于比较基础的</span><br><span class="line">+ 正确处理线程池异常</span><br><span class="line">    + trycatch</span><br><span class="line">    + future对象 + callable</span><br><span class="line">        + get()</span><br><span class="line">+ 线程池应用</span><br><span class="line">    + 定时任务</span><br><span class="line">        + 记得Linux或者spring里有个cron表达式专门做定时任务</span><br><span class="line">        + 用quartz或springtask</span><br><span class="line">        + 可以用Xxl-job</span><br><span class="line">        + 下次执行时间 + 间隔时间</span><br><span class="line">+ tomcat线程池</span><br><span class="line">    + 线程池-分工</span><br><span class="line">    + 拒绝策略：尝试放入队列后，抛异常</span><br><span class="line">    + 配置</span><br><span class="line">        + 最大线程不够，再放入队列</span><br><span class="line">+ fork/join线程池</span><br><span class="line">    + 分治、任务拆分线程池</span><br><span class="line">    + 使用</span><br><span class="line">        + 任务对象：recursivetask</span><br><span class="line">        + 拆分任务：递归思想</span><br><span class="line">        + 测试</span><br><span class="line">            + 这个方法处理斐波那契数列非常慢，还是需要加上记忆化</span><br><span class="line">        + 任务拆分优化</span><br><span class="line">            + 不用一个任务依赖另一个任务</span><br><span class="line">            + 和Java高并发程序设计里的例子一样，很好的分离任务之间的联系</span><br><span class="line">            + 分治</span><br><span class="line">                + 拆分两个任务，分治</span><br></pre></td></tr></table></figure><h1 id="Aqs原理"><a href="#Aqs原理" class="headerlink" title="Aqs原理"></a>Aqs原理</h1><p>JUC包原理部分</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320142555302.png" alt="image-20220320142555302"></p><p>AQS同步器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320142530222.png" alt="image-20220320142530222"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ AQS原理</span><br><span class="line">    + 概述</span><br><span class="line">        + 阻塞式锁和同步工具的框架</span><br><span class="line">            + state</span><br><span class="line">                + 控制获取锁释放锁</span><br><span class="line">            + 等待队列，entrylist</span><br><span class="line">            + 条件变量，waitlist</span><br><span class="line">        + reentrantLock就是用的aqs</span><br><span class="line">    + 自定义锁（不可重入锁）</span><br><span class="line">        + 同步器类-继承aqs</span><br><span class="line">            + tryacquire</span><br><span class="line">                + cas修改status</span><br><span class="line">                + 设置owner为当前线程</span><br><span class="line">            + tryrelease</span><br><span class="line">                + owner为null</span><br><span class="line">                + 直接修改status</span><br><span class="line">                    + 前面为写屏障，保证null被其他线程可见</span><br><span class="line">            + isHeldexclusively</span><br><span class="line">                + 是否持有独占锁</span><br><span class="line">            + newcondition</span><br><span class="line">        + 加锁</span><br><span class="line">        + 加锁、可打断加锁</span><br><span class="line">            + 尝试加锁，尝试加锁带超时</span><br><span class="line">        + 解锁</span><br><span class="line">            + release唤醒</span><br><span class="line">    + 测试</span><br><span class="line">        + 不可重入</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320143257653.png" alt="image-20220320143257653"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320143313550.png" alt="image-20220320143313550"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">+ ReentrantLock原理</span><br><span class="line">    + 实现lock</span><br><span class="line">    + 内部sync同步器，继承aqs，实现了非公平和公平锁</span><br><span class="line">    + 非公平锁实现原理（默认）</span><br><span class="line">        + 加锁成功流程——lock()</span><br><span class="line">            + cas修改status</span><br><span class="line">            + 修改owner为当前线程</span><br><span class="line">            + cas修改失败</span><br><span class="line">                + JDK11 已经没有了，直接调用的AQS抽象类的acquire</span><br><span class="line">                + JDK11 对于失败采用的是短路与的方式</span><br><span class="line">                + tryacquire——cas重试</span><br><span class="line">                + 重试失败，acquirequeue加入队列</span><br><span class="line">                    + 第1个线程直接抢占同步器，第2个线程初始化队列：产生哑元和Node1节点，第三个线程产生Node2节点并将其插入到哑元和Node1节点之后。就是这样一个过程</span><br><span class="line">                    + 队列大体是这样的：head-&gt;哑元-&gt;Node1(Thead-1)-&gt;Node2(Thread-2)-&gt;...-&gt;tail)</span><br><span class="line">                    + 获取前驱节点</span><br><span class="line">                        + 若为头结点（哨兵）</span><br><span class="line">                        + 再次尝试获取锁tryacquire</span><br><span class="line">                    + 仍然获取失败</span><br><span class="line">                        + 把前驱节点waitstatus改为-1（有责任唤醒后继节点）</span><br><span class="line">                            + 返回false</span><br><span class="line">                        + 重新进入acquirequeue</span><br><span class="line">                            + 再次tryacquire</span><br><span class="line">                            + 这次前驱node为-1</span><br><span class="line">                            + park阻塞当前线程</span><br><span class="line">        + 解锁竞争成功流程</span><br><span class="line">            + tryrelease</span><br><span class="line">                + status、owner</span><br><span class="line">            + unpark</span><br><span class="line">                + 找到最近没取消的node，unpark</span><br><span class="line">                    + 唤醒后，重新进入循环tryacquire</span><br><span class="line">                    + 变成owner线程</span><br><span class="line">                        + 当前node变为头结点，哨兵节点</span><br><span class="line">        + 解锁竞争失败流程</span><br><span class="line">            + 不在等待队列中的线程，解锁时来竞争</span><br><span class="line">                + node尝试获取锁失败</span><br><span class="line">                + 重新进入park阻塞</span><br><span class="line">    + 可重入原理（非公平锁为例）</span><br><span class="line">        + 同一线程再次调用tryacquire</span><br><span class="line">            + 判断状态为上锁</span><br><span class="line">            + 再次判断owner是否为当前线程</span><br><span class="line">                + 发生锁重入</span><br><span class="line">                + status++表示重入两次</span><br><span class="line">        + 释放锁tryrelease</span><br><span class="line">            + status--</span><br><span class="line">                + 但是status不为0，返回false</span><br><span class="line">            + 再次调用tryrelease时将status变为0，设owner为null</span><br><span class="line">                + 返回true</span><br><span class="line">    + 可打断原理</span><br><span class="line">        + 不可打断模式（默认）</span><br><span class="line">            + 就是在获取到锁之前不能被打断</span><br><span class="line">            + 不可打断就是会用interrupted标记自己被打断过，但不会立即响应打断，等获得锁之后再自己打断自己</span><br><span class="line">        + 可打断模式interruptibly</span><br><span class="line">            + park时打断，直接抛出异常，停止等待锁</span><br><span class="line">    + 公平锁原理</span><br><span class="line">        + 非公平锁</span><br><span class="line">            + 没有锁时，直接去cas获取锁，不会检测等待队列</span><br><span class="line">        + 公平锁</span><br><span class="line">            + 先去检查aqs队列中是否有前驱节点，没有才去获取锁</span><br><span class="line">            + 如果队列中没有第二个节点、第二个节点不是此线程</span><br><span class="line">                + 返回没资格获取</span><br><span class="line">    + 条件变量实现原理</span><br><span class="line">        + 每个条件变量对应一个等待队列</span><br><span class="line">        + await</span><br><span class="line">            + 进入addconditionwaiter流程</span><br><span class="line">                + 把当前线程加入条件变量的链表</span><br><span class="line">                    + 创建新的node状态为-2（每个node都有状态）</span><br><span class="line">                    + 加入链表</span><br><span class="line">            + fullyrelease流程</span><br><span class="line">                + 释放同步器上的所有锁</span><br><span class="line">                + owner空出、 unpark后序节点</span><br><span class="line">            + park当前线程，等待被唤醒</span><br><span class="line">        + signal</span><br><span class="line">            + 判断当前线程是否为锁持有者</span><br><span class="line">                + 非持有者无法唤醒条件变量线程</span><br><span class="line">            + 条件队列，找到队首元素</span><br><span class="line">                + 断开node</span><br><span class="line">            + node转移到竞争锁的队列中</span><br><span class="line">                + 转移成功，修改node状态</span><br><span class="line">                    + 阻塞队列除了最后一个node状态为0，其他都为-1</span><br><span class="line">                    + 然后如果是CAS设置waitStatus出错的话，源码翻译好像说这个状态错误是短暂且无害的，但是为了正确，可能还是得重新让他抢锁，然后重新入队，再次CAS到状态正确就结束</span><br><span class="line">                    + 如果CAS错误，可能也有一种情况就是他超时正在取消，然后还没改waitStatus，等你调用CAS他的watiStatus已经改成取消了</span><br><span class="line">                + 转移失败，使用条件队列下一个node唤醒</span><br></pre></td></tr></table></figure><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320143730503.png" alt="image-20220320143730503"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">+ ReentrantReadWriteLock</span><br><span class="line">    + 使用</span><br><span class="line">        + 读读并发，读写互斥</span><br><span class="line">            + 只是读就可以读，读的时候写了就阻塞读</span><br><span class="line">        + 测试</span><br><span class="line">            + 同时读取，不互斥</span><br><span class="line">            + 读写，阻塞无法写，等待读锁释放</span><br><span class="line">            + 写写互斥</span><br><span class="line">    + 注意事项</span><br><span class="line">        + 读锁不支持条件变量，写锁支持</span><br><span class="line">        + 重入的时候，不能升级获取</span><br><span class="line">            + 读锁时不能重入获取写</span><br><span class="line">        + 重入时降级支持</span><br><span class="line">            + 写锁时可以再次获取读</span><br><span class="line">                + 有缓存数据，直接读取返回</span><br><span class="line">                + 没有缓存</span><br><span class="line">                    + 获取写锁（提前释放读锁）</span><br><span class="line">                    + 再次判断缓存是否已经更新</span><br><span class="line">                        + 直接返回数据</span><br><span class="line">                    + 缓存仍不存在</span><br><span class="line">                        + 重新计算数据</span><br><span class="line">                    + 获取读锁，防止写线程干扰</span><br><span class="line">                    + 释放写锁</span><br><span class="line">                + 读取数据</span><br><span class="line">        + 应用之缓存</span><br><span class="line">            + 添加缓存</span><br><span class="line">                + 缓存map集合：key：标志缓存（sql、参数）</span><br><span class="line">                + 查询：先从缓存中找，没有查询后添加到缓存</span><br><span class="line"></span><br><span class="line">                    + 查询key</span><br><span class="line">                + 更新：删除缓存，更新</span><br><span class="line">            + 问题分析</span><br><span class="line">                + hashmap不安全</span><br><span class="line">                + 高并发查询不安全</span><br><span class="line">                + 缓存更新策略</span><br><span class="line">                    + 先清缓存，再更新数据库</span><br><span class="line">                        + 清空后还未更新，其他线程查询旧数据，同步到缓存（旧）</span><br><span class="line">                    + 先更新数据库 √</span><br><span class="line">                        + 还未清空缓存，其他线程查询到旧数据，才清空缓存（短暂不一致）</span><br><span class="line">                        + 可以加原子操作</span><br><span class="line">            + 实现</span><br><span class="line">                + 创建读写锁</span><br><span class="line">                    + update（更新、删缓存）添加写锁</span><br><span class="line">                        + 保证原子性</span><br><span class="line">                    + 直接查询缓存添加读锁</span><br><span class="line">                    + 查库（查询、放入缓存）添加写锁</span><br><span class="line">                        + 可能多个线程阻塞在写锁</span><br><span class="line">                        + 双重检查，再次判断缓存存在</span><br><span class="line">                        + 保证原子性</span><br><span class="line">                + 缓存意义是为了减少连接数据库的查询用的，多线程下缓存的访问需要考虑线程安全问题，所以加锁</span><br><span class="line">                + 读本来可以不加锁，但是写操作会导致读错误，所以加了读锁，会导致写锁加了不能写，还有其他原因</span><br><span class="line">            + 补充</span><br><span class="line">                + 适合读多写少</span><br><span class="line">                + 问题</span><br><span class="line">                    + 缓存容量</span><br><span class="line">                    + 缓存过期</span><br><span class="line">                    + 单机</span><br><span class="line">                    + 并发低</span><br><span class="line">                        + 锁细分</span><br><span class="line">                        + 针对不同操作分区，上不同锁</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——共享模型之无锁、不可变-CAS&amp;享元模式</title>
      <link href="/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
      <url>/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 问题提出</span><br><span class="line">    + 保护共享资源</span><br><span class="line">        + 加锁实现</span><br><span class="line">            + synchronize、reentrantlock</span><br><span class="line">        + 无锁实现</span><br><span class="line">            + AtomicInteger：原子整数</span><br><span class="line">                + int封装</span><br><span class="line">            + compareAndSet(prev,next)</span><br><span class="line">                + 修改成功为true</span><br></pre></td></tr></table></figure><h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><p>cas</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315223914515.png" alt="image-20220315223914515"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ cas与volatile</span><br><span class="line">    + 工作方式</span><br><span class="line">        + cas原子</span><br><span class="line">        + CAS就是JAVA里唯一的乐观锁了...</span><br><span class="line">        + 保证了CAS原子性</span><br><span class="line">    + 慢动作分析</span><br><span class="line">    + volatile</span><br><span class="line">        + 保证了变量的可见性</span><br><span class="line">            + 保证获取新值比较</span><br><span class="line">    + 效率分析</span><br><span class="line">        + 无锁始终运行，有锁会上下文切换</span><br><span class="line">            + runnable——&gt;blocked</span><br><span class="line">            + 代价比较大</span><br><span class="line">        + 无锁线程保存运行，需要额外cpu支持</span><br><span class="line">            + 没有分到时间片，变成可运行状态，还是会上下文阻塞 </span><br><span class="line">        + 多核cpu无锁才有优势</span><br><span class="line">    + 特点</span><br><span class="line">        + 线程少 + 多核cpu</span><br><span class="line">        + 体现乐观锁思想</span><br><span class="line">        + synchronize体现悲观锁思想</span><br><span class="line">        + cas体现无锁开发、无阻塞并发</span><br></pre></td></tr></table></figure><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p>J.U.C 并发包提供了：</p><ul><li><p>AtomicBoolean</p></li><li><p>AtomicInteger</p></li><li><p>AtomicLong</p></li></ul><p>以 AtomicInteger 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 原子整数</span><br><span class="line">    + AtomicInteger 原子方法</span><br><span class="line">        + compareAndSet </span><br><span class="line">            + 配合while(true)</span><br><span class="line">        + 自增</span><br><span class="line">            + incrementAndGet()：++i</span><br><span class="line">            + getAndIncrement：i++</span><br><span class="line">            + decrementAndGet ...</span><br><span class="line">        + 加法</span><br><span class="line">            + getAndAdd() </span><br><span class="line">            + addAndGet()</span><br><span class="line">            + 这里没有将这些方法底层 底层还是循环获取最新值才能进行加法</span><br><span class="line">        + updateAndGet 表达式</span><br><span class="line">            + 参数：函数接口</span><br><span class="line">            + 原理</span><br><span class="line">                + 用do&#123;&#125;while()吧，源码也是用的do&#123;&#125;while()</span><br><span class="line">                + 通用封装</span><br><span class="line">                + 官方实现</span><br></pre></td></tr></table></figure><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>为什么需要原子引用类型？</p><ul><li><p>AtomicReference</p></li><li><p>AtomicMarkableReference</p></li><li><p>AtomicStampedReference</p></li></ul><p>有如下方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 原子引用</span><br><span class="line">    + AtomicReference</span><br><span class="line">        + 基本类型的赋值也是原子操作，但是要保证成员变量在线程之间的可见性，并且不使用synchronized这种重量级的互斥锁，就需要到atomic包下面的无锁操作</span><br><span class="line">        + bigdecimal</span><br><span class="line">        + 本来就没啥差，就是内部的value是引用类型了</span><br><span class="line">    + ABA问题</span><br><span class="line">        + 问到CAS必问ABA</span><br><span class="line">        + 无法判断是否被别人修改过，只能判断值相同</span><br><span class="line">        + 其他线程A-B-A ，值仍不变，但是修改过了</span><br><span class="line">    + AtomicStampedReference</span><br><span class="line">        + 比较值 + 版本号</span><br><span class="line">        + 维护版本号</span><br><span class="line">    + AtomicMarkableReference</span><br><span class="line">        + 只关心是否被更改过</span><br><span class="line">            + boolean记录</span><br><span class="line">        + 使用AtomicStampedReference也可以实现相同的效果</span><br><span class="line">        + 这其实还是为了解决ABA问题，就是打了一个标记。</span><br></pre></td></tr></table></figure><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 原子数组</span><br><span class="line">    + 不想改变引用本身，修改里面的元素，如数组</span><br><span class="line">    + 这里需要说一下，compareAndSet()的比较是通过引用地址比较的，之前是对String举例，String的不可变性导致了我们每次对String的更改也导致了引用的更改</span><br><span class="line">    + 测试</span><br><span class="line">        + 线程不安全</span><br><span class="line">    + 改为原子数组AtomicIntegerArray</span><br><span class="line">        + 线程安全</span><br></pre></td></tr></table></figure><h2 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 原子更新器</span><br><span class="line">    + 针对对象某个字段进行原子操作</span><br><span class="line">        + 必须volatile</span><br><span class="line">        + integer、long、reference等</span><br></pre></td></tr></table></figure><h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 原子累加器</span><br><span class="line">    + 性能比原子整数好</span><br><span class="line">    + 原子整数测试</span><br><span class="line">        + 200w次累加 57</span><br><span class="line">    + 原子累加器测试</span><br><span class="line">        + 200w次累加 24</span><br><span class="line">    + 原理</span><br><span class="line">        + 设置多个累加单元cell（不会超过cpu核心）</span><br><span class="line">        + 最后将结果汇总</span><br><span class="line">        + 操作不同累加单元cell，cas重试次数减少数</span><br></pre></td></tr></table></figure><h2 id="LongAdder原理"><a href="#LongAdder原理" class="headerlink" title="LongAdder原理"></a>LongAdder原理</h2><p>@sun.misc.Contended</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315224104497.png" alt="image-20220315224104497"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ LongAdder（原子累加器）原理</span><br><span class="line">    + cas锁</span><br><span class="line">        + cellsbusy</span><br><span class="line">            + cas加锁，防止扩容时，多个线程同时扩容</span><br><span class="line">        + 状态标记，用cas来保证原子更改状态</span><br><span class="line">        + 只有更改状态成功——获得锁</span><br><span class="line">            + 就是ReentransLock 使用 AQS 加锁过程</span><br><span class="line">            + 这个就是基本的操作系统实现锁的方式啊。。。</span><br><span class="line">    + 缓存行伪共享</span><br><span class="line">        + cell类</span><br><span class="line">            + contended，防止缓存行伪共享 </span><br><span class="line">        + cpu内存结构</span><br><span class="line">            + 缓存以缓存行为单位</span><br><span class="line">            + 缓存加入造成数据副本产生</span><br><span class="line">            + 保证数据一致性</span><br><span class="line">                + 一个核心对缓存数据更改，另一个核心缓存要失效</span><br><span class="line">            + 两个cell可以放进一个缓存行</span><br><span class="line">                + 对cell进行修改，导致其他核心的缓存行失效</span><br><span class="line">            + 解决</span><br><span class="line">                + 让cell存在于不同缓存行</span><br><span class="line">                + @sun.misc.Contended</span><br><span class="line">                    + 字段前后各加128字节大小的空隙</span><br><span class="line">                    + 保证将对象读到缓存，占用不同缓存行</span><br><span class="line">                    + 不会造成其他核心缓存行失效</span><br><span class="line">    + add</span><br><span class="line">        + 源码最重要</span><br><span class="line">    + LongAccumulate</span><br><span class="line">        + cells未创建</span><br><span class="line">        + cell未创建</span><br><span class="line">        + 逻辑性太强了</span><br><span class="line">        + cell已创建</span><br><span class="line">            + 重要的是要能串起来</span><br><span class="line">        + sum</span><br><span class="line">            + 累加单元求和</span><br></pre></td></tr></table></figure><h2 id="Unsafe对象"><a href="#Unsafe对象" class="headerlink" title="Unsafe对象"></a>Unsafe对象</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ unsafe对象</span><br><span class="line">    + 获取</span><br><span class="line">        + cas、park等都是调用unsafe中方法</span><br><span class="line">        + 反射获取对象</span><br><span class="line">    + cas相关方法</span><br><span class="line">        + cas操作，修改域值</span><br><span class="line">        + 有竞争，需要while重试</span><br><span class="line">    + 模拟实现原子整数</span><br><span class="line">        + AtomicInteger模拟实现</span><br><span class="line">            + 反射获取unsafe对象</span><br><span class="line">            + int成员变量，volatile</span><br><span class="line">                + 获取int偏移量，保护域变量</span><br><span class="line">            + get</span><br><span class="line">            + decrement</span><br><span class="line">                + 循环</span><br><span class="line">                + cas赋值</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ cas、volatile</span><br><span class="line">    + 无锁并发</span><br><span class="line">+ api</span><br><span class="line">    + 原子整数</span><br><span class="line">    + 原子引用</span><br><span class="line">    + 原子数组</span><br><span class="line">    + 字段更新器</span><br><span class="line">    + 原子累加器</span><br><span class="line">+ unsafe</span><br><span class="line">+ 原理</span><br><span class="line">    + LongAdder</span><br><span class="line">    + 伪共享 </span><br></pre></td></tr></table></figure><h1 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h1><h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>string</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315224233141.png" alt="image-20220315224233141"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 不可变对象</span><br><span class="line">    + 使用</span><br><span class="line">        + 不可变 日期时间类</span><br><span class="line">    + 设计</span><br><span class="line">        + string类</span><br><span class="line">            + final修饰，不可修改</span><br><span class="line">            + 保护性拷贝</span><br><span class="line">                + 通过创建副本对象，避免共享，线程安全</span><br></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315224255945.png" alt="image-20220315224255945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ 享元模式</span><br><span class="line">    + 定义和实现</span><br><span class="line">        + 对相同取值的对象进行共享，减少内存使用</span><br><span class="line">        + 体现</span><br><span class="line">            + 事先创建好256个long对象到缓存数组</span><br><span class="line">                + 不超过范围就重用，从数组中获取，避免对象重复创建</span><br><span class="line">            + byte、short、long、integer（上限可变）：-128-127</span><br><span class="line">            + char：0-127、boolean：true false</span><br><span class="line">            + string、bigdecimal</span><br><span class="line">    + 不可变线程安全辨析</span><br><span class="line">        + 就是因为是不可变类才可以用享元模式，不然一个可变的对象你咋能多个线程和变量共享而确定其值你是你需要的？</span><br><span class="line">        + 单个方法线程安全，但组合不一定是安全的，前面就讲过，说牵强的好好听课</span><br><span class="line">    + 自定义连接池</span><br><span class="line">        + 分析</span><br><span class="line">            + 连接池，重用</span><br><span class="line">            + 开发工程师？搬砖码农？</span><br><span class="line">        + 实现</span><br><span class="line">            + 属性、构造</span><br><span class="line">                + final size、数组、数组状态（原子）</span><br><span class="line">                + Integer只是调用单个方法线程安全,修改值之前需要查看状态是否为0然后置为1,这个时候就有可能有线程问题</span><br><span class="line">            + 方法</span><br><span class="line">                + 获取连接</span><br><span class="line">                    + 乐观锁，cas获取空闲连接</span><br><span class="line">                    + 无空闲连接，加锁，进入wait等待</span><br><span class="line">                + 归还连接</span><br><span class="line">                    + 直接修改状态（单线程）</span><br><span class="line">                    + 通知其他线程，notifyall</span><br><span class="line">        + 测试</span><br><span class="line">        + 总结</span><br><span class="line">            + 获取不到连接，wait</span><br><span class="line">                + 防止cpu空转获取</span><br><span class="line">                + 非短时间</span><br><span class="line">            + 优化</span><br><span class="line">                + 连接扩缩容</span><br><span class="line">                + 连接可用性检测</span><br><span class="line">                + 超时处理</span><br><span class="line">                + 分布式hash</span><br></pre></td></tr></table></figure><h2 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ final原理</span><br><span class="line">    + 设置final变量的原理</span><br><span class="line">        + 赋值final变量之后，加入写屏障</span><br><span class="line">            + 前面指令不会重排序到后面</span><br><span class="line">            + 前面变量操作同步到主存，可见性</span><br><span class="line">    + 获取final变量的原理</span><br><span class="line">        + 不加final共享堆空间，从堆中获取</span><br><span class="line">        + 加了复制到栈内存，或者使用常量池中的，用的是复制的</span><br><span class="line">            + 加快访问速度</span><br></pre></td></tr></table></figure><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 不可变：有成员，不可以改变</span><br><span class="line">+ 无状态：没有成员变量（状态信息），没有状态，更是线程安全的</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 不可变类使用</span><br><span class="line">+ 不可变类设计</span><br><span class="line">    + 保护性拷贝</span><br><span class="line">+ 原理</span><br><span class="line">    + final</span><br><span class="line">+ 模式</span><br><span class="line">    + 享元模式</span><br><span class="line">        + 重用对象，减少对内存的使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——共享模型之内存-JMM&amp;Volatile&amp;DCL</title>
      <link href="/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98-JMM&amp;%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92&amp;Volatile&amp;DCL/"/>
      <url>/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98-JMM&amp;%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92&amp;Volatile&amp;DCL/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型-JMM"></a>Java内存模型-JMM</h2><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。</p><p>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul><li><p>可见性</p></li><li><p>一个线程对主存数据修改，对于另外一个线程不可见</p></li><li><p>问题</p><ul><li>初始状态，t线程从主存读取run到工作内存</li><li>因为t要频繁从主内存读取run<ul><li>JIT编译器将run的值存储在工作内存中，减少对主存run的访问<ul><li>CPU高速缓存</li></ul></li></ul></li><li>主线程修改run的值，同步到主存<ul><li>t一直从高速缓存中读</li></ul></li></ul></li><li><p>解决</p><ul><li><p>加上volatile修饰：易变</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130021025.png" alt="image-20220315130021025"></p><ul><li>只能修饰成员、静态成员变量<ul><li>必须从主存获取值</li></ul></li></ul></li><li><p>加上synchronize解决</p><ul><li>在Java内存模型中，synchronized规定，线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</li></ul></li></ul></li><li><p>可见性vs原子性</p><ul><li><p>不能防止指令交错，只能保证读到最新的值</p></li><li><p>synchronize保证原子性、可见性，重量级</p></li><li><p>volatile保证可见性，适合一个写一个读</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130104860.png" alt="image-20220315130104860"></p><ul><li>print里面有synchronized修饰</li></ul></li></ul></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><p>终止模式之两阶段终止模式</p><ul><li><p>原来用打断标记</p><ul><li>正常执行被打断<ul><li>设置打断标记为真<ul><li>不会进入catch，继续运行</li></ul></li></ul></li><li>sleep被打断<ul><li>进入catch，会清除打断标记<ul><li>重新设置打断标记为真</li></ul></li></ul></li></ul></li><li><p>用volatile改进，boolean是否运行</p><ul><li><p>vo 的使用 场景 就是 boolean 变量 可见性</p></li><li><p>不希望sleep，直接interrupt</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130122284.png" alt="image-20220315130122284"></p><ul><li>不需要重设打断等</li></ul></li></ul></li></ul></li><li><p>同步之Balking（犹豫模式）</p><ul><li><p>保证某个线程同时只能start一次，监控线程</p></li><li><p>标记：boolean变量，一执行改为true</p></li><li><p>原子性、可见性问题</p><ul><li><p>用synchronize加锁，存在读写操作</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130128605.png" alt="image-20220315130128605"></p></li></ul></li><li><p>应用</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130134816.png" alt="image-20220315130134816"></p><ul><li>实现线程安全的单例</li></ul></li></ul></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><ul><li><p>有序性</p><ul><li><p>指令重排</p></li><li><p>指令重排原理</p><ul><li><p>指令并行优化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130152912.png" alt="image-20220315130152912"></p><ul><li><p>同时执行不同指令</p></li><li><p>前提，不影响结果</p></li></ul></li></ul></li><li><p>问题</p><ul><li>num后执行</li></ul></li><li><p>验证</p><ul><li><p>压测验证</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130215855.png" alt="image-20220315130215855"></p></li><li><p>千万次测试，存在指令重排序</p></li></ul></li><li><p>禁用</p><ul><li>ready加上volatile，禁止重排序<ul><li>防止ready之前的代码重排序<ul><li>写屏障</li></ul></li></ul></li><li>volatile保证可见性、有序性</li></ul></li></ul></li></ul><h2 id="Volatile原理"><a href="#Volatile原理" class="headerlink" title="Volatile原理"></a>Volatile原理</h2><ul><li><p>volatile原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130225821.png" alt="image-20220315130225821"></p><ul><li><p>内存屏障</p><ul><li>变量写指令，后加入写屏障</li><li>变量读指令，前加入读屏障</li></ul></li><li><p>保证可见性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130549217.png" alt="image-20220315130549217"></p><ul><li>写操作时，volatile及以前的，都同步到主存</li><li>读操作时，volatile及以后的，对共享变量读取，加载主存</li></ul></li><li><p>保证有序性</p><ul><li><p>写屏障确保指令重排时，写屏障之前代码，不会重排到写屏障后</p></li><li><p>读屏障确保指令重排时，读屏障之后代码，不会重排到度屏障前</p></li><li><p>不能解决指令交错问题</p><ul><li>只能保证可见性和有序性<ul><li>写，之前更改到主存，不能重排到后面</li><li>读，之后读到最新，无法重排到前面</li></ul></li><li>synchronize都能做到，可见、有序、原子</li></ul></li></ul></li><li><p>dcl</p><ul><li><p>简介</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130257450.png" alt="image-20220315130257450"></p><ul><li><p>懒汉式，单例用到才创建</p><ul><li>balking</li><li>只有第一次需要线程保护。后面都是读操作</li></ul></li><li><p>两次检查上锁 </p><ul><li>只在第一次没创建时上锁（外层校验）</li><li>首次访问同步</li></ul></li><li><p>指令重排等问题</p><ul><li>学了多线程现在代码都不敢写了</li></ul></li></ul></li><li><p>问题分析</p><ul><li>synchronized无法禁止指令重排序，但可以保证有序性</li><li>synchronized能保证原子性、可见性和有序性，但不能禁止指令重排</li><li>指令重排，先给变量复制，还没来得及构造对象</li><li>其他线程判断变量不为空，拿到未初始化完毕的单例</li></ul></li><li><p>问题纠正</p><ul><li>think<ul><li>synchronized能保证只有一个线程执行临界区，且保证这个线程在临界区的有序性</li><li>synchronize不能阻止重排序，volatile才能</li><li>synchronized的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同</li><li>因为synchronized修饰的代码块是单线程运行的，因此即使发生重排序也不会影响最终的结果，因此，synchronized是可以保证有序性的，但是保证有序性的方式和volatile不同。</li><li>synchronized不能防止指令重排序，但是重排序是不影响”单线程”的执行结果的，加上synchronized只有一个线程能进入执行指令，所以保证”多线程中的有序性”.</li><li>当前dcl例子中，对INSTANCE的“读取和写入”并没有在synchronized同步块内，不能保证同时只有一个线程执行，而写入的指令中又出现了重排序(写入和构造方法调用)，因此导致了这个问题。</li></ul></li><li>共享变量若完全给synchronize，即使有重排序，也不会有有序性问题</li><li>本例<strong>共享变量没有完全被synchronize保护</strong>，代码块外面还有使用</li><li>内部重排 + 共享变量外部引用 导致问题</li></ul></li><li><p>问题解决</p><ul><li><p>加上volatile</p><ul><li><p>阻止指令重排序</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130316484.png" alt="image-20220315130316484"></p></li><li><p>调用构造方法等指令，不能重排到赋值指令之后</p><ul><li>保证先构造再赋值</li></ul></li><li><p>其他线程读取指令时带读屏障，读取最新结果</p><ul><li><p>其实就是保证了每个线程遇到被volatile修饰的变量时都会从主存中重新获取该值</p></li><li><p>我觉得这里解决的是先调构造方法再赋值的指令顺序，而不是图上画的，因为这是2个线程的图，volatile是单线程指令排序，多线程可见性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130324230.png" alt="image-20220315130324230"></p></li></ul></li><li><p>解决dcl单例</p></li></ul></li></ul></li><li><p>happens-before规则</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130331914.png" alt="image-20220315130331914"></p><ul><li>这块和指令重排那块没有书上讲的好，最好看书</li><li>解锁可见</li><li>volatile可见</li><li>start前写</li><li>线程结束</li><li>打断之前对变量的写，可见</li><li>变量默认值的写</li><li>volatile变量前，其他变量的写，都同步到主存（写屏障）</li></ul></li><li><p>习题</p><ul><li>balking模式<ul><li>volatile情况<ul><li>一个线程写其他读</li><li>dcl 锁外，防止指令重排</li></ul></li></ul></li><li>线程安全单例1<ul><li>final<ul><li>防止子类继承这个单例类 然后重写方法</li></ul></li><li>防止反序列化破坏单例<ul><li>对，当用反序列化创建对象时，会调用readResovle()，因此我们直接给它重写，让它返回我们创建的对象就行了。</li><li>克隆、反射、反序列化都会破坏单例</li></ul></li><li>私有<ul><li>防止直接创建，不能防止反射</li></ul></li><li>初始化对象<ul><li>安全</li></ul></li><li>公共静态方法<ul><li>封装、改造、泛型等</li></ul></li></ul></li><li>线程安全单例<ul><li>枚举单例<ul><li>1、定义时有几个就有几个，静态成员变量</li><li>2、没有并发问题，类加载完成</li><li>3、不能反射破坏</li><li>4、可以防止</li><li>5、饿汉式</li><li>6、加到构造方法中</li></ul></li><li>懒汉式<ul><li>线程安全：类对象锁</li><li>效率低</li></ul></li><li>DCL单例<ul><li>只在创建时加锁，效率提高</li><li>防止第一并发访问，其他线程进入锁，再次创建</li><li>防止重排序</li></ul></li><li>静态内部类，懒汉式<ul><li>类加载是懒惰的</li><li>用getinstance时才触发类加载操作，初始化</li></ul></li><li>类加载由JVM保证线程安全</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>JMM<ul><li>可见性<ul><li>JVM缓存优化引起</li></ul></li><li>有序性<ul><li>JVM指令重排优化引起</li></ul></li><li>happens-before规则<ul><li>写读是否可见</li></ul></li></ul></li><li>原理<ul><li>CPU指令并行，重排序问题</li><li>volatile<ul><li>读写屏障</li></ul></li></ul></li><li>模式<ul><li>两阶段终止模式优化<ul><li>volatile改进</li></ul></li><li>同步模式之balking<ul><li>只执行一次情况<ul><li>监控线程启动</li><li>单例</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——共享模型之管程-Monitor&amp;ReentrantLock</title>
      <link href="/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B-Monitor&amp;ReentrantLock/"/>
      <url>/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B-Monitor&amp;ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><h2 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h2><p>上下文切换问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234314311.png" alt="image-20220314234314311"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ 共享带来的问题</span><br><span class="line">+ 上下文切换分析</span><br><span class="line">    + 单线程</span><br><span class="line">    + 多线程情况</span><br><span class="line">        + 线程的 cpu 时间片用完 -&gt; 线程挂起，运行到就绪 -&gt; 线程上下文切换 -&gt; 字节码指令交错运行 -&gt; 共享变量counter读写冲突</span><br><span class="line">    + 根源：指令交错</span><br><span class="line">+ 临界区与竞态条件</span><br><span class="line">    + 临界区</span><br><span class="line">        + 存在对共享资源的多线程读写区域</span><br><span class="line">    + 竞态条件</span><br><span class="line">        + 结果无法预测</span><br><span class="line">+ 避免竞态条件</span><br><span class="line">    + 非阻塞式</span><br><span class="line">        + 原子变量</span><br><span class="line">    + 阻塞式</span><br><span class="line">        + synchronize、lock</span><br><span class="line">+ synchronize</span><br><span class="line">    + 对象锁</span><br><span class="line">        + 临界区代码变成串行</span><br><span class="line">        + 对象，多个线程共享</span><br><span class="line">    + 理解</span><br><span class="line">        + 比喻</span><br><span class="line">            + synchronize中即使时间片用完，下次获取时间片仍进入（上下文切换）</span><br><span class="line">                + 只有执行完其中代码，从synchronize出来解锁</span><br><span class="line">        + 时序图</span><br><span class="line">            + 执行中，若本线程上下文切换</span><br><span class="line">                + 其他线程获取锁被阻塞blocked</span><br><span class="line">                + 其他线程直接上下文切换，本线程继续执行</span><br><span class="line">            + 释放锁，唤醒阻塞线程</span><br><span class="line">        + 思考</span><br><span class="line">            + 利用对象锁保证临界区中代码的原子性</span><br><span class="line">                + 原子性：原子操作，不可分割</span><br><span class="line">    + 面向对象改进</span><br><span class="line">        + 互斥等逻辑封装在room类内部</span><br><span class="line">            + 对共享资源保护，由内部实现</span><br><span class="line">        + 对外调用即可</span><br><span class="line">    + synchronize加在方法上</span><br><span class="line">        + 成员方法上</span><br><span class="line">            + 相当于锁this对象</span><br><span class="line">        + static方法上</span><br><span class="line">            + 相当于锁类对象</span><br><span class="line">            + jvm中只有一个类对象，但是有多个实例对象。这就是区别</span><br><span class="line">        + 习题：线程八锁</span><br><span class="line">            + sleep即抱着锁睡觉</span><br><span class="line">            + 锁类对象只有一个</span><br></pre></td></tr></table></figure><h2 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234413264.png" alt="image-20220314234413264"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 变量的线程安全分析</span><br><span class="line">    + 成员变量、静态变量被共享</span><br><span class="line">        + 读操作，线程安全</span><br><span class="line">        + 读写操作，临界区，考虑线程安全</span><br><span class="line">    + 局部变量</span><br><span class="line">        + 局部变量在线程之内，不共享</span><br><span class="line">            + 线程安全</span><br><span class="line">        + 局部变量引用的对象，可能被共享</span><br><span class="line">            + 如果引用对象逃离方法的作用范围，考虑线程安全</span><br><span class="line">        + 暴露引用</span><br><span class="line">            + private、final，防止子类影响</span><br></pre></td></tr></table></figure><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234431459.png" alt="image-20220314234431459"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ 线程安全类</span><br><span class="line">    + 多个线程调用他们同一实例时是安全的</span><br><span class="line">        + hashtable put</span><br><span class="line">    + 多个方法组合不安全：非原子</span><br><span class="line">        + 还需在外部上锁</span><br><span class="line">    + 不可变类</span><br><span class="line">    + 直接创建新的实例，不在原有实例上改变</span><br><span class="line">        + 线程安全</span><br><span class="line">    + 实例分析</span><br><span class="line">        + final：对象的引用不可变不代表对象的状态不可变</span><br><span class="line">        + 还可以使用ThreadLocal给每个线程存储一个私有start变量</span><br><span class="line">        + 我觉得主要还是看变量是否1、能逃离，2、共享</span><br><span class="line">        + 先看有木有多个线程同时访问共享变量，再看该共享变量是否可被修改</span><br><span class="line">        + 逃逸分析，要符合闭合原则</span><br><span class="line">+ 习题</span><br><span class="line">    + 售票</span><br><span class="line">        + sell读写操作，不安全</span><br><span class="line">        + add线程安全，有synchronize</span><br><span class="line">        + sell和add</span><br><span class="line">            + 安全， 不是同一共享变量</span><br><span class="line">            + 概括来说就是：下边的原子操作不依赖上边原子操作的结果的话，就不用考虑两个原子操作合在一起的安全性</span><br><span class="line">        + threadlist安全，不被多个线程共享</span><br><span class="line">        + sell加锁</span><br><span class="line">            + 保证原子性</span><br><span class="line">    + 转账</span><br><span class="line">        + 加锁：类对象</span><br></pre></td></tr></table></figure><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>加锁实现原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234449143.png" alt="image-20220314234449143"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 对象头</span><br><span class="line">    + klass word</span><br><span class="line">        + 找到的类对象</span><br><span class="line">    + mark word</span><br><span class="line">+ monitor（锁）</span><br><span class="line">    + 加锁实现原理</span><br><span class="line">        + 对象与monitor相关联</span><br><span class="line">        + 每个synchronize(obj)对象关联一个monitor</span><br><span class="line">            + 只能有一个owner</span><br><span class="line">        + 其他线程执行synchronize（obj）</span><br><span class="line">            + 进入entrylist blocked</span><br><span class="line">        + 执行完同步代码块内容</span><br><span class="line">            + 唤醒entrylist中等待线程</span><br><span class="line">            + 线程相互竞争owner</span><br><span class="line">    + 原理（字节码）</span><br><span class="line">        + 如果出现异常，帮我们正确解锁</span><br><span class="line">            + 重置mark word，唤醒entrylist</span><br><span class="line">            + 抛出异常</span><br></pre></td></tr></table></figure><h2 id="synchronize优化原理"><a href="#synchronize优化原理" class="headerlink" title="synchronize优化原理"></a>synchronize优化原理</h2><p>对象头格式：正常、偏向锁、轻量级锁、重量级锁、GC</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234523762.png" alt="image-20220314234523762"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">+ synchronize优化原理</span><br><span class="line">    + 小故事</span><br><span class="line">    + 轻量级锁</span><br><span class="line">        + 创建锁记录（Lock Record）对象</span><br><span class="line">            + 线程栈帧中包含锁的结构</span><br><span class="line">        + 锁记录中object reference指向锁对象</span><br><span class="line">            + 用cas替换lock record和锁的mark word</span><br><span class="line">                + 用于解锁的恢复和锁记录地址</span><br><span class="line">        + cas替换成功</span><br><span class="line">            + 锁中存储了锁记录地址（哪个线程）和轻量级锁</span><br><span class="line">            + 表示该线程给对象加锁</span><br><span class="line">        + cas替换失败</span><br><span class="line">            + 如果其他线程持有了该obj的轻量级锁</span><br><span class="line">                + 进入锁膨胀过程</span><br><span class="line">            + 如果自己synchronize锁重入</span><br><span class="line">                + 添加lock record，知道是自己线程的锁，作为重入的计数</span><br><span class="line">        + 解锁时如果取值为null，表示锁重入，清除锁记录</span><br><span class="line">        + 解锁时如果取值不为null</span><br><span class="line">            + cas将mark word恢复给锁对象头</span><br><span class="line">                + 变为无锁状态</span><br><span class="line">            + 成功，解锁成功</span><br><span class="line">            + 失败</span><br><span class="line">                + 说明轻量级锁进入了锁膨胀或一级升级为重量级锁</span><br><span class="line">                + 进入重量级锁解锁流程</span><br><span class="line">    + 锁膨胀</span><br><span class="line">        + 将轻量级锁升级为重量级锁</span><br><span class="line">        + 流程</span><br><span class="line">            + 为object对象申请monitor锁</span><br><span class="line">                + mark word指向重量级锁地址，后两位10</span><br><span class="line">            + 其他线程进入monitor的entrylist阻塞</span><br><span class="line">            + 线程执行完，解锁</span><br><span class="line">                + cas将mark word恢复，失败</span><br><span class="line">                + 进入重量级解锁流程</span><br><span class="line">                    + 根据对象头找到monitor</span><br><span class="line">                    + 设置owner为null</span><br><span class="line">                    + 唤醒entrylist</span><br><span class="line">    + 自旋优化</span><br><span class="line">        + 重量级锁竞争时，自旋优化（重试）</span><br><span class="line">            + 减少阻塞发生</span><br><span class="line">                + 阻塞要进行上下文切换</span><br><span class="line">        + 自旋失败，进入阻塞</span><br><span class="line">        + 自旋锁是自适应的，正反馈调节</span><br><span class="line">        + java7以后无法控制是否开启自旋</span><br><span class="line">    + 偏向锁</span><br><span class="line">        + 轻量级锁，锁重入时仍需CAS操作</span><br><span class="line">            + 每一次都要cas操作（翻书包）</span><br><span class="line">        + 偏向锁（刻名字）</span><br><span class="line">            + 第一次cas时将Thread id设置到锁对象头</span><br><span class="line">                + 重入时判断为本线程，无需cas</span><br><span class="line">        + 偏向状态</span><br><span class="line">            + 默认开启偏向锁，mark word中biased_lock为1</span><br><span class="line">                + 默认延迟开启</span><br><span class="line">            + 获取锁对象</span><br><span class="line">                + 设置线程id到锁的mark word</span><br><span class="line">            + synchronize结束后</span><br><span class="line">                + 锁的mark word不变</span><br><span class="line">            + 其他线程获取锁对象</span><br><span class="line">                + 撤销偏向锁，变成轻量级锁</span><br><span class="line">                    + 竞争</span><br><span class="line">                        + 膨胀变成重量级锁</span><br><span class="line">            + 使用偏向锁之前获取hashcode</span><br><span class="line">                + 会禁用偏向锁</span><br><span class="line">                + 哈希码用的时候才产生，填到mark word中</span><br><span class="line">                    + 轻量级锁hashcode存在线程栈帧的锁记录里</span><br><span class="line">                    + 重量级锁hashcode存在monitor对象里</span><br><span class="line">                    + 解锁时都会还原回来</span><br><span class="line">                + 偏向锁没有存储的地方</span><br><span class="line">        + 撤销</span><br><span class="line">            + 调用hashcode</span><br><span class="line">            + 其他线程使用对象</span><br><span class="line">                + 偏向锁升级为轻量级锁</span><br><span class="line">                    + 测试</span><br><span class="line">                        + 轻量级锁、偏向锁前提</span><br><span class="line">                            + 线程错开，否则升级重量级锁</span><br><span class="line">                            + wait会释放CPU和锁资源</span><br><span class="line">                + 多个线程获取偏向锁</span><br><span class="line">                    + 撤销偏向锁</span><br><span class="line">            + 调用wait/notify</span><br><span class="line">                + wait/notify只有重量级锁有</span><br><span class="line">                    + 自动升级为重量级锁</span><br><span class="line">        + 批量重偏向</span><br><span class="line">            + 虽然被多个线程访问，没有竞争</span><br><span class="line">                + 让偏向锁重新偏向，而不升级轻量级锁</span><br><span class="line">            + 撤销偏向次数过多：超过20次</span><br><span class="line">                + 重新偏向新线程</span><br><span class="line">            + 总结就是没超过阈值，先把偏向锁变成轻量锁，然后再偏向锁</span><br><span class="line">        + 批量撤销</span><br><span class="line">            + 撤销偏向次数过多：超过40次</span><br><span class="line">                + 整个类所有对象不可偏向</span><br><span class="line">            + 测试</span><br><span class="line">                + t1 </span><br><span class="line">                    + 39个偏向t1（偏向锁）</span><br><span class="line">                +t2 </span><br><span class="line">                    + 前19个撤销，变成轻量级锁，解锁不可偏向，（轻量级锁）</span><br><span class="line">                    + 19以后批量重偏向优化，重新偏向于t2，（偏向锁）</span><br><span class="line">                + t3</span><br><span class="line">                    + 前19个撤销，不可偏向</span><br><span class="line">                        + t3前19个已被t2设为不可偏向，为轻量级锁</span><br><span class="line">                        + t3前十九个已经被t2设置为不可偏向锁，故t3初始为不可偏向锁，加锁成为轻量级锁</span><br><span class="line">                        + T2前十九个没有重偏向，解锁后就变为不可偏向，后二十是偏向t2</span><br><span class="line">                    + 19以后，</span><br><span class="line">                        + 原本偏向t2线程</span><br><span class="line">                        + 被撤销，升级为轻量级锁</span><br><span class="line">                        + 解锁之后不可偏向</span><br><span class="line">                        + 重偏向是针对单个线程来讲的，一个线程撤销20个锁才进行重偏向，这时另一个线程还是要撤销20个</span><br><span class="line">                        + t1:全部偏向t1；t2:一半撤销t1的偏向锁，一半偏向t2；t3:一半轻量级锁，一半撤销t2的偏向锁；总共撤销了20次t1的偏向锁，20次t2的偏向锁</span><br><span class="line">                        + 批量重偏向和批量撤销是针对类的优化，和对象无关。偏向锁重偏向一次之后不可再次重偏向。当某个类已经触发批量撤销机制后，JVM会默认当前类产生了严重的问题，剥夺了该类的新实例对象使用偏向锁的权利</span><br><span class="line">        + 锁消除</span><br><span class="line">            + JIT优化</span><br><span class="line">                + 分析局部变量，synchronize中不会被共享</span><br><span class="line">                + 把synchronize优化掉</span><br></pre></td></tr></table></figure><h2 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234608743.png" alt="image-20220314234608743"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ wait、notify</span><br><span class="line">    + 为什么需要wait</span><br><span class="line">        + 进入休息室wait</span><br><span class="line">        + 烟到了notify，唤醒wait线程</span><br><span class="line">    + 工作原理</span><br><span class="line">        + owner线程发现条件不满足，放弃锁</span><br><span class="line">            + 调用wait方法进入waitset</span><br><span class="line">                + WAITING：没有时限</span><br><span class="line">        + blocked和waiting都处于阻塞</span><br><span class="line">            + 不占用cpu时间片</span><br><span class="line">        + owner调用notify或者notifyall唤醒</span><br><span class="line">            + 进入entrylist重新竞争</span><br><span class="line">    + api</span><br><span class="line">        + 都需要获得锁成为owner才能调用</span><br><span class="line">        + 同步代码块中</span><br><span class="line">        + notify挑一个唤醒</span><br><span class="line">        + 有参wait</span><br><span class="line">            + 最大时限等待</span><br><span class="line">    + sleep 和 wait</span><br><span class="line">        + sleep是thread方法，wait是object所有对象方法</span><br><span class="line">        + sleep不需要和synchronize使用，wait需要获取锁</span><br><span class="line">        + sleep睡眠不会释放锁，wait等待时会释放锁</span><br><span class="line">    + wait和notify使用</span><br><span class="line">        + wait时其他线程可以继续工作</span><br><span class="line">        + notify错误唤醒：虚假唤醒</span><br><span class="line">            + notifyall全部唤醒</span><br><span class="line">                + 指定的话，用park，unpark</span><br><span class="line">            + notifyall + while</span><br><span class="line">                + if条件改为while，</span><br><span class="line">                + 只有条件正确才能唤醒出循环</span><br><span class="line">        + 正确使用</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>保护性暂停</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234708945.png" alt="image-20220314234708945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ 设计模式：同步模式之保护性暂停</span><br><span class="line">    + 定义</span><br><span class="line">        + 一个线程等待另一个线程执行结果</span><br><span class="line">            + 一个结果从一个线程传递到另一个线程，关联同一个GuardedObject</span><br><span class="line">            + 结果不断传输，需要消息队列（生产者、消费者）</span><br><span class="line">            + join、future实现，采用保护性暂停</span><br><span class="line">            + 等待结果，同步模式</span><br><span class="line">    + 实现</span><br><span class="line">        + guardedobject</span><br><span class="line">        + 优点</span><br><span class="line">            + 相比join，不需要等线程结束，线程还可以继续运行</span><br><span class="line">            + 等待结果变量无需设置全局，直接获取</span><br><span class="line">    + 拓展-增加超时</span><br><span class="line">        + wait time</span><br><span class="line">        + 测试</span><br><span class="line">    + join原理</span><br><span class="line">        + 记录经历时间，等待</span><br><span class="line">            + 保护性暂停</span><br><span class="line">    + 拓展-解耦等待和生产</span><br><span class="line">        + 解耦，生产者和消费者</span><br><span class="line">        + 维护一个集合，guardedobject有唯一id</span><br><span class="line">        + 实现</span><br><span class="line">            + mailbox</span><br><span class="line">                + 线程安全的map hashtable</span><br><span class="line">                + 自增id方法加锁</span><br><span class="line">                + 获取完邮件直接删除，所以remove</span><br><span class="line">            + postman、people</span><br><span class="line">                + 继承Thread</span><br><span class="line">                + people</span><br><span class="line">                + postman</span><br><span class="line">        + 测试</span><br><span class="line">            + //确保生成居民先于快递员,但是快递员发信要早于居民收信</span><br><span class="line">            + 解耦了生产者和消费者</span><br><span class="line">            + 生产者和消费者必须一一对应</span><br></pre></td></tr></table></figure><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>生产者消费者-消息队列</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234728830.png" alt="image-20220314234728830"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ 异步模式之生产者消费者</span><br><span class="line">    + 定义</span><br><span class="line">        + 不需要生产者和消费者一一对应</span><br><span class="line">        + 消息队列</span><br><span class="line">            + 有容量限制</span><br><span class="line">            + 各种阻塞队列，就是这种模式</span><br><span class="line">        + 异步模式</span><br><span class="line">            + 等待通知 同步，等待需要 通知 之后的结果</span><br><span class="line">    + 实现</span><br><span class="line">        + message</span><br><span class="line">        + messageQueue</span><br><span class="line">            + LinkedList 双向队列</span><br><span class="line">            + 获取消息</span><br><span class="line">                + 队列为空wait等待</span><br><span class="line">                + 不为空，取出队列头部消息</span><br><span class="line">                this的话锁粒度太大了，直接就相当于单线程操作了……</span><br><span class="line">                + 取完消息，notify唤醒生产者，队列不满</span><br><span class="line">            + 存入消息</span><br><span class="line">                + 判断队列否已满</span><br><span class="line">                    + 生产者wait等待</span><br><span class="line">                + 尾部加入消息</span><br><span class="line">                + notify唤醒消费者，接收消息</span><br><span class="line">    + 测试</span><br><span class="line">        + 生产者</span><br><span class="line">        + 消费者</span><br></pre></td></tr></table></figure><h2 id="Park-amp-unpark"><a href="#Park-amp-unpark" class="headerlink" title="Park&amp;unpark"></a>Park&amp;unpark</h2><p>先调用unpark原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234756570.png" alt="image-20220314234756570"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ park&amp;unpark</span><br><span class="line">    + 基本使用</span><br><span class="line">        + 暂停当前线程</span><br><span class="line">        + wait状态，无时限等待</span><br><span class="line">        + 若先调用unpark</span><br><span class="line">            + 无法park住</span><br><span class="line">        + 特点</span><br><span class="line">            + 无需配置monitor</span><br><span class="line">            + 以线程为单位阻塞、唤醒线程，精准唤醒</span><br><span class="line">            + 可以先unpark</span><br><span class="line">    + 原理</span><br><span class="line">        + 每个线程都有parker对象（背包）</span><br><span class="line">            + counter（0、1）</span><br><span class="line">                + 干粮</span><br><span class="line">            + cond</span><br><span class="line">                + 帐篷</span><br><span class="line">            + mutex</span><br><span class="line">        + unpark：令干粮充足</span><br><span class="line">        + 调用park</span><br><span class="line">        + 调用unpark</span><br><span class="line">        + 先调用unpark</span><br><span class="line">        + 说白了就是当count为0时调用park才会停</span><br><span class="line">        + 总结</span><br><span class="line">            + park消费counter</span><br><span class="line">                + 若无counter进入cond，counter为0</span><br><span class="line">                    + 若unpark，counter为1</span><br><span class="line">                        + 唤醒cond中线程，消费counter为0，继续运行 </span><br><span class="line">                + 若有counter，counter为0，继续运行</span><br></pre></td></tr></table></figure><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p>线程状态</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234813808.png" alt="image-20220314234813808"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ 线程状态转换</span><br><span class="line"></span><br><span class="line">    + new</span><br><span class="line">        + 创建java对象，还没和操作系统线程对象关联</span><br><span class="line">    + runnable</span><br><span class="line">        + 关联操作系统线程，cpu调度执行</span><br><span class="line">        + 包括是否被cpu调度</span><br><span class="line">        + 调用操作系统阻塞io相关的api，java层面都是runnable</span><br><span class="line">    + runnable和waiting</span><br><span class="line">        + 使用synchronize获取对象锁后，wait()，进入waitset</span><br><span class="line">            + notify、interrupt，进入entryset()</span><br><span class="line">                + 竞争锁成功，runnable</span><br><span class="line">                + 竞争锁失败，blocked</span><br><span class="line">        + 调用t线程的join()，当前线程变成waiting</span><br><span class="line">            + t线程结束、当前线程interrupt，变成runnable</span><br><span class="line">        + park</span><br><span class="line">            + unpark、interrupt</span><br><span class="line">    + runnable和timed_waiting（有时限waiting）</span><br><span class="line">        + 获取了synchronize对象锁之后，wait(n)</span><br><span class="line">            + 等待超时、notify、interrupt，进入entryset</span><br><span class="line">                + 竞争锁成功，runnable</span><br><span class="line">                + 竞争锁失败，blocked</span><br><span class="line">        + join(n)</span><br><span class="line">            + 等待超时、运行结束、interrupt，runnable</span><br><span class="line">        + parkNacos(n)、parkUntil(n)</span><br><span class="line">            + 超时、unpark、interrupt，runnable</span><br><span class="line">        + sleep(n)</span><br><span class="line">            + 超时，runnable</span><br><span class="line">    + runnable和blocked</span><br><span class="line">        + 竞争锁失败，blocked</span><br><span class="line">        + 竞争锁成功，runnable</span><br><span class="line">    + terminated</span><br><span class="line">        + 当前线程所有代码执行完毕</span><br></pre></td></tr></table></figure><h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p>JUC-可重入锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234844081.png" alt="image-20220314234844081"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">+ 多把锁</span><br><span class="line">    + 一把锁，并发度低</span><br><span class="line">        + 粒度细分，准备多个对象锁</span><br><span class="line">        + 业务不能有关联</span><br><span class="line">        + 增加并发度</span><br><span class="line">        + 可能造成死锁</span><br><span class="line">    + 活跃性</span><br><span class="line">        + 死锁现象</span><br><span class="line">            + 一个线程需要同时获取多把锁</span><br><span class="line">                + 都在等待对方释放锁</span><br><span class="line">        + 定位死锁</span><br><span class="line">            + jconsole、jstack</span><br><span class="line">        + 哲学家就餐问题</span><br><span class="line">        + 活锁</span><br><span class="line">            + 两个线程互相改变，无法达到结束条件</span><br><span class="line">                + 没有阻塞</span><br><span class="line">            + 执行时间交错开，随机睡眠时间</span><br><span class="line">        + 饥饿</span><br><span class="line">            + 线程优先级太低，始终无法得到cpu调度</span><br><span class="line">            + 顺序加锁的解决方案，都按A、B顺序加锁</span><br><span class="line">                + 产生饥饿问题</span><br><span class="line">                + 在争夺左筷子（最外层锁）中，苏和阿同时争夺c1,所以概率倒数，在 第二轮争夺右筷子时，c5没有人跟赫争，故赫能吃到饭的概率最高</span><br><span class="line">    + ReentrantLock 可重入锁</span><br><span class="line">        + 特点</span><br><span class="line">            + 可中断（破坏锁）</span><br><span class="line">            + 可设置超时时间（争抢锁）</span><br><span class="line">            + 可设置为公平锁（block先进先出）</span><br><span class="line">            + 支持多个条件变量（不同条件对应多个waitset，精准唤醒）</span><br><span class="line">            + 与synchronize一样，支持可重入（同一个线程可以重复获取锁）</span><br><span class="line">        + 可重入</span><br><span class="line">            + 同一个线程获取锁后，可再次获取锁（lock多次）</span><br><span class="line">        + 可打断</span><br><span class="line">            + 等待锁过程中，可以被interrupt打断终止等待</span><br><span class="line">            + lockInterruptibly方法获取锁（lock无法打断等待）</span><br><span class="line">                + 其他线程interrupt()打断</span><br><span class="line">                + 捕捉到InterruptException异常</span><br><span class="line">                + 直接返回</span><br><span class="line">            + 被动，避免死等</span><br><span class="line">        + 锁超时</span><br><span class="line">            + 主动，设置超时避免死等</span><br><span class="line">            + trylock()，尝试获得锁，返回布尔值</span><br><span class="line">                + 获取不到锁直接返回</span><br><span class="line">                + 返回为真，获得到了锁，向下执行代码</span><br><span class="line">            + trylock()带参数</span><br><span class="line">                + 等待获取锁时间，超时返回false</span><br><span class="line">                + 可被打断，进入打断异常，直接返回</span><br><span class="line">            + 解决哲学家就餐</span><br><span class="line">                + 筷子继承可重入锁</span><br><span class="line">                + trylock()</span><br><span class="line">                + 拿不到锁就结束，释放所有锁</span><br><span class="line">                    + 左手拿不到继续获取，右手拿不到，释放左手锁</span><br><span class="line">        + 公平锁</span><br><span class="line">            + 默认不公平</span><br><span class="line">            + 公平锁：先入先得锁</span><br><span class="line">                + 为了解决饥饿问题</span><br><span class="line">                    + trylock也可以解决</span><br><span class="line">                + 没有必要，降低并发度</span><br><span class="line">            + 非公平锁：没进入等待队列也有机会获得锁</span><br><span class="line">        + 条件变量</span><br><span class="line">            + 支持多个条件变量（休息室），可以精准唤醒</span><br><span class="line">            + 操作</span><br><span class="line">                + 创建条件变量（休息室）</span><br><span class="line">                + 指定条件变量执行await，等待</span><br><span class="line">                    + 时间参数</span><br><span class="line">                + 指定条件变量执行signal，唤醒</span><br><span class="line">                    + 唤醒之后重新竞争lock锁</span><br><span class="line">            + 使用</span><br><span class="line">            + 不看源码，自己把源码敲了一遍，的确有些自己一直没注意到的地方</span><br></pre></td></tr></table></figure><h2 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ 同步模式之顺序控制（控制线程的运行顺序）</span><br><span class="line">    + 固定运行顺序（先执行2，后执行1）</span><br><span class="line">        + wait&amp;notify</span><br><span class="line">            + while条件判断 + wait、notify</span><br><span class="line">        + await&amp;signal</span><br><span class="line">        + join()</span><br><span class="line">        + park&amp;unpark</span><br><span class="line">            + 精准暂停，唤醒</span><br><span class="line">                + 背包干粮</span><br><span class="line">            + 若t2先运行，t1可正常继续执行</span><br><span class="line">    + 交替输出（按abc顺序交替输出）</span><br><span class="line">        + wait&amp;notify</span><br><span class="line">            + 等待标记：用整数1、2、3标记条件，代表某个数字允许打印</span><br><span class="line">                + 面向对象code，很强</span><br><span class="line">        + await&amp;signal</span><br><span class="line">            + 三个不同休息室（条件变量）</span><br><span class="line">                + 进入当前休息室</span><br><span class="line">                + 打印</span><br><span class="line">                + 唤醒下一间休息室</span><br><span class="line">            + 执行流程</span><br><span class="line">                + 不管谁抢到锁，都进入休息室</span><br><span class="line">                + 只有a休息室解锁，a打印，解锁b休息室</span><br><span class="line">                + 只有b会继续运行，打印，解锁c</span><br><span class="line">            + 之前已经说过了，可以先唤醒，后等待，不存在全部等待的问题</span><br><span class="line">        + park&amp;unpark</span><br><span class="line">            + 以线程为单位停止、恢复</span><br><span class="line">                + 我一直以为我很懂面向对象，写的太烂了</span><br><span class="line">            + 面向对象编程，确实牛逼</span><br><span class="line">            + 流程</span><br><span class="line">                + 无论谁抢到时间片，全部线程park</span><br><span class="line">                + 主线程唤醒t1，t1线程打印，唤醒t2</span><br><span class="line">                + t2打印，唤醒t3</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ 知识点</span><br><span class="line">    + 共享资源、临界区</span><br><span class="line">    + synchronize</span><br><span class="line">        + 保证临界区代码线程安全</span><br><span class="line">            + 原子性</span><br><span class="line">            + 不至于上下文切换产生交错</span><br><span class="line">        + 锁对象语法</span><br><span class="line">        + 成员、静态方法</span><br><span class="line">        + wait、notify同步方法</span><br><span class="line">            + 条件不满足等待，条件满足恢复运行</span><br><span class="line">    + reentrantlock</span><br><span class="line">        + 可打断、锁超时trylock、公平锁、条件变量</span><br><span class="line">    + 分析变量线程安全性，常见线程安全类</span><br><span class="line">    + 线程活跃性</span><br><span class="line">        + 死锁、活锁、饥饿</span><br><span class="line">+ 应用</span><br><span class="line">    + 互斥</span><br><span class="line">        + synchronize和lock共享资源互斥</span><br><span class="line">    + 同步</span><br><span class="line">        + wait/notify、await/signal线程间通信效果</span><br><span class="line">+ 原理</span><br><span class="line">    + monitor、synchronize、wait/notify</span><br><span class="line">    + synchronize</span><br><span class="line">        + 轻量级锁、偏向锁、重量级锁</span><br><span class="line">        + 锁膨胀、锁消除等</span><br><span class="line">    + park&amp;unpark</span><br><span class="line">    + synchronize实现monitor，JVM层面，c++</span><br><span class="line">    + lock实现monitor，java级别</span><br><span class="line">+ 设计模式</span><br><span class="line">    + 同步模式之保护性暂停</span><br><span class="line">        + 线程之间获得结果，一一对应</span><br><span class="line">    + 异步模式之生产者消费者</span><br><span class="line">        + 生产消费不是一一对应关系</span><br><span class="line">    + 同步模式之顺序控制</span><br><span class="line">        + 控制线程执行先后次序、交替运行</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——线程原理&amp;栈帧&amp;两阶段终止模式</title>
      <link href="/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86&amp;%E6%A0%88%E5%B8%A7&amp;%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86&amp;%E6%A0%88%E5%B8%A7&amp;%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 进程</span><br><span class="line">    + 加载指令、管理内存、管理io</span><br><span class="line">    + 程序的一个实例</span><br><span class="line">    + java中资源分配的最小单位</span><br><span class="line">+ 线程</span><br><span class="line">    + 一个指令流</span><br><span class="line">    + 一个进程内多个线程</span><br><span class="line">    + java中最小调度单位</span><br><span class="line">+ 对比</span><br><span class="line">    + 进程基本相互独立，线程存在于进程中</span><br><span class="line">    + 进程通信复杂</span><br><span class="line">        + 不同计算机进程通信，http协议等</span><br><span class="line">    + 线程通信简单</span><br><span class="line">        + 共享进程内的内存，数据</span><br><span class="line">    + 线程上下文切换成本低</span><br></pre></td></tr></table></figure><h2 id="并行并发的概念"><a href="#并行并发的概念" class="headerlink" title="并行并发的概念"></a>并行并发的概念</h2><p>并发</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230324615.png" alt="并发"></p><p>并行</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230509268.png" alt="并行"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)</span><br><span class="line">并行： 单位时间内，多个任务同时执行</span><br><span class="line">+ 并发</span><br><span class="line">    + 同一时间线程轮流使用cpu</span><br><span class="line">        + concurrent</span><br><span class="line">    + 单核cpu下</span><br><span class="line">        + 实际串行执行</span><br><span class="line">        + cpu时间片轮流执行</span><br><span class="line">        + 宏观上并行</span><br><span class="line">+ 并行</span><br><span class="line">    + 多核cpu下</span><br><span class="line">        + 每个核同时调度运行线程</span><br><span class="line">+ 并发和并行都有</span><br><span class="line">    + 并发：同一时间应对多件事</span><br><span class="line">    + 并行：同一时间动手做多件事</span><br></pre></td></tr></table></figure><h2 id="线程应用"><a href="#线程应用" class="headerlink" title="线程应用"></a>线程应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 异步async</span><br><span class="line">    + 不需要等待结果返回，继续运行</span><br><span class="line">    + 特点</span><br><span class="line">    + 线程不同</span><br><span class="line">        + 避免阻塞主线程</span><br><span class="line">        + 提高吞吐量</span><br><span class="line">+ 提高效率</span><br><span class="line">+ 分布式的远程调用一般都是异步调，节省总响应时间</span><br><span class="line">    + 取决最长时间</span><br><span class="line">    + 多核下</span><br><span class="line">        + 任务拆分、并行执行</span><br><span class="line">    + 非阻塞io和异步io优化</span><br></pre></td></tr></table></figure><h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 创建和运行线程</span><br><span class="line">+ 1、直接使用Thread</span><br><span class="line">    + 2、使用Runnable配合Thread</span><br><span class="line">        + 把线程和任务分</span><br><span class="line">    + lambda简化</span><br><span class="line">        + idea智能替换</span><br><span class="line">            + 能简化的，idea会有灰色提示</span><br><span class="line">    + 方法1、2</span><br><span class="line">        + 走的都是run()方法</span><br><span class="line">        + runnable与线程池等配合</span><br><span class="line">        + 脱离任务和线程继承体系</span><br><span class="line">    + 3、FutureTask配合Thread</span><br><span class="line">        + 可以返回任务执行结果</span><br><span class="line">            + return + get</span><br><span class="line">        + 参数：泛型 + callable接口</span><br><span class="line">        + get()</span><br><span class="line">            + 阻塞等待结果返回</span><br></pre></td></tr></table></figure><h2 id="线程运行"><a href="#线程运行" class="headerlink" title="线程运行"></a>线程运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 线程运行</span><br><span class="line">    + 现象</span><br><span class="line">+ 查看和杀死</span><br><span class="line">        + windows</span><br><span class="line">        + linux</span><br><span class="line">        + jconsole</span><br></pre></td></tr></table></figure><h2 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h2><p>栈帧图解</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230549515.png" alt="栈帧原理"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ 线程运行原理</span><br><span class="line">    + 栈与栈帧</span><br><span class="line">        + 栈帧Frame</span><br><span class="line">            + 线程中方法的调用</span><br><span class="line">        + 栈帧图解</span><br><span class="line">            + 程序运行</span><br><span class="line">                + 类加载</span><br><span class="line">                + 启动主线程，栈内存</span><br><span class="line">                    + 执行main方法，分配栈帧内存</span><br><span class="line">                        + 局部变量表（args、变量）</span><br><span class="line">                        + 返回地址</span><br><span class="line">                    + 执行method1，分配栈帧内存</span><br><span class="line">                    + 执行method2，分配栈帧内存 </span><br><span class="line">                        + 堆中创建对象</span><br><span class="line">                    + 执行完毕，释放栈帧内存</span><br><span class="line">        + 多线程情况</span><br><span class="line">            + 断点模式</span><br><span class="line">                + 可以控制每个线程前进</span><br><span class="line">            + 线程栈之间独立，独立的栈内存</span><br><span class="line">    + 线程上下文切换</span><br><span class="line">        + cpu转去执行另一个线程</span><br><span class="line">        + 切换产生原因</span><br><span class="line">            + cpu时间片用完</span><br><span class="line">            + 垃圾回收</span><br><span class="line">            + 更高优先级线程</span><br><span class="line">            + 线程调用一些方法</span><br><span class="line">        + 记录当前线程状态</span><br><span class="line">            + 程序计数器</span><br><span class="line">            + 栈帧信息、局部变量、返回地址等</span><br><span class="line">        + 频繁上下文切换影响性能</span><br></pre></td></tr></table></figure><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+ 线程常见方法</span><br><span class="line">    + start()</span><br><span class="line">        + 线程进入就绪状态</span><br><span class="line">    + run()</span><br><span class="line">        + 线程启动后调用</span><br><span class="line">    + join()</span><br><span class="line">        + 等待线程运行结束</span><br><span class="line">        + 超时时间</span><br><span class="line">    ...</span><br><span class="line">+ start 和 run</span><br><span class="line">    + 调用run()只是普通调用方法</span><br><span class="line">    + 未创建线程</span><br><span class="line">    + 而run真正的意义是当线程start进入就绪态后被调度获得时间片时执行run方法由就绪态进入运行态</span><br><span class="line">    + 这里感觉t1.start()方法后加个t1.join（）保证t1线程执行完才打印更合理些，而且状态是TERMINATED。而运行时状态应该在run（）方法中打印</span><br><span class="line">    + start不能多次调用</span><br><span class="line">        + 变成runnable就不能调用start</span><br><span class="line">+ sleep()与yield</span><br><span class="line">    + sleep()</span><br><span class="line">        + running状态变成TIMED_WAITING：阻塞</span><br><span class="line">        + interrupt打断睡眠</span><br><span class="line">            + 睡眠线程抛出异常执行catch</span><br><span class="line">        + 睡眠结束未必立即执行，需要cpu使用权</span><br><span class="line">        + 可读性</span><br><span class="line">            + TimeUnit的sleep，附带时间单位</span><br><span class="line">    + yield()</span><br><span class="line">        + 从running变成runnable就绪</span><br><span class="line">        + 让出cpu使用权，有机会立即获得时间片</span><br><span class="line">+ 线程优先级</span><br><span class="line">    + setPriority()</span><br><span class="line">+ sleep应用</span><br><span class="line">    + while(true)</span><br><span class="line">    + 加上sleep</span><br><span class="line">        + 避免空转占满cpu</span><br><span class="line">+ join()</span><br><span class="line">    + 线程.join()</span><br><span class="line">        + 等待某线程运行结束</span><br><span class="line">    + 同步应用</span><br><span class="line">        + 同步：需要等待返回结果</span><br><span class="line">    + 限时同步：参数</span><br><span class="line">        + 最长等待时间</span><br><span class="line">+ interrupt()</span><br><span class="line">    + 打断阻塞线程：sleep、wait、join</span><br><span class="line">        + 抛出Interrupted异常</span><br><span class="line">        + 打断标记设为false</span><br><span class="line">    + 打断正常</span><br><span class="line">        + 打断标记为true</span><br><span class="line">            + 程序不结束</span><br><span class="line">            + 根据打断标记可以主动结束线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 过时方法</span><br><span class="line">    + 造成死锁</span><br><span class="line">+ 守护线程</span><br><span class="line">    + 当非守护线程都结束，守护线程强制结束</span><br><span class="line">    + 垃圾回收线程</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>interrupt实现</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230843538.png" alt="image-20220314230843538"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 两阶段终止模式</span><br><span class="line">    + 错误思路</span><br><span class="line">        + stop()</span><br><span class="line">            + 强制杀死，锁资源无法释放</span><br><span class="line">    + interrupt实现</span><br><span class="line">        + sleep中被打断</span><br><span class="line">            + 抛出异常，执行catch语句，继续运行</span><br><span class="line">                + 手动打断，设置打断标记为真</span><br><span class="line">            + 这里为什么还能进入下一次循环？是因为catch这里会处理异常，而不是抛出异常，抛出异常才会导致线程终止！这里打印红色异常信息不会导致线程终止</span><br><span class="line">        + 非sleep时被打断，设置打断标记未真</span><br><span class="line">            + 结束循环</span><br><span class="line">    + interrupt细节</span><br><span class="line">        + interrupted()会清除打断标记</span><br><span class="line">+ interrupt打断park线程 </span><br><span class="line">    + park暂停</span><br><span class="line">        + 打断标记为false时暂停</span><br><span class="line">        + interrupt可打断park线程</span><br></pre></td></tr></table></figure><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程状态</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230908950.png" alt="image-20220314230908950"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ 五种状态</span><br><span class="line">    + 初始状态</span><br><span class="line">        + 创建线程对象</span><br><span class="line">+ 可运行状态    </span><br><span class="line">        + 线程已被创建，可调度执行</span><br><span class="line">    + 运行状态</span><br><span class="line">        + 获取cpu时间片</span><br><span class="line">    + 阻塞状态</span><br><span class="line">        + 调用阻塞API</span><br><span class="line">    + 终止状态</span><br><span class="line">        + 线程执行完毕</span><br><span class="line">+ 六种状态：根据Thread.State</span><br><span class="line">    + new</span><br><span class="line">        + 创建对象</span><br><span class="line">    + runnable</span><br><span class="line">        + 包括可运行、运行、阻塞状态</span><br><span class="line">    + terminated</span><br><span class="line">        + 终止状态</span><br><span class="line">    + java API层面的阻塞</span><br><span class="line">        + blocked</span><br><span class="line">            + 拿不到锁</span><br><span class="line">        + waiting</span><br><span class="line">            + join()</span><br><span class="line">        + timed waiting</span><br><span class="line">            + sleep()</span><br><span class="line">+ 六种状态演示</span><br><span class="line">    + sleep不会释放锁，只会释放cpu资源；wait既会释放CPU又会释放锁资源</span><br><span class="line">    + 拿不到锁，blocked</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 小结</span><br><span class="line">    + 线程创建</span><br><span class="line">        + 3种</span><br><span class="line">    + api</span><br><span class="line">        + join</span><br><span class="line">        + interrupt</span><br><span class="line">    + 线程状态</span><br><span class="line">        + 五种</span><br><span class="line">        + 六种</span><br><span class="line">    + 应用</span><br><span class="line">        + 异步调用</span><br><span class="line">        + 同步等待join</span><br><span class="line">        + 异步编排</span><br><span class="line">    + 原理</span><br><span class="line">        + 运行流程</span><br><span class="line">            + 栈、栈帧</span><br><span class="line">            + 上下文切换</span><br><span class="line">            + 程序计数器</span><br><span class="line">        + 创建源码</span><br><span class="line">    + 设计模式</span><br><span class="line">        + 两阶段终止interrupt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生实战</title>
      <link href="/2022/03/12/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%9E%E6%88%98/"/>
      <url>/2022/03/12/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312161918939.png" alt="image-20220312161918939"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312161936438.png" alt="image-20220312161936438"></p><ul><li><p>容器化相比虚拟化</p><ul><li><p>同一标准</p><ul><li><p>应用无论什么语言同一构建成镜像</p></li><li><p>镜像分享仓库</p></li><li><p>容器化时代</p><ul><li>虚拟化技术</li><li>容器化技术</li></ul></li></ul></li><li><p>资源隔离</p><ul><li>资源隔离</li><li>访问设备隔离</li><li>网络隔离</li><li>用户隔离</li></ul></li></ul></li></ul><ul><li><p>docker架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1624937894925-f437bd98-94e2-4334-9657-afa69bb52179.svg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1625373590853-2aaaa76e-d5b5-446b-850a-f6cfa26ac70a.png" alt="image.png"></p></li><li><p>操作</p></li></ul><ul><li><p>镜像操作</p><ul><li>docker hub仓库</li></ul></li><li><p>容器操作</p><ul><li><p>外部操作</p></li><li><p>内部操作</p><ul><li>看镜像仓库官网</li></ul></li></ul></li><li><p>打包镜像变化</p><ul><li>docker commit</li></ul></li><li><p>镜像保存</p><ul><li>docker save</li><li>保存为压缩包文件</li></ul></li><li><p>镜像加载</p><ul><li>docker load</li><li>读取压缩包为镜像</li></ul></li><li><p>镜像推送</p><ul><li>login：登录仓库</li><li>tag：改名，带上自己的仓库名</li><li>push：推送镜像</li></ul></li><li><p>挂载</p><ul><li>保证外部有配置文件</li><li>提前cp出来文件</li></ul></li><li><p>其他命令</p><ul><li><p>docker logs 容器</p><ul><li>容器日志</li></ul></li><li><p>docker cp</p><ul><li>容器复制到本地</li><li>本地复制到容器</li></ul></li></ul></li><li><p>构建应用</p></li></ul><ul><li><p>以前</p><ul><li>springboot打包</li><li>jar包上传服务器（环境）</li><li>运行jar包</li></ul></li><li><p>现在</p><ul><li><p>打包镜像，启动即用</p></li><li><p>编写docker file（如何打包）</p><ul><li><p>from：基础镜像</p><ul><li>运行环境</li></ul></li><li><p>label：作者</p></li><li><p>copy：把jar包复制到容器中位置</p></li><li><p>entrypoint：启动命令</p><ul><li>java -jar xx</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312162555498.png" alt="image-20220312162555498"></p></li></ul></li><li><p>上传到linux运行打包</p><ul><li>docker file + jar包</li><li>docker build<ul><li>tag：镜像名</li><li>当前目录工作</li></ul></li></ul></li><li><p>启动容器应用</p></li><li><p>docker logs xx 查看日志</p></li></ul></li><li><p>应用分享与启动</p><ul><li>tag</li><li>push</li><li>pull</li></ul></li></ul><h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><ul><li><p>组织架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1625452728905-e72041a2-cf1b-4b24-a327-7f0c3974a931.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163709410.png" alt="image-20220312163709410"></p></li><li><p>k8s集群部署</p><ul><li>三个服务器</li><li>安装docker容器环境</li><li>k8s<ul><li>kubelet、kubeadm、kubectl</li></ul></li><li>kubeadm启动集群<ul><li>master</li><li>worker</li><li>dashboard页面</li></ul></li></ul></li><li><p>核心实战</p><ul><li><p>namespace</p><ul><li>隔离资源</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163739852.png" alt="image-20220312163739852"></p></li><li><p>pod</p><ul><li><p>一组容器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163750025.png" alt="image-20220312163750025"></p></li><li><p>创建pod</p><ul><li>命令行</li><li>配置文件<ul><li>apply -f</li></ul></li></ul></li></ul></li><li><p>pod网络ip</p><ul><li>集群内公共访问</li></ul></li><li><p>多容器pod</p><ul><li>共享pod网络</li><li>端口不同即可部署多个相同应用</li></ul></li><li><p>deployment部署</p><ul><li><p>控制pod</p><ul><li>自愈</li><li>多副本</li></ul></li><li><p>扩缩容</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163803222.png" alt="image-20220312163803222"></p></li><li><p>自愈&amp;故障转移</p></li><li><p>阈值设置</p></li><li><p>滚动更新</p><ul><li>set新镜像自动滚动更新</li><li>不停机更新</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163809935.png" alt="image-20220312163809935"></p></li><li><p>版本回退</p><ul><li>rollout<ul><li>history<ul><li>查看历史部署</li></ul></li><li>undo<ul><li>回退</li></ul></li></ul></li></ul></li><li><p>工作负载：控制pod</p><ul><li>有状态、无状态</li><li>守护进程</li><li>任务等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163840752.png" alt="image-20220312163840752"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163820457.png" alt="image-20220312163820457"></p></li></ul></li></ul></li><li><p>服务网格</p><ul><li><p>service</p><ul><li>暴露：将一组pod公开为网络服务</li><li>自带负载均衡</li><li>集群内ip、域名访问</li><li>服务暴露<ul><li>clusterIP<ul><li>只能集群内访问</li></ul></li><li>NodePort<ul><li>集群外也可以访问（每个节点）</li><li>随机分配端口（3万以上）</li><li>nodeport——targetport——containerport</li></ul></li></ul></li></ul></li><li><p>ingress</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163902230.png" alt="image-20220312163902230"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163909266.png" alt="image-20220312163909266"></p><ul><li><p>集群统一网关入口</p></li><li><p>ingress网络模型</p><ul><li>底层nginx</li><li>ingress接收请求转发到不同service<ul><li>每个模块服务抽取为service<ul><li>service层网络</li></ul></li></ul></li></ul></li><li><p>路径重写</p></li><li><p>限流</p></li></ul></li><li><p>网络模型总结</p><ul><li>pod层，组合容器</li><li>service层，负载均衡pod</li><li>ingress层，路由service</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163919837.png" alt="image-20220312163919837"></p></li></ul></li><li><p>存储抽象</p><ul><li><p>数据挂载层同一管理为存储层</p><ul><li><p>多种存储框架</p><ul><li><p>NFS</p><ul><li><p>client节点同步server节点数据</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163928292.png" alt="image-20220312163928292"></p></li></ul></li></ul></li><li><p>搭建NFS环境</p></li><li><p>deploy数据卷挂载</p><ul><li><p>原生方式</p><ul><li>创建文件夹</li><li>配置deploy文件</li></ul></li><li><p>PV与PVC</p><ul><li><p>PV持久卷：指定保存位置</p></li><li><p>PVC持久卷规格声明：容量等</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163942434.png" alt="image-20220312163942434"></p></li><li><p>pvc配置文件</p></li></ul></li></ul></li><li><p>configmap抽取配置</p><ul><li><p>configmap便于镜像和配置文件的解耦</p></li><li><p>编写配置文件，创建为配置集</p><ul><li>保存在etcd</li></ul></li><li><p>启动pod，配置文件挂载configmap</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163949059.png" alt="image-20220312163949059"></p></li></ul></li><li><p>secret秘钥令牌</p><ul><li><p>创建serect</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163958664.png" alt="image-20220312163958664"></p></li><li><p>base64编码</p><ul><li>docker仓库第三方需解密</li><li>可破解</li></ul></li></ul></li></ul></li></ul></li><li><p>小结</p><ul><li>deployment</li><li>其他工作负载</li><li>pod</li><li>service</li><li>ingress</li><li>pvc</li><li>configmap</li><li>serect</li></ul></li></ul><h1 id="kubeSphere"><a href="#kubeSphere" class="headerlink" title="kubeSphere"></a>kubeSphere</h1><ul><li><p>kubesphere</p><ul><li><p>简介</p><ul><li>可视化界面</li><li>多租户</li><li>多k8s集群管理</li><li>CI/CD</li><li>微服务治理：服务网格</li><li>应用管理</li></ul></li><li><p>安装</p><ul><li><p>k8s安装</p><ul><li>默认存储类型nfs</li><li>metrics-server</li><li>全功能安装</li></ul></li><li><p>linux安装</p><ul><li><p>单节点一键安装</p><ul><li>kubekey</li></ul></li><li><p>多节点安装</p><ul><li>kubekey</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164547433.png" alt="image-20220312164547433"></p></li></ul></li></ul></li><li><p>多租户管理</p></li><li><p>中间件部署</p><ul><li><p>手动部署</p><ul><li>依据docker hub文档</li><li>configmap</li><li>pvc</li><li>部署工作负载<ul><li>镜像、资源、端口</li><li>环境变量、配置、挂载文件</li></ul></li><li>部署服务<ul><li>暴露<ul><li>集群内部通过域名访问（自动）</li><li>集群外部<ul><li>指定工作负载，集群外访问</li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164602153.png" alt="image-20220312164602153"></p></li><li><p>直接部署应用（从应用商店）</p><ul><li>要自己打开clusterConfiguration</li></ul></li><li><p>应用仓库</p><ul><li>helm-k8s包管理仓库</li><li>添加应用仓库</li></ul></li></ul></li><li><p>应用部署cloud</p><ul><li><p>数据层</p></li><li><p>微服务治理层</p></li><li><p>微服务层</p><p>​            <img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164622245.png" alt="image-20220312164622245"></p><ul><li>制作镜像<ul><li>docker file</li><li>maven打包</li></ul></li><li>推送镜像<ul><li>阿里云镜像仓库</li><li>应用部署</li></ul></li></ul></li><li><p>前端层</p><ul><li><p>基础镜像nginx</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164642652.png" alt="image-20220312164642652"></p></li><li><p>构建镜像</p></li><li><p>部署</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164652308.png" alt="image-20220312164652308"></p></li><li><p>存活检查：探针</p></li></ul></li><li><p>devops</p><ul><li><p>敏捷开发</p></li><li><p>全链路自动化</p></li><li><p>cloud应用上云</p><ul><li><p>中间件层</p><ul><li>手动构建服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164744707.png" alt="image-20220312164744707"></p></li><li><p>微服务层</p><ul><li>生产环境配置抽取</li><li>nacos配置中心<ul><li>域名地址配置中间件</li></ul></li></ul></li><li><p>流水线</p><ul><li><p>流水线模板</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164758372.png" alt="image-20220312164758372"></p></li><li><p>第一步-拉取代码</p></li><li><p>第二步-项目编译</p><ul><li>配置maven阿里云镜像<ul><li>修改ks-devops-agent配置</li></ul></li></ul></li><li><p>第三步-构建镜像</p><ul><li><p>基础操作</p></li><li><p>并发构建</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164807965.png" alt="image-20220312164807965"></p></li></ul></li><li><p>第四步-推送镜像</p><ul><li><p>基础操作</p><ul><li>镜像仓库凭证</li></ul></li><li><p>并发推送</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164813947.png" alt="image-20220312164813947"></p></li></ul></li><li><p>第五步-部署到dev环境</p><ul><li><p>微服务准备deploy.yaml部署文件</p></li><li><p>镜像凭证</p><ul><li>阿里云仓库密钥</li></ul></li><li><p>并行部署</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164820639.png" alt="image-20220312164820639"></p></li><li><p>就绪探针</p></li></ul></li><li><p>第六步-系统邮件</p></li></ul></li><li><p>前端项目</p><ul><li><p>流水线</p><ul><li>基础环境nodejs</li><li>拉取代码</li><li>项目安装依赖、编译</li><li>构建镜像<ul><li>docker file</li></ul></li></ul></li><li><p>推送镜像</p></li><li><p>部署到dev环境</p><ul><li>deploy.yaml</li></ul></li><li><p>发送确认邮件</p></li></ul></li><li><p>部署nust-site前端项目</p><ul><li><p>基于nust服务端渲染</p></li><li><p>打包镜像</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164832626.png" alt="image-20220312164832626"></p></li><li><p>可以请求一切走集群内网（服务端渲染）</p></li></ul></li><li><p>webhook自动启动流水线</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164847450.png" alt="image-20220312164847450"></p><ul><li><p>写完代码提交</p></li><li><p>给指定地方发请求</p></li><li><p>流水线自动运行</p></li><li><p>创建webhook：gitee配置</p></li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt"><a href="#kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt" class="headerlink" title="kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt"></a>kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt</h1><ul><li><p>kubekey运维高可用集群</p><ul><li><p>Kubekey介绍</p><ul><li>kubeadm、kops、kubespray方式<ul><li>容器环境、管理证书</li><li>apiserver负载均衡器</li><li>etcd等</li></ul></li><li>kubekey方式<ul><li>部署k8s、k3s</li></ul></li></ul></li><li><p>部署高可用k8s集群</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165738542.png" alt="image-20220312165738542"></p><ul><li><p>外部负载均衡</p></li><li><p>内部负载均衡</p></li><li><p>kubekey部署高可用集群</p></li></ul></li><li><p>kubekey集群配置文件</p><ul><li>hosts：ip、user</li></ul></li><li><p>k8s增删集群节点</p></li><li><p>集群证书管理</p></li><li><p>kubesphere启用可插拔组件</p></li><li><p>节点管理</p></li></ul></li><li><p>devops深入</p><ul><li><p>devops元素周期表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165317185.png" alt="image-20220312165317185"></p></li><li><p>devops流程</p></li><li><p>devops生命周期</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165751201.png" alt="image-20220312165751201"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165800148.png" alt="image-20220312165800148"></p></li><li><p>devops流水线</p></li><li><p>质量扫描&amp;单元测试&amp;制品管理</p></li><li><p>自动部署构建</p></li><li><p>devops自动部署</p></li><li><p>source to images 发布应用</p><ul><li>无需dockerfile</li><li>通过github代码地址</li></ul></li><li><p>binary to image发布应用</p><ul><li>通过jar包</li></ul></li><li><p>Jenkinsfile部署流水线</p></li></ul></li><li><p>kubesphere备份与恢复</p><ul><li>多节点模式</li><li>master节点启停</li><li>woker节点启停</li><li>集群启停</li></ul></li><li><p>云原生应用管理</p><ul><li>调试应用</li><li>应用调度</li><li>helm<ul><li>helm及应用仓库</li><li>开发helm</li><li>k8s应用声明周期</li><li>应用仓库管理</li><li>应用管理场景</li></ul></li></ul></li><li><p>kubernetes federation</p></li><li><p>服务网格架构</p><ul><li><p>微服务</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165816353.png" alt="image-20220312165816353"></p><ul><li><p>微服务框架挑战</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165824002.png" alt="image-20220312165824002"></p><ul><li>过于绑定技术栈</li><li>多语言受限</li><li>代码侵入度过高</li></ul></li></ul></li><li><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165831921.png" alt="image-20220312165831921"></p><ul><li><p>side car</p></li><li><p>服务网格</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165836512.png" alt="image-20220312165836512"></p><ul><li>一组轻量级网络代理实现</li></ul></li></ul></li><li><p>istio</p><ul><li><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165844680.png" alt="image-20220312165844680"></p></li><li><p>安装部署</p></li><li><p>测试项目部署</p></li><li><p>isito核心概念</p><ul><li>虚拟服务</li><li>目标规则</li></ul></li><li><p>kubesphere启用服务治理</p><ul><li><p>启用istio</p></li><li><p>创建服务</p></li><li><p>服务治理</p><ul><li><p>链路追踪</p></li><li><p>流量监控</p></li><li><p>灰度发布</p><ul><li><p>金丝雀发布</p><ul><li>流量手动分配</li></ul></li><li><p>达到足够上线条件</p><ul><li>接管</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><p>k8s可观测性</p><ul><li>日志系统</li><li>日志安装<ul><li>kubesphere可插拔式安装</li><li>cluster configuration<ul><li>logging<ul><li>集合fluent bit</li></ul></li></ul></li></ul></li></ul></li><li><p>日志查看</p><ul><li><p>容器日志查询</p></li><li><p>日志检索与落盘日志收集</p><ul><li>开启日志收集</li><li>创建工作负载<ul><li>alpine镜像<ul><li>启动命令</li></ul></li><li>挂载pvc</li></ul></li></ul></li><li><p>常见问题</p><ul><li>存储外部es，关闭内部es</li><li>日志保留日期</li></ul></li></ul></li><li><p>监控与预警</p><ul><li><p>Prometheus</p><ul><li><p>安装node explorer</p></li><li><p>promQL</p></li><li><p>告警处理</p><ul><li>告警规则</li></ul></li><li><p>operator</p><ul><li>控制中心</li></ul></li></ul></li><li><p>kubesphere监控</p><ul><li>基于Prometheus</li></ul></li><li><p>费率统计</p></li></ul></li><li><p>kubevirt虚拟机管理</p><ul><li><p>虚拟化技术</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165923874.png" alt="image-20220312165923874"></p></li><li><p>kubevirt</p></li><li><p>KSV平台</p></li></ul></li><li><p>CKA、CKS</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312170342258.png" alt="image-20220312170342258"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——k8s-DevOps-CI/CD&amp;最终部署</title>
      <link href="/2022/03/11/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-k8s-%E8%87%AA%E5%8A%A8%E5%8C%96cicd&amp;%E6%9C%80%E7%BB%88%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/03/11/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-k8s-%E8%87%AA%E5%8A%A8%E5%8C%96cicd&amp;%E6%9C%80%E7%BB%88%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps: Development 和 Operations 的组合</p><ul><li>DevOps 看作开发（软件工程）、技术运营和质量保障（QA）三者的交集。</li><li>突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、 发布更加快捷、频繁和可靠。</li><li>DevOps 希望做到的是软件产品交付过程中 <strong>IT 工具链的打通</strong>，使得各个团队减少时间损耗，更加高效地协同工作。DevOps 能力图如下，良好的闭环可以大大增加整体的产出。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311121142708.png" alt="image-20220311121142708"></p><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h2><p>1、持续集成（Continuous Integration） </p><p>持续集成是指软件个人研发的部分向软件整体部分交付，频繁进行集成以便更快地发现 其中的错误。“持续集成”源自于极限编程（XP），是 XP 最初的 12 种实践之一。</p><p>CI 需要具备这些：</p><ul><li><strong>全面的自动化测试。</strong>这是实践持续集成&amp;持续部署的基础，同时，选择合适的自动化测试工具也极其重要</li><li><strong>灵活的基础设施。容器，虚拟机</strong>的存在让开发人员和 QA 人员不必再大费周折</li><li><strong>版本控制工具。</strong>如 <strong>Git</strong>，CVS，SVN 等</li><li><strong>自动化的构建和软件发布流程的工具</strong>，如 <strong>Jenkins</strong>，flow.ci</li><li><strong>反馈机制。</strong>如构建/测试的失败，可以快速地反馈到相关负责人，以尽快解决达到一个更稳定的版本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311121324347.png" alt="image-20220311121324347"></p><p>2、持续交付（Continuous Delivery） </p><p>持续交付在持续集成的基础上，将集成后的代码部署到<strong>更贴近真实运行环境的</strong>「类生产环境」 （production-like environments）中。持续交付优先于整个产品生命周期的软件部署，建立在高水平自动化持续集成之上。</p><p>灰度发布。 </p><p>持续交付和持续集成的优点非常相似：</p><ul><li><strong>快速发布。</strong>能够应对业务需求，并更快地实现软件价值</li><li><strong>编码-&gt;测试-&gt;上线-&gt;交付</strong>的频繁迭代周期缩短，同时获得迅速反馈</li><li><strong>高质量的软件发布标准</strong>。整个交付过程标准化、可重复、可靠</li><li><strong>整个交付过程进度可视化，</strong>方便团队人员了解项目成熟度</li><li><strong>更先进的团队协作方式。</strong>从需求分析、产品的用户体验到交互 设计、开发、测试、运维等角色密切协作，相比于传统的瀑布式软件团队，更少浪费</li></ul><p>3、持续部署（Continuous Deployment）</p><p><strong>持续部署</strong>是指当交付的代码通过评审之后，<strong>自动部署到生产环境中</strong>。持续部署是持续交付的最高阶段。这意味着，所有通过了一系列的自动化测试的改动都将自动部署到生产环境。它也可以被称为“Continuous Release”。</p><p>“开发人员提交代码，持续集成服务器获取代码，执行单元测试，根据测试结果决定是否部署到预演环境，如果成功部署到预演环境，进行整体验收测试，如果测试通过，自动部署到产品环境，全程自动化高效运转。”</p><p>持续部署主要好处是，可以相对独立地部署新的功能，并能快速地收集真实用户的反馈。 </p><p>下图是由 Jams Bowman 绘制的持续交付工具链图</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/cicd-tools-fullsize.jpeg" alt="cicd-tools-fullsize"></p><h1 id="最终部署"><a href="#最终部署" class="headerlink" title="最终部署"></a>最终部署</h1><p>kubesphere架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/architecture.png" alt="architecture"></p><h2 id="有状态服务部署"><a href="#有状态服务部署" class="headerlink" title="有状态服务部署"></a>有状态服务部署</h2><p>1、有状态服务抽取配置为 ConfigMap</p><p>2、有状态服务必须使用 pvc 持久化数据</p><p>3、服务集群内访问使用 DNS 提供的稳定域名</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311125735647.png" alt="image-20220311125735647"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311131906123.png" alt="image-20220311131906123"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311131257276.png" alt="image-20220311131257276"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 部署流程</span><br><span class="line">    + configMap</span><br><span class="line">    + pvc</span><br><span class="line">    + 镜像</span><br><span class="line">    + 资源限制</span><br><span class="line">    + 环境变量</span><br><span class="line">    + 挂载pvc</span><br><span class="line">    + 外网访问、集群内访问等</span><br></pre></td></tr></table></figure><p>依次部署集群：</p><p>MySQL、Redis、RabbitMQ、Elasticsearch、Kibana</p><p>Nacos、Zipkin、Nginx、Sentinel</p><h2 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1、dockerfile</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311132713759.png" alt="image-20220311132713759"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 创建项目 dockerfile2、上传项目到服务器。 </span><br><span class="line">+ 进入项目，构建镜像到本地仓库； </span><br><span class="line">+ docker build -t nginx:GA-1.0 -f ./Dockerfile . </span><br><span class="line">+ docker images </span><br><span class="line">+ docker exec -it 容器 id /bin/bash；进入容器，修改容器 </span><br><span class="line">+ docker commit -a “leifengyang” -m “nginxxx” 容器 id </span><br><span class="line">+  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] </span><br><span class="line">+  OPTIONS 说明： </span><br><span class="line">+ -a :提交的镜像作者； </span><br><span class="line">+ -c :使用 Dockerfile 指令来创建镜像； </span><br><span class="line">+ -m :提交时的说明文字； </span><br><span class="line">+ -p :在 commit 时，将容器暂停。 </span><br><span class="line">+ docker login : 登陆到一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub </span><br><span class="line">+ docker login -u 用户名 -p 密码 </span><br><span class="line">+ docker logout : 登出一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub </span><br><span class="line">+ 推送镜像到 docker hub </span><br><span class="line">+ 标记镜像，docker tag local-image:tagname username/new-repo:tagname </span><br><span class="line">+ 上传镜像，docker push username/new-repo:tagname </span><br><span class="line">+ 保存镜像，加载镜像 </span><br><span class="line">+ 可以保存镜像为 tar，使用 u 盘等设备复制到任意 docker 主机，再次加载镜像 </span><br><span class="line">+ 保存：docker save spring-boot-docker -o /home/spring-boot-docker.tar </span><br><span class="line">+ 加载：docker load -i spring-boot-docker.tar </span><br><span class="line">+ 阿里云操作 </span><br><span class="line">+ 登录阿里云，密码就是开通镜像仓库时的密码 docker login --username=qwertyuiopasdf_aa registry.cn-hangzhou.aliyuncs.com </span><br><span class="line">+ 拉取镜像 docker pull registry.cn-hangzhou.aliyuncs.com/atguigumall/gulimall-nginx:v1.0 </span><br><span class="line">+ 推送镜像 docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/atguigumall/gulimall-nginx:v1 </span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/atguigumall/gulimall-nginx:v1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM java:openjdk-8-jre-alpine</span><br><span class="line">WORKDIR /home</span><br><span class="line">COPY target/*.jar /home</span><br><span class="line">ENTRYPOINT java -jar *.jar</span><br></pre></td></tr></table></figure><p>2、k8s部署描述文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubesphere</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">ks-sample</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ks-sample</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubesphere-sample-prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubesphere</span></span><br><span class="line">      <span class="attr">component:</span> <span class="string">ks-sample</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubesphere</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">ks-sample</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CACHE_IGNORE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">js|html</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CACHE_PUBLIC_EXPIRATION</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">3d</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">$REGISTRY/$HARBOR_NAMESPACE/$APP_NAME:$TAG_NAME</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">ks</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">300m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">600Mi</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">          <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">          <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311150912792.png" alt="image-20220311150912792"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ Containerport：容器内服务端口</span><br><span class="line">+ TargetPort</span><br><span class="line">+ pod访问container</span><br><span class="line">+ Port：集群内service端口，域名、ip端口号</span><br><span class="line">+ Nodeport：外部访问集群service</span><br><span class="line">+ 特点</span><br><span class="line">+ Targetport、serviceport端口可以一样</span><br><span class="line">+ 每个service、pod地址都不一样，都是集群内虚拟的</span><br><span class="line">+ Nodeport不能一样，暴露外部端口</span><br></pre></td></tr></table></figure><p>3、Jenkinsfile流水线文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pipeline</span> &#123;</span><br><span class="line">  <span class="string">agent</span> &#123;</span><br><span class="line">    <span class="string">node</span> &#123;</span><br><span class="line">      <span class="string">label</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">parameters</span> &#123;</span><br><span class="line">        <span class="string">string(name:&#x27;TAG_NAME&#x27;</span>,<span class="attr">defaultValue:</span> <span class="string">&#x27;&#x27;</span>,<span class="string">description:&#x27;&#x27;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">environment</span> &#123;</span><br><span class="line">        <span class="string">DOCKER_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;dockerhub-id&#x27;</span></span><br><span class="line">        <span class="string">GITHUB_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;github-id&#x27;</span></span><br><span class="line">        <span class="string">KUBECONFIG_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;demo-kubeconfig&#x27;</span></span><br><span class="line">        <span class="string">REGISTRY</span> <span class="string">=</span> <span class="string">&#x27;docker.io&#x27;</span></span><br><span class="line">        <span class="string">DOCKERHUB_NAMESPACE</span> <span class="string">=</span> <span class="string">&#x27;1637872839&#x27;</span></span><br><span class="line">        <span class="string">GITHUB_ACCOUNT</span> <span class="string">=</span> <span class="string">&#x27;1637872839&#x27;</span></span><br><span class="line">        <span class="string">APP_NAME</span> <span class="string">=</span> <span class="string">&#x27;devops-java-sample&#x27;</span></span><br><span class="line">        <span class="string">SONAR_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;sonar-qube&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">stages</span> &#123;</span><br><span class="line">        <span class="string">stage</span> <span class="string">(&#x27;checkout</span> <span class="string">scm&#x27;)</span> &#123;</span><br><span class="line">            <span class="string">steps</span> &#123;</span><br><span class="line">                <span class="string">checkout(scm)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">stage</span> <span class="string">(&#x27;unit</span> <span class="string">test&#x27;)</span> &#123;</span><br><span class="line">            <span class="string">steps</span> &#123;</span><br><span class="line">                <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;mvn clean  -gs `pwd`/configuration/settings.xml test&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="string">stage</span> <span class="string">(&#x27;build</span> <span class="string">&amp;</span> <span class="string">push&#x27;)</span> &#123;</span><br><span class="line">            <span class="string">steps</span> &#123;</span><br><span class="line">                <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;mvn  -Dmaven.test.skip=true -gs `pwd`/configuration/settings.xml clean package&#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;docker build -f Dockerfile-online -t $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER .&#x27;</span></span><br><span class="line">                    <span class="string">withCredentials(</span>[<span class="string">usernamePassword(passwordVariable</span> <span class="string">:</span> <span class="string">&#x27;DOCKER_PASSWORD&#x27;</span> ,<span class="attr">usernameVariable :</span> <span class="string">&#x27;DOCKER_USERNAME&#x27;</span> ,<span class="attr">credentialsId :</span> <span class="string">&quot;$DOCKER_CREDENTIAL_ID&quot;</span> ,<span class="string">)</span>]<span class="string">)</span> &#123;</span><br><span class="line">                        <span class="string">sh</span> <span class="string">&#x27;echo &quot;$DOCKER_PASSWORD&quot; | docker login $REGISTRY -u &quot;$DOCKER_USERNAME&quot; --password-stdin&#x27;</span></span><br><span class="line">                        <span class="string">sh</span> <span class="string">&#x27;docker push  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">stage(&#x27;push</span> <span class="string">latest&#x27;)</span>&#123;</span><br><span class="line">           <span class="string">when</span>&#123;</span><br><span class="line">             <span class="string">branch</span> <span class="string">&#x27;master&#x27;</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="string">steps</span>&#123;</span><br><span class="line">                <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                  <span class="string">sh</span> <span class="string">&#x27;docker tag  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:latest &#x27;</span></span><br><span class="line">                  <span class="string">sh</span> <span class="string">&#x27;docker push  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:latest &#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">stage(&#x27;deploy</span> <span class="string">to</span> <span class="string">dev&#x27;)</span> &#123;</span><br><span class="line">          <span class="string">when</span>&#123;</span><br><span class="line">            <span class="string">branch</span> <span class="string">&#x27;master&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="string">steps</span> &#123;</span><br><span class="line">            <span class="string">input(id:</span> <span class="string">&#x27;deploy-to-dev&#x27;</span>, <span class="attr">message:</span> <span class="string">&#x27;deploy to dev?&#x27;</span><span class="string">)</span></span><br><span class="line">            <span class="string">kubernetesDeploy(configs:</span> <span class="string">&#x27;deploy/dev-ol/**&#x27;</span>, <span class="attr">enableConfigSubstitution:</span> <span class="literal">true</span>, <span class="attr">kubeconfigId:</span> <span class="string">&quot;$KUBECONFIG_CREDENTIAL_ID&quot;</span><span class="string">)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">stage(&#x27;push</span> <span class="string">with</span> <span class="string">tag&#x27;)</span>&#123;</span><br><span class="line">          <span class="string">when</span>&#123;</span><br><span class="line">            <span class="string">expression</span>&#123;</span><br><span class="line">              <span class="string">return</span> <span class="string">params.TAG_NAME</span> <span class="string">=~</span> <span class="string">/v.*/</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="string">steps</span> &#123;</span><br><span class="line">              <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                <span class="string">input(id:</span> <span class="string">&#x27;release-image-with-tag&#x27;</span>, <span class="attr">message:</span> <span class="string">&#x27;release image with tag?&#x27;</span><span class="string">)</span></span><br><span class="line">                  <span class="string">withCredentials(</span>[<span class="string">usernamePassword(credentialsId:</span> <span class="string">&quot;$GITHUB_CREDENTIAL_ID&quot;</span>, <span class="attr">passwordVariable:</span> <span class="string">&#x27;GIT_PASSWORD&#x27;</span>, <span class="attr">usernameVariable:</span> <span class="string">&#x27;GIT_USERNAME&#x27;</span><span class="string">)</span>]<span class="string">)</span> &#123;</span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git config --global user.email &quot;kubesphere@yunify.com&quot; &#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git config --global user.name &quot;kubesphere&quot; &#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git tag -a $TAG_NAME -m &quot;$TAG_NAME&quot; &#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git push http://$GIT_USERNAME:$GIT_PASSWORD@github.com/$GITHUB_ACCOUNT/devops-java-sample.git --tags --ipv4&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="string">sh</span> <span class="string">&#x27;docker tag  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:$TAG_NAME &#x27;</span></span><br><span class="line">                <span class="string">sh</span> <span class="string">&#x27;docker push  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:$TAG_NAME &#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">stage(&#x27;deploy</span> <span class="string">to</span> <span class="string">production&#x27;)</span> &#123;</span><br><span class="line">          <span class="string">when</span>&#123;</span><br><span class="line">            <span class="string">expression</span>&#123;</span><br><span class="line">              <span class="string">return</span> <span class="string">params.TAG_NAME</span> <span class="string">=~</span> <span class="string">/v.*/</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="string">steps</span> &#123;</span><br><span class="line">            <span class="string">input(id:</span> <span class="string">&#x27;deploy-to-production&#x27;</span>, <span class="attr">message:</span> <span class="string">&#x27;deploy to production?&#x27;</span><span class="string">)</span></span><br><span class="line">            <span class="string">kubernetesDeploy(configs:</span> <span class="string">&#x27;deploy/prod-ol/**&#x27;</span>, <span class="attr">enableConfigSubstitution:</span> <span class="literal">true</span>, <span class="attr">kubeconfigId:</span> <span class="string">&quot;$KUBECONFIG_CREDENTIAL_ID&quot;</span><span class="string">)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、阿里云镜像仓库</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311152111010.png" alt="image-20220311152111010"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 创建镜像仓库</span><br><span class="line">    + 登录仓库</span><br><span class="line">    + 拉取镜像</span><br><span class="line">    + 推送镜像</span><br></pre></td></tr></table></figure><h3 id="DevOps部署流水线"><a href="#DevOps部署流水线" class="headerlink" title="DevOps部署流水线"></a>DevOps部署流水线</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311150756780.png" alt="image-20220311150756780"></p><p>1、拉取gitee代码&amp;参数化构建&amp;环境变量</p><ul><li>配置凭证</li><li>配置构建微服务参数</li><li>配置运行参数等</li></ul><p>2、Sonar代码质量分析</p><ul><li>配置阿里云镜像</li><li>进入sonar查看分析报告</li><li>bug修改等</li></ul><p>3、构建&amp;推送镜像</p><ul><li>配置阿里云私有镜像仓库</li><li>根据dockerfile 打包镜像</li><li>推送镜像</li></ul><p>4、部署到k8s生产环境</p><p>5、发布</p><ul><li><p>gitee仓库地址</p></li><li><p>tag信息</p></li></ul><h2 id="全链路最终部署"><a href="#全链路最终部署" class="headerlink" title="全链路最终部署"></a>全链路最终部署</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311151019195.png" alt="image-20220311151019195"></p><p>1、数据服务集群</p><p>2、微服务集群</p><p>3、gateway网关集群</p><p>4、nginx集群</p><p>5、vue后台</p><p>6、ingress controller网关路由</p><p>地址——&gt;ingress controller——&gt;动静分离nginx——&gt;gateway——&gt;微服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 部署方式</span><br><span class="line">+ Jenkins流水线</span><br><span class="line">+ 自己打包部署k8s服务</span><br><span class="line">+ 拉取镜像自己运行</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><p>动态扩容节点</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311132218996.png" alt="image-20220311132142809"></p><p>预警信息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311152935372.png" alt="image-20220311152935372"></p><p>监控信息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311132353545.png" alt="image-20220311132353545"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ k8s概念</span><br><span class="line">    + pod、server</span><br><span class="line">    + nodeport等</span><br><span class="line">+ 应用路由</span><br><span class="line">    + ingress controller</span><br><span class="line">+ 配置中心</span><br><span class="line">    + configMap</span><br><span class="line">+ Devops</span><br><span class="line">    + 自动化流水线</span><br><span class="line">        + 修改推送代码</span><br><span class="line">        + 运行流水线构建</span><br><span class="line">+ 监控资源</span><br><span class="line">+ 集群技术</span><br><span class="line">    + 主从、分片、选领导</span><br><span class="line">    + 各种集群</span><br><span class="line">+ Jenkins file</span><br><span class="line">+ Docker file</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——云原生Pass-Kubesphere&amp;集群搭建</title>
      <link href="/2022/03/08/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9FPaaS%E5%B9%B3%E5%8F%B0Kubesphere/"/>
      <url>/2022/03/08/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9FPaaS%E5%B9%B3%E5%8F%B0Kubesphere/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubesphere"><a href="#Kubesphere" class="headerlink" title="Kubesphere"></a>Kubesphere</h1><p>Kubesphere官网：<a href="https://kubesphere.io/zh/">https://kubesphere.io/zh/</a></p><p>KubeSphere 是一款面向云原生设计的开源项目，在目前主流容器调度平台 Kubernetes 之上构建的分布式多租户容器管理平台，提供简单易用的操作界面以及向导式操作方式，在降低用户使用容器调度平台学习成本的同时，极大降低开发、测试、运维的日常工作的复杂度。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>1、安装helm（master节点）</p><p>2、安装 Tiller（master 执行） </p><p>3、安装 OpenEBS（master 执行）</p><p>4、最小化、完整化安装Kubesphere</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308144343351.png" alt="image-20220308144343351"></p><h2 id="多租户管理"><a href="#多租户管理" class="headerlink" title="多租户管理"></a>多租户管理</h2><p>包括集群(Cluster)、企业空间(Workspace)、项目(Project)和DevOps Project(DevOps 工程)的层级关系</p><p><img src="https://www.icode9.com/i/ll/?i=20210712161032787.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zMjE5Njg5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311104750797.png" alt="image-20220311104750797"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1776090-20210826172258323-530376724.png" alt="img"></p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>集群的目标</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309074801138.png" alt="image-20220309074801138"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 集群目标</span><br><span class="line">    + 高可用HA</span><br><span class="line">    + 突破数据量限制</span><br><span class="line">    + 多节点存储</span><br><span class="line">    + 多节点备份</span><br><span class="line">    + 数据备份容灾</span><br><span class="line">    + 压力分担</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309074812891.png" alt="image-20220309074812891"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 基础形式</span><br><span class="line">+ 主从</span><br><span class="line">+ 同步：主从复制</span><br><span class="line">        + 主从调度</span><br><span class="line">    + 分片</span><br><span class="line">    + 分片存储</span><br><span class="line">    + 分片备份</span><br><span class="line">   + 选主</span><br><span class="line">   + 选主容灾</span><br><span class="line">   + 选主调度</span><br></pre></td></tr></table></figure><h2 id="MySQL集群"><a href="#MySQL集群" class="headerlink" title="MySQL集群"></a>MySQL集群</h2><p>集群原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308233055567.png" alt="image-20220308233055567"></p><p>企业中常用的数据库解决方案</p><h3 id="集群方式"><a href="#集群方式" class="headerlink" title="集群方式"></a>集群方式</h3><p>1、MMM</p><p>MySQL-MMM 是 Master-Master Replication Manager for MySQL（mysql 主主复制管理器）的简称，是 Google 的开源项目（Perl 脚本）。MMM 基于 MySQLReplication 做的扩展架构，主要用来监控 mysql 主主复制并做失败转移。其原理是将真实数据库节点的IP（RIP）映射为虚拟 IP（VIP）集。mysql-mmm 的监管端会提供多个虚拟 IP（VIP），包括一个可写 VIP，多个可读 VIP，通过监管的管理，这些 IP 会绑定在可用 mysql 之上，当某一台 mysql 宕机时，监管会将 VIP迁移至其他 mysql。在整个监管过程中，需要在 mysql 中添加相关授权用户，以便让 mysql 可以支持监理机的维护。授权的用户包括一个mmm_monitor 用户和一个 mmm_agent 用户，如果想使用 mmm 的备份工具则还要添加一个 mmm_tools 用户。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308233254614.png" alt="image-20220308233254614"></p><p>2、MHA</p><p>MHA（Master High Availability）目前在 MySQL 高可用方面是一个相对成熟的解决方案, 由日本 DeNA 公司 youshimaton（现就职于 Facebook 公司）开发，是一套优秀的作为 MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中， MHA 能做到在 0~30 秒之内自动完成数据库的故障切换操作（以 2019 年的眼光来说太 慢了），并且在进行故障切换的过程中，MHA 能在最大程度上保证数据的一致性，以 达到真正意义上的高可用。</p><p>3、InnoDB Cluster</p><p>InnoDB Cluster 支持自动 Failover、强一致性、读写分离、读库高可用、读请求负载均衡，横向扩展的特性，是比较完备的一套方案。但是部署起来复杂，想要解决 router单点问题好需要新增组件，如没有其他更好的方案可考虑该方案。 InnoDB Cluster 主要由 MySQL Shell、MySQL Router 和 MySQL 服务器集群组成，三者协同工作，共同为MySQL 提供完整的高可用性解决方案。MySQL Shell 对管理人员提供管理接口，可以很方便的对集群进行配置和管理,MySQL Router 可以根据部署的集群状况自动的初始化，是客户端连接实例。如果有节点 down 机，集群会自动更新配置。集群包含单点写入和多点写入两种模式。在单主模式下，如果主节点 down 掉，从节点自动替换上来，MySQL Router 会自动探测，并将客户端连接到新节点。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308233434429.png" alt="image-20220308233434429"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ MMM</span><br><span class="line">+ MHA</span><br><span class="line">+ InnoDB Cluster</span><br><span class="line">+ 自动故障转移</span><br><span class="line">+ 强一致性</span><br><span class="line">+ 读写分离</span><br><span class="line">+ 高可用</span><br><span class="line">+ 负载均衡</span><br><span class="line">+ 横向拓展</span><br></pre></td></tr></table></figure><h3 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">master：</span><br><span class="line">docker run -p 3307:3306 --name mysql-master \ </span><br><span class="line">-v /mydata/mysql/master/log:/var/log/mysql \ </span><br><span class="line">-v /mydata/mysql/master/data:/var/lib/mysql \ </span><br><span class="line">-v /mydata/mysql/master/conf:/etc/mysql \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \ -d mysql:5.7 </span><br><span class="line">参数说明</span><br><span class="line">-p 3307:3306：将容器的 3306 端口映射到主机的 3307 端口 </span><br><span class="line">-v /mydata/mysql/master/conf:/etc/mysql：将配置文件夹挂在到主机 -v /mydata/mysql/master/log:/var/log/mysql：将日志文件夹挂载到主机 </span><br><span class="line">-v /mydata/mysql/master/data:/var/lib/mysql/：将配置文件夹挂载到主机 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码</span><br><span class="line">slaver：</span><br><span class="line">docker run -p 3317:3306 --name mysql-slaver-01 \ </span><br><span class="line">-v /mydata/mysql/slaver/log:/var/log/mysql \ </span><br><span class="line">-v /mydata/mysql/slaver/data:/var/lib/mysql \ </span><br><span class="line">-v /mydata/mysql/slaver/conf:/etc/mysql \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \ -d mysql:5.7</span><br><span class="line"></span><br><span class="line">修改配置Master、slaver</span><br><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld] </span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27; </span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27; </span><br><span class="line">character-set-server=utf8 </span><br><span class="line">collation-server=utf8_unicode_ci </span><br><span class="line">skip-character-set-client-handshake </span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line">添加 master 主从复制部分配置 </span><br><span class="line">server_id=1 </span><br><span class="line">log-bin=mysql-bin </span><br><span class="line">read-only=0 </span><br><span class="line">binlog-do-db=gulimall_ums </span><br><span class="line">binlog-do-db=gulimall_pms</span><br><span class="line">binlog-do-db=gulimall_oms </span><br><span class="line">binlog-do-db=gulimall_sms </span><br><span class="line">binlog-do-db=gulimall_wms </span><br><span class="line">binlog-do-db=gulimall_admin </span><br><span class="line">replicate-ignore-db=mysql </span><br><span class="line">replicate-ignore-db=sys </span><br><span class="line">replicate-ignore-db=information_schema </span><br><span class="line">replicate-ignore-db=performance_schema</span><br><span class="line"></span><br><span class="line">添加 slaver主从复制部分配置 </span><br><span class="line">server_id=2 </span><br><span class="line">log-bin=mysql-bin </span><br><span class="line">read-only=1binlog-do-db=gulimall_ums </span><br><span class="line">binlog-do-db=gulimall_pms </span><br><span class="line">binlog-do-db=gulimall_oms </span><br><span class="line">binlog-do-db=gulimall_sms </span><br><span class="line">binlog-do-db=gulimall_wms </span><br><span class="line">binlog-do-db=gulimall_admin </span><br><span class="line">replicate-ignore-db=mysql </span><br><span class="line">replicate-ignore-db=sys </span><br><span class="line">replicate-ignore-db=information_schema </span><br><span class="line">replicate-ignore-db=performance_schema</span><br><span class="line"></span><br><span class="line">Master授权用户</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* to &#x27;backup&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;; </span><br><span class="line"></span><br><span class="line">Master授权用户</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* to &#x27;backup&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;; </span><br><span class="line"></span><br><span class="line">Slaver设置主库连接</span><br><span class="line">change master to </span><br><span class="line">master_host=&#x27;192.168.124.135&#x27;,master_user=&#x27;backup&#x27;,master_password=&#x27;123456&#x27;,mas </span><br><span class="line">ter_log_file=&#x27;mysql-bin.000001&#x27;,master_log_pos=0,master_port=3307;</span><br></pre></td></tr></table></figure><p>1）、主从数据库在自己配置文件中声明需要同步哪个数据库，忽略哪个数据库等信息。并且 server-id 不能一样 </p><p>2）、主库授权某个账号密码来同步自己的数据 </p><p>3）、从库使用这个账号密码连接主库来同步数据</p><h2 id="ShardingSphere"><a href="#ShardingSphere" class="headerlink" title="ShardingSphere"></a>ShardingSphere</h2><p>ShardingSphere-Proxy</p><p><img src="https://shardingsphere.apache.org/document/current/img/shardingsphere-proxy_v2.png" alt="ShardingSphere-Proxy Architecture"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">docker：</span><br><span class="line">docker run -d </span><br><span class="line">-v /mydata/sharding-proxy/conf:/opt/sharding-proxy/conf </span><br><span class="line">-v /mydata/sharding-proxy/lib:/opt/sharding-proxy/lib </span><br><span class="line">--env PORT=3308 </span><br><span class="line">-p13308:3308 apache/sharding-proxy:latest</span><br><span class="line">配置数据分片+读写分离:</span><br><span class="line">schemaName: sharding_db_0</span><br><span class="line">dataSources:</span><br><span class="line">  write_0_ds:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3307/demo_ds_0?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br><span class="line">  read_ds_0:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3317/demo_ds_0?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash">schemaName: sharding_db_1</span></span><br><span class="line">dataSources:</span><br><span class="line">  write_1_ds:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3307/demo_ds_1?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br><span class="line">  read_ds_1:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3317/demo_ds_1?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br></pre></td></tr></table></figure><p>分库分表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309075942273.png" alt="image-20220309075942273"></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h3><p>1、客户端分区</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131147587.png" alt="image-20220309131147587"></p><p>客户端分区方案 的代表为 Redis Sharding，Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的 Redis 多实例集群 方法。Java 的 Redis 客户端驱动库 Jedis，支持 Redis Sharding 功能，即 ShardedJedis 以及 结合缓存池 的 ShardedJedisPool。 </p><p>优点：不使用 第三方中间件，分区逻辑可控，配置 简单，节点之间无关联，容易 线性扩展，灵活性强。 </p><p>缺点：客户端无法动态增删服务节点，客户端需要自行维护分发逻辑，客户端之间 无连接共享，会造成连接浪费。</p><p>2、代理分区</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131230974.png" alt="image-20220309131230974"></p><p>代理分区常用方案有 Twemproxy 和 Codis。</p><p>3、redis-cluster</p><p>redis官方推荐</p><h3 id="高可用方式"><a href="#高可用方式" class="headerlink" title="高可用方式"></a>高可用方式</h3><p>1、Sentinel（ 哨兵机制）支持高可用</p><p>前面介绍了主从机制，但是从运维角度来看，主节点出现了问题我们还需要通过人工干预的方式把从节点设为主节点，还要通知应用程序更新主节点地址，这种方式非常繁琐笨重， 而 且主节点的读写能力都十分有限，有没有较好的办法解决这两个问题，哨兵机制就是针对第 一个问题的有效解决方案，第二个问题则有赖于集群！哨兵的作用就是监控 Redis 系统的运行状况，其功能主要是包括以下三个：</p><ul><li><p>监控(Monitoring): 哨兵(sentinel) 会不断地检查你的 Master 和 Slave 是否运作常。 </p></li><li><p>提醒(Notification): 当被监控的某个 Redis 出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。 </p></li><li><p>自动故障迁移(Automatic failover): 当主数据库出现故障时自动将从数据库转换为主数 据库。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131342915.png" alt="image-20220309131342915"></p><p><strong>哨兵的原理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ Redis Sentinel</span><br><span class="line">+ 三个定时监控任务</span><br><span class="line">+ 向主节点发送请求获取最新拓扑结构</span><br><span class="line">+ 向redis节点的哨兵频道发送故障判断及自身节点信息</span><br><span class="line">+ 哨兵之间订阅哨兵频道，了解集群信息</span><br><span class="line">+ 向全部节点（包括哨兵）发送心跳检测</span><br><span class="line">+ 心跳检测异常，判断下线</span><br><span class="line">+ 主节点判断下线</span><br><span class="line">+ 需要多个哨兵检测下线票数</span><br><span class="line">+ 故障检测和leader选举</span><br><span class="line">+ 主节点判断下线</span><br><span class="line">+ 采用Raft算法选举leader（详见前几次博客：Raft原理）</span><br></pre></td></tr></table></figure><p>2、redis-cluster</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ Redis Cluster</span><br><span class="line">+ 3主3从</span><br><span class="line">+ 故障转移</span><br><span class="line">+ 选举从节点上位</span><br><span class="line">+ key路由</span><br><span class="line">+ 哈希槽分区：16384槽位</span><br><span class="line">+ 数据迁移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131556005.png" alt="image-20220309131556005"></p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>1、哈希槽分区（CRC16校验算法）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131813090.png" alt="image-20220309131813090"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 哈希槽分区</span><br><span class="line">+ 问题限制</span><br><span class="line">+ key批量操作</span><br><span class="line">+ mset、mget只支持相同slot值的key批量操作</span><br><span class="line">+ 映射为不同slot分布在不同节点</span><br><span class="line">+ key事务操作</span><br><span class="line">+ 只支持key在同一节点事务</span><br><span class="line">+ key作为分区最小粒度</span><br><span class="line">+ 不能将大的键值对象，如hash、list映射不同节点</span><br><span class="line">+ 不支持多数据库空间</span><br><span class="line">+ 集群模式只有一个数据库db0</span><br><span class="line">+ 复制结构只支持一层</span><br><span class="line">+ 从节点 只能复制 主节点，不支持 嵌套树状复制 结构</span><br><span class="line">+ 命令大多会重定向，耗时多</span><br><span class="line">+ 非本节点数据</span><br></pre></td></tr></table></figure><p>2、一致性哈希</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309132413181.png" alt="image-20220309132413181"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 一致性哈希</span><br><span class="line">+ 稳定性</span><br><span class="line">+ 哈希倾斜问题</span><br><span class="line">+ 引入虚拟节点</span><br><span class="line">+ 将虚拟节点数据划分到其真实数据节点，保证负载均衡</span><br></pre></td></tr></table></figure><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for port in $(seq 7001 7006); \ </span><br><span class="line">do \ </span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf </span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf </span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf </span><br><span class="line">port $&#123;port&#125; </span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-config-file nodes.conf </span><br><span class="line">cluster-node-timeout 5000 </span><br><span class="line">cluster-announce-ip 192.168.56.10cluster-announce-port $&#123;port&#125; </span><br><span class="line">cluster-announce-bus-port 1$&#123;port&#125; </span><br><span class="line">appendonly yes </span><br><span class="line">EOF </span><br><span class="line">docker run -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; --name redis-$&#123;port&#125; \ </span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/data:/data \ </span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \ </span><br><span class="line">-d redis:5.0.7 redis-server /etc/redis/redis.conf; \ </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">docker exec -it redis-7001 bash redis-cli --cluster create 192.168.56.10:7001 192.168.56.10:7002 192.168.56.10:7003 192.168.56.10:7004 192.168.56.10:7005 192.168.56.10:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure><h2 id="Elasticsearch集群"><a href="#Elasticsearch集群" class="headerlink" title="Elasticsearch集群"></a>Elasticsearch集群</h2><p>elasticsearch 是<strong>天生支持集群</strong>的，他不需要依赖其他的服务发现和注册的组件，如 zookeeper 这些，因为他内置了一个名字叫 ZenDiscovery 的模块，是 elasticsearch 自己实现的一套用于节点发现和选主等功能的组件，所以 elasticsearch 做起集群来非常简单，不需要太多额外的配置和安装额外的第三方组件。</p><h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">+ 节点</span><br><span class="line">+ 主节点</span><br><span class="line">+ 管理集群变更</span><br><span class="line">+ 任意节点知道任意文档位置</span><br><span class="line">+ 请求转发到存储文档的节点</span><br><span class="line">+ 集群健康</span><br><span class="line">+ yellow</span><br><span class="line">+ 主分片正常运行，副本分片不正常</span><br><span class="line">+ green</span><br><span class="line">+ red</span><br><span class="line">+ 分片</span><br><span class="line">+ 全部数据的一部分</span><br><span class="line">+ 主分片</span><br><span class="line">+ 决定索引保存的最大数据量</span><br><span class="line">+ 副本分片</span><br><span class="line">+ 随时可以修改</span><br><span class="line">+ 索引建立时确定主分片、副本分片数量</span><br><span class="line">+ 新增节点</span><br><span class="line">+ 自动发现、加入集群</span><br><span class="line">        + 节点相同clustre.name</span><br><span class="line">        + 配置可连接到的主机列表</span><br><span class="line">+ 水平扩容</span><br><span class="line">+ 自动迁移分片</span><br><span class="line">+ 动态扩大副本数量</span><br><span class="line">+ 提高集群搜索性能</span><br><span class="line">+ 应对故障</span><br><span class="line">+ 节点宕机</span><br><span class="line">+ 集群选主</span><br><span class="line">+ 副本分片提升为主分片</span><br><span class="line">+ 节点恢复</span><br><span class="line">+ 缺失副本分片重新分配</span><br><span class="line">+ 问题与解决</span><br><span class="line">+ 主节点</span><br><span class="line">+ 创建索引、删除索引、分配分片、追踪集群状态</span><br><span class="line">+ 负责分发和返回结果</span><br><span class="line">+ 首先成为候选主节点</span><br><span class="line">+ 候选主节点</span><br><span class="line">+ 选举其中一个作为主节点</span><br><span class="line">+ 问题</span><br><span class="line">+ master选择分歧，导致主分片、副本分歧</span><br><span class="line">+ 数据节点</span><br><span class="line">+ 负责数据存储、聚合等</span><br><span class="line">+ 集群需要设置专用候选主节点和数据节点</span><br><span class="line">+ 避免因数据节点负载重导 致主节点不响应</span><br><span class="line">+ 客户端节点</span><br><span class="line">+ 非主节点、数据节点</span><br><span class="line">+ 只负责请求的分发、汇总</span><br><span class="line">+ 为了负载均衡</span><br><span class="line">+ 脑裂问题可能的原因</span><br><span class="line">+ 网络问题</span><br><span class="line">+ 一些节点访问不到master</span><br><span class="line">+ 选举新master</span><br><span class="line">+ 节点负载</span><br><span class="line">+ 主节点既为master又为data</span><br><span class="line">+ 访问过大，es延迟响应等</span><br><span class="line">+ 其他节点选举新master</span><br><span class="line">+ 内存回收</span><br><span class="line">+ data节点占用内存较大</span><br><span class="line">+ JVM大规模内存回收</span><br><span class="line">+ es失去响应</span><br><span class="line">+ 脑裂问题解决方案</span><br><span class="line">+ 角色分离</span><br><span class="line">+ master节点与data节点分离，限制角色</span><br><span class="line">+ 减少master节点工作压力</span><br><span class="line">+ 减少误判</span><br><span class="line">+ 配置主节点响应时间延长</span><br><span class="line">+ 减少宕机误判</span><br><span class="line">+ 选举触发</span><br><span class="line">+ 设置选举触发资格</span><br><span class="line">+ 集群大于一半的节点相互连接才能进行选举</span><br><span class="line">+ 防止少部分节点失联独自选举</span><br></pre></td></tr></table></figure><h3 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h3><p>  以三台物理机为例。在这三台物理机上，搭建了 6 个 ES 的节点，三个 data 节点，三个 master 节点（每台物理机分别起了一个 data 和一个 master），3 个 master 节点，目的是达到（n/2） +1 等于 2 的要求，这样挂掉一台 master 后（不考虑 data），n 等于 2，满足参数，其他两个 master 节点都认为 master 挂掉之后开始重新选举</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310232611812.png" alt="image-20220310232611812"></p><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">1、防止 JVM 报错</span><br><span class="line">echo vm.max_map_count=262144 &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line">2、准备docker网络（创建自己的 bridge 网络）</span><br><span class="line">docker network create --driver bridge --subnet=172.18.12.0/16 --gateway=172.18.1.1 mynet</span><br><span class="line">3、master*3节点创建</span><br><span class="line">for port in $(seq 1 3); \ </span><br><span class="line">do \ </span><br><span class="line">mkdir -p /mydata/elasticsearch/master-$&#123;port&#125;/config </span><br><span class="line">mkdir -p /mydata/elasticsearch/master-$&#123;port&#125;/data </span><br><span class="line">chmod -R 777 /mydata/elasticsearch/master-$&#123;port&#125; </span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/elasticsearch/master-$&#123;port&#125;/config/elasticsearch.yml </span><br><span class="line">cluster.name: my-es #集群的名称，同一个集群该值必须设置成相同的 </span><br><span class="line">node.name: es-master-$&#123;port&#125; #该节点的名字 </span><br><span class="line">node.master: true #该节点有机会成为 master 节点 </span><br><span class="line">node.data: false #该节点可以存储数据 </span><br><span class="line">network.host: 0.0.0.0 </span><br><span class="line">http.host: 0.0.0.0 #所有 http 均可访问 </span><br><span class="line">http.port: 920$&#123;port&#125; </span><br><span class="line">transport.tcp.port: 930$&#123;port&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.minimum_master_nodes: 2 <span class="comment">#设置这个参数来保证集群中的节点可以知道其</span></span> </span><br><span class="line">它 N 个有 master 资格的节点。官方推荐（N/2）+1 </span><br><span class="line">discovery.zen.ping_timeout: 10s #设置集群中自动发现其他节点时 ping 连接的超时时间 </span><br><span class="line">discovery.seed_hosts: [&quot;172.18.12.21:9301&quot;, &quot;172.18.12.22:9302&quot;, &quot;172.18.12.23:9303&quot;] #设置集 </span><br><span class="line">群中的 Master 节点的初始列表，可以通过这些节点来自动发现其他新加入集群的节点，es7 </span><br><span class="line">的新增配置 </span><br><span class="line">cluster.initial_master_nodes: [&quot;172.18.12.21&quot;] #新集群初始时的候选主节点，es7 的新增配置 </span><br><span class="line">EOF </span><br><span class="line">docker run --name elasticsearch-node-$&#123;port&#125; \ </span><br><span class="line">-p 920$&#123;port&#125;:920$&#123;port&#125; -p 930$&#123;port&#125;:930$&#123;port&#125; \ </span><br><span class="line">--network=mynet --ip 172.18.12.2$&#123;port&#125; \-e ES_JAVA_OPTS=&quot;-Xms300m -Xmx300m&quot; \ </span><br><span class="line">-v</span><br><span class="line"><span class="meta">/mydata/elasticsearch/master-$</span><span class="bash">&#123;port&#125;/config/elasticsearch.yml:/usr/share/elasticsearch/config/el</span> </span><br><span class="line">asticsearch.yml \ </span><br><span class="line">-v /mydata/elasticsearch/master-$&#123;port&#125;/data:/usr/share/elasticsearch/data \ </span><br><span class="line">-v /mydata/elasticsearch/master-$&#123;port&#125;/plugins:/usr/share/elasticsearch/plugins \ </span><br><span class="line">-d elasticsearch:7.4.2 </span><br><span class="line">done </span><br><span class="line">4、data-node*3节点创建</span><br><span class="line">for port in $(seq 4 6); \ </span><br><span class="line">do \ </span><br><span class="line">mkdir -p /mydata/elasticsearch/node-$&#123;port&#125;/config </span><br><span class="line">mkdir -p /mydata/elasticsearch/node-$&#123;port&#125;/data </span><br><span class="line">chmod -R 777 /mydata/elasticsearch/node-$&#123;port&#125; </span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/elasticsearch/node-$&#123;port&#125;/config/elasticsearch.yml </span><br><span class="line">cluster.name: my-es #集群的名称，同一个集群该值必须设置成相同的 </span><br><span class="line">node.name: es-node-$&#123;port&#125; #该节点的名字 </span><br><span class="line">node.master: false #该节点有机会成为 master 节点 </span><br><span class="line">node.data: true #该节点可以存储数据 </span><br><span class="line">network.host: 0.0.0.0 </span><br><span class="line"><span class="meta">#</span><span class="bash">network.publish_host: 192.168.56.10 <span class="comment">#互相通信 ip，要设置为本机可被外界访问的 ip，否则</span></span> </span><br><span class="line">无法通信 </span><br><span class="line">http.host: 0.0.0.0 #所有 http 均可访问 </span><br><span class="line">http.port: 920$&#123;port&#125; </span><br><span class="line">transport.tcp.port: 930$&#123;port&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.minimum_master_nodes: 2 <span class="comment">#设置这个参数来保证集群中的节点可以知道其</span></span> </span><br><span class="line">它 N 个有 master 资格的节点。官方推荐（N/2）+1 </span><br><span class="line">discovery.zen.ping_timeout: 10s #设置集群中自动发现其他节点时 ping 连接的超时时间 </span><br><span class="line">discovery.seed_hosts: [&quot;172.18.12.21:9301&quot;, &quot;172.18.12.22:9302&quot;, &quot;172.18.12.23:9303&quot;] #设置集 </span><br><span class="line">群中的 Master 节点的初始列表，可以通过这些节点来自动发现其他新加入集群的节点，es7 </span><br><span class="line">的新增配置 </span><br><span class="line">cluster.initial_master_nodes: [&quot;172.18.12.21&quot;] #新集群初始时的候选主节点，es7 的新增配置 </span><br><span class="line">EOF </span><br><span class="line">docker run --name elasticsearch-node-$&#123;port&#125; \ </span><br><span class="line">-p 920$&#123;port&#125;:920$&#123;port&#125; -p 930$&#123;port&#125;:930$&#123;port&#125; \ </span><br><span class="line">--network=mynet --ip 172.18.12.2$&#123;port&#125; \ </span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms300m -Xmx300m&quot; \ </span><br><span class="line"><span class="meta">-v/mydata/elasticsearch/node-$</span><span class="bash">&#123;port&#125;/config/elasticsearch.yml:/usr/share/elasticsearch/config/ela</span> </span><br><span class="line">sticsearch.yml \ </span><br><span class="line">-v /mydata/elasticsearch/node-$&#123;port&#125;/data:/usr/share/elasticsearch/data \ </span><br><span class="line">-v /mydata/elasticsearch/node-$&#123;port&#125;/plugins:/usr/share/elasticsearch/plugins \ </span><br><span class="line">-d elasticsearch:7.4.2 </span><br><span class="line">done </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310234921706.png" alt="image-20220310234921706"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310234912741.png" alt="image-20220310234912741"></p><h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><p>RabbiMQ 是用 Erlang 开发的，集群非常方便，因为 Erlang 天生就是一门分布式语言，但其本身并不支持负载均衡。 </p><p>RabbitMQ 集群中节点包括**内存节点(RAM)<strong>、</strong>磁盘节点(Disk，消息持久化)**，集群中至少有 一个 Disk 节点。</p><h3 id="集群原理-1"><a href="#集群原理-1" class="headerlink" title="集群原理"></a>集群原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ 集群形式</span><br><span class="line">+ 普通模式</span><br><span class="line">+ 集群特点</span><br><span class="line">            + 各节点相同队列结构</span><br><span class="line">            + 消息只存在于一个节点</span><br><span class="line">            + 消费者消费，需要通过节点直接转发</span><br><span class="line">+ 应用场景</span><br><span class="line">+ 适合消息无需持久化场景，日志队列等</span><br><span class="line">+ 宕机时可直接连接其他节点，只需重新创建队列</span><br><span class="line">+ 镜像模式</span><br><span class="line">+ 集群特点</span><br><span class="line">            + 消息实体会主动在镜像节点间同步（消息到队列时）</span><br><span class="line">            + mirror queue选举算法</span><br><span class="line">                + 1个master，n个slaver</span><br><span class="line">                + 生产者、消费者请求转至master</span><br><span class="line">+ 镜像集群基于普通集群</span><br><span class="line">+ 先搭建普通集群，再设置镜像队列</span><br><span class="line">+ 缺点</span><br><span class="line">+ 镜像队列过多，且消息体量大</span><br><span class="line">+ 集群内部网络带宽将会被此种同步通讯所消耗</span><br><span class="line">+ 应用场景</span><br><span class="line">+ 可靠性要求较高场合，如下单、库存队列</span><br><span class="line">        + 若消费过程中，master 挂掉，则选举新 master</span><br><span class="line">           + 若未来得及确认，则可能会重复消费</span><br></pre></td></tr></table></figure><h3 id="集群搭建-1"><a href="#集群搭建-1" class="headerlink" title="集群搭建"></a>集群搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、启动容器</span><br><span class="line">mkdir /mydata/rabbitmq </span><br><span class="line">cd rabbitmq/ </span><br><span class="line">mkdir rabbitmq01 rabbitmq02 rabbitmq03</span><br><span class="line">docker run -d --hostname rabbitmq01 --name rabbitmq01 -v /mydata/rabbitmq/rabbitmq01:/var/lib/rabbitmq -p 15673:15672 -p 5673:5672 -e RABBITMQ_ERLANG_COOKIE=&#x27;atguigu&#x27; rabbitmq:management</span><br><span class="line">docker run -d --hostname rabbitmq02 --name rabbitmq02 -v</span><br><span class="line">/mydata/rabbitmq/rabbitmq02:/var/lib/rabbitmq -p 15674:15672 -p 5674:5672 -e RABBITMQ_ERLANG_COOKIE=&#x27;atguigu&#x27; --link rabbitmq01:rabbitmq01 rabbitmq:management</span><br><span class="line">docker run -d --hostname rabbitmq03 --name rabbitmq03 -v /mydata/rabbitmq/rabbitmq03:/var/lib/rabbitmq -p 15675:15672 -p 5675:5672 -e RABBITMQ_ERLANG_COOKIE=&#x27;atguigu&#x27; --link rabbitmq01:rabbitmq01 --link rabbitmq02:rabbitmq02 rabbitmq:management</span><br><span class="line">--hostname 设置容器的主机名 </span><br><span class="line">RABBITMQ_ERLANG_COOKIE 节点认证作用，部署集成时 需要同步该值</span><br><span class="line">2、节点加入集群</span><br><span class="line">docker exec -it rabbitmq01 /bin/bash </span><br><span class="line">rabbitmqctl stop_app </span><br><span class="line">rabbitmqctl reset </span><br><span class="line">rabbitmqctl start_app </span><br><span class="line">进入第二个节点 </span><br><span class="line">docker exec -it rabbitmq02 /bin/bash rabbitmqctl stop_app rabbitmqctl reset rabbitmqctl join_cluster --ram rabbit@rabbitmq01 rabbitmqctl start_app exit </span><br><span class="line">进入第三个节点 docker exec -it rabbitmq03 bash rabbitmqctl stop_app rabbitmqctl reset rabbitmqctl join_cluster --ram rabbit@rabbitmq01 rabbitmqctl start_app exit</span><br><span class="line">3、实现镜像集群</span><br><span class="line">docker exec -it rabbitmq01 bash</span><br><span class="line">rabbitmqctl set_policy -p / ha &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27; </span><br><span class="line">可以使用 rabbitmqctl list_policies -p /；查看 vhost/下面的所有 policy</span><br><span class="line">在 cluster 中任意节点启用策略，策略会自动同步到集群节点</span><br><span class="line">rabbitmqctl set_policy-p/ha-all&quot;^&quot;’&#123;“ha-mode”:“all”&#125;’</span><br><span class="line">策略模式 all 即复制到所有节点，包含新增节点，策略正则表达式为 “^” 表示所有匹配所有队列名称。“^hello”表示只匹配名为 hello 开始的队列</span><br></pre></td></tr></table></figure><p>改为镜像集群：同步</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310234800034.png" alt="image-20220310234800034"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——云原生核心-Kubernetes</title>
      <link href="/2022/03/06/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A0%B8%E5%BF%83-Kubernetes/"/>
      <url>/2022/03/06/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A0%B8%E5%BF%83-Kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker只是解决服务下层的问题，服务上层建筑如容器编排，服务发现等问题已经超越了Docker的管辖。</p><p>Kubernetes提供的编排和管理功能，轻松完成大规模容器部署，借助k8s的编排功能，用户可以构建跨多个容器的应用服务，实现跨集群调度，扩展容器，以及长期持续管理这些容器的健康状况等，并整合网络，存储，安全性，监控及其他服务，提供全面的容器基础架构。</p><p>Kubernetes 满足了一系列产品内运行程序的普通需求，兼具平台即服务（PaaS）的简化和基础架构即服务（IaaS）的灵活，并促进了在平台服务提供商之间的迁移。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225820940.png" alt="image-20220306225820940"></p><p><strong>微服务</strong><br>微服务解决的是我们软件开发中一直追求的低耦合+高内聚，微服务可以解决这个问题，微服务的本质是把一块大饼分成若干块低耦合的小饼，比如一块小饼专门负责接收外部的数据，一块小饼专门负责响应前台的操作，小饼可以进一步拆分，比如负责接收外部数据的小饼可以继续分成多块负责接收不同类型数据的小饼，这样每个小饼出问题了，其它小饼还能正常对外提供服务。</p><p><strong>DevOps</strong><br>DevOps的意思就是开发和运维不再是分开的两个团队，而是你中有我，我中有你的一个团队。我们现在开发和运维已经是一个团队了，但是运维方面的知识和经验还需要持续提高。</p><p><strong>持续交付</strong><br>持续交付的意思就是在不影响用户使用服务的前提下频繁把新功能发布给用户使用，要做到这点非常非常难。我们现在两周一个版本，每次上线之后都会给不同的用户造成不同程度的影响。</p><p><strong>容器化</strong><br>容器化的好处在于运维的时候不需要再关心每个服务所使用的技术栈了，每个服务都被无差别地封装在容器里，可以被无差别地管理和维护，现在比较流行的工具是docker和k8s。</p><p>简单地把云原生理解为：云原生 = 微服务 + DevOps + 持续交付 + 容器化</p><p>k8s官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>整体主从方式</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230018184.png" alt="image-20220306230018184"></p><ul><li><p>组件</p><ul><li><p>master</p><ul><li>kube-apiserver<ul><li>外界进行资源操作的入口</li><li>认证、授权、访问控制、api注册、发现</li></ul></li><li>etcd<ul><li>nosql数据库</li><li>集群数据</li></ul></li><li>kube-schedule<ul><li>从etcd中获取任务进行调度，选择节点运行</li><li>所有对k8s集群的操作，都必须经过主节点</li></ul></li><li>kube-controller-manager<ul><li>node controller（节点控制器）<ul><li>在节点出现故障时进行通知和响应</li></ul></li><li>replication controller（副本控制器）<ul><li>部署</li></ul></li><li>endpoints controller（端点控制器）<ul><li>暴露端口之类的</li></ul></li><li>service account &amp; token controllers<ul><li>控制安全</li></ul></li></ul></li></ul></li><li><p>node</p><ul><li>container runtime<ul><li>容器运行环境，如docker</li></ul></li><li>kubelet<ul><li>每个节点的代理，保证容器都运行在Pod中<ul><li>pod：一组容器，最小部署单元</li></ul></li><li>维护容器的生命周期，数据卷、网络</li></ul></li><li>kube-proxy<ul><li>每个节点的网络代理，帮助请求路由和访问具体容器</li></ul></li><li>fluentd<ul><li>节点日志收集</li></ul></li></ul></li></ul></li></ul><p>master</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230319472.png" alt="image-20220306230319472"></p><p>node</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230348661.png" alt="image-20220306230348661"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230401741.png" alt="image-20220306230401741"></p><ul><li><p>Container：容器，可以是 docker 启动的一个容器 </p></li><li><p>Pod： </p><ul><li>k8s 使用 Pod 来组织一组容器 </li><li>一个 Pod 中的所有容器共享同一网络。 </li><li>Pod 是 k8s 中的最小部署单元 </li></ul></li><li><p>Volume </p><ul><li>声明在 Pod 容器中可访问的文件目录 </li><li>可以被挂载在 Pod 中一个或多个容器指定路径下 </li><li>支持多种后端存储抽象(本地存储，分布式存储，云存储…) </li></ul></li><li><p>Controllers：更高层次对象，部署和管理 Pod；</p><ul><li>ReplicaSet：确保预期的 Pod 副本数量 </li><li>Deplotment：无状态应用部署 </li><li>StatefulSet：有状态应用部署 </li><li>DaemonSet：确保所有 Node 都运行一个指定 Pod </li><li>Job：一次性任务 </li><li>Cronjob：定时任务 </li></ul></li><li><p>Deployment： </p><ul><li>定义一组 Pod 的副本数目、版本等 </li><li>通过控制器（Controller）维持 Pod 数目(自动回复失败的 Pod) </li><li>通过控制器以指定的策略控制版本（滚动升级，回滚等） </li></ul></li><li><p>Service </p><ul><li>定义一组 Pod 的访问策略 </li><li>Pod 的负载均衡，提供一个或者多个 Pod 的稳定访问地址 </li><li>支持多种方式（ClusterIP、NodePort、LoadBalance） </li></ul></li><li><p>Label：标签，用于对象资源的查询，筛选 </p></li><li><p>Namespace：命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制（鉴权，资源） </li><li>每个资源都属于一个 namespace </li><li>同一个 namespace 所有资源名不能重复 </li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230837907.png" alt="image-20220306230837907"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 流程</span><br><span class="line">    + kubectl——apiserver——etcd</span><br><span class="line">    + controller manager——监听——apiserver</span><br><span class="line">    + 发现pod未创建</span><br><span class="line">    + 根据pod模板生成pod对象，apiserver——etcd</span><br><span class="line">    + scheduler——监听——选定node，apiserver——etcd</span><br><span class="line">    + kubelet——监听——启动pod</span><br></pre></td></tr></table></figure><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>调度</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225909169.png" alt="image-20220306225909169"></p><p>自动恢复</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225921697.png" alt="image-20220306225921697"></p><p>水平伸缩</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225940799.png" alt="image-20220306225940799"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231026852.png" alt="image-20220306231026852"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231116495.png" alt="image-20220306231116495"></p><p>1、设置 linux 环境</p><p>2、所有节点安装 Docker、kubeadm、kubelet、kubectl</p><p>3、安装 Pod 网络插件（CNI）</p><p>4、加入 Kubernetes Node </p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231924323.png" alt="image-20220306231924323"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>pod、controller</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232549267.png" alt="image-20220306232549267"></p><p>deployment、service</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232559381.png" alt="image-20220306232559381"></p><p>labels、selectors</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232631265.png" alt="image-20220306232631265"></p><p>ingress</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232639695.png" alt="image-20220306232639695"></p><p>ingress——&gt;service——&gt;pod——&gt;container</p><p>网络模型</p><p>Kubernetes的网络模型从内至外由四个部分组成：</p><p>1、Pod内部容器所在的网络 </p><p>2、Pod所在的网络 </p><p>3、Pod和Service之间通信的网络</p><p>4、外界与Service之间通信的网络</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232717133.png" alt="image-20220306232717133"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——高并发（秒杀）系统&amp;Sentinel&amp;链路追踪</title>
      <link href="/2022/03/04/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E7%A7%92%E6%9D%80%EF%BC%89%E7%B3%BB%E7%BB%9F&amp;Sentinel&amp;%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
      <url>/2022/03/04/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E7%A7%92%E6%9D%80%EF%BC%89%E7%B3%BB%E7%BB%9F&amp;Sentinel&amp;%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="1、秒杀业务"><a href="#1、秒杀业务" class="headerlink" title="1、秒杀业务"></a>1、秒杀业务</h1><p>秒杀具有瞬间高并发的特点，针对这一特点，必须要做限流 + 异步 + 缓存（页面静态化）+ 独立部署。 </p><h2 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304221850788.png" alt="image-20220304221850788"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304221910750.png" alt="image-20220304221910750"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ 秒杀（高并发）系统关注的问题</span><br><span class="line">    + 独立部署</span><br><span class="line">    + 防止影响其他服务</span><br><span class="line">    + 链接加密</span><br><span class="line">    + 防止请求暴露，恶意攻击</span><br><span class="line">    + 库存预热</span><br><span class="line">        + redis信号量</span><br><span class="line">        + redis高可用</span><br><span class="line">    + 动静分离</span><br><span class="line">        + nginx</span><br><span class="line">        + cdn</span><br><span class="line">    + 恶意请求拦截</span><br><span class="line">    + 网关层</span><br><span class="line">    + 流量错峰</span><br><span class="line">        + 小米：验证码</span><br><span class="line">        + 验证正常请求</span><br><span class="line">    + 流量错峰</span><br><span class="line">   + 加入购物车</span><br><span class="line">    + 结算时间不同，流量错峰</span><br><span class="line">    + 限流&amp;熔断&amp;降级</span><br><span class="line">        + 限流</span><br><span class="line">            + 前端限流</span><br><span class="line">            + 点击次数、间隔限制</span><br><span class="line">            + 后端限流</span><br><span class="line">                + 筛选非用户行为</span><br><span class="line">                + 限制请求次数、总量            </span><br><span class="line">            + nginx限流</span><br><span class="line">            + 直接负载部分请求到错误的静态页面</span><br><span class="line">            + 令牌算法 漏斗算法</span><br><span class="line">            + 网关限流</span><br><span class="line">            + 限流的过滤器</span><br><span class="line">        + 熔断、降级</span><br><span class="line">            + 调用链路异常，快速失败熔断</span><br><span class="line">            + 流量太大，引导部分请求降级</span><br><span class="line">    + 队列削峰（杀手锏）</span><br><span class="line">        + 抢到信号量的放行后台</span><br><span class="line">        + 后台发送消息到队列，返回秒杀成功回调</span><br><span class="line">        + 订单服务等监听队列，慢慢创建订单处理成功秒杀的消息</span><br></pre></td></tr></table></figure><h2 id="秒杀商品上架（定时、异步、幂等性）、展示、渲染"><a href="#秒杀商品上架（定时、异步、幂等性）、展示、渲染" class="headerlink" title="秒杀商品上架（定时、异步、幂等性）、展示、渲染"></a>秒杀商品上架（定时、异步、幂等性）、展示、渲染</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304222418396.png" alt="image-20220304222418396"></p><p>定时任务&amp;异步任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ 开启定时任务@EnableScheduling</span><br><span class="line">+ 定时方法注解@Scheduled</span><br><span class="line">+ spring中区别</span><br><span class="line">        + cron语法</span><br><span class="line">        + 默认阻塞</span><br><span class="line">+ 解决阻塞</span><br><span class="line">        + 异步编排运行，自己提交到线程池</span><br><span class="line">        + 支持定时任务线程池（线程池默认大小为一）</span><br><span class="line">            + 配置文件设置线程池大小</span><br><span class="line">            + 不太好使</span><br><span class="line">        + 让定时任务异步执行（异步任务）</span><br><span class="line"></span><br><span class="line">+ 异步任务</span><br><span class="line">    + 开启异步任务@EnableAsync</span><br><span class="line">    + 异步方法注解@Async</span><br><span class="line">        + 默认使用线程池，大小为8</span><br><span class="line">        + 可配置线程池属性</span><br><span class="line"></span><br><span class="line">+ 在Spring中表达式是6位组成，不允许第七位的年份</span><br><span class="line">+ 在周几的的位置,1-7代表周一到周日</span><br><span class="line">+ 定时任务不该阻塞。默认是阻塞的</span><br><span class="line">+ 可以让业务以异步的方式，自己提交到线程池</span><br><span class="line">+ CompletableFuture.runAsync(() -&gt; &#123;&#125;,execute);</span><br><span class="line">+ 支持定时任务线程池；设置 TaskSchedulingProperties</span><br><span class="line">+ spring.task.scheduling.pool.size: 5</span><br><span class="line">+ 让定时任务异步执行</span><br><span class="line">+ 异步任务</span><br><span class="line">+ 解决：使用异步任务 + 定时任务来完成定时任务不阻塞的功能</span><br></pre></td></tr></table></figure><p>上架商品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 上架service</span><br><span class="line">    + 远程调用优惠系统，扫描最近三天需要秒杀的商品</span><br><span class="line">    + 查询最近三天秒杀活动</span><br><span class="line">    + 得到最近三天格式化日期 </span><br><span class="line">+ 查询起始时间between起始和结束之间的活动</span><br><span class="line">+ 遍历每一个活动，查询关联商品list</span><br><span class="line">+ 根据活动id查询关联表</span><br><span class="line">    + 封装返回数据Vo</span><br><span class="line">    + 上架商品</span><br><span class="line">+ 缓存到reids</span><br><span class="line">            + 缓存活动信息</span><br><span class="line">                + 遍历活动，获取开始结束时间作为key</span><br><span class="line">                + 收集活动所有商品id list作为value</span><br><span class="line">            + 缓存活动的关联商品信息</span><br><span class="line">                + 准备hash操作</span><br><span class="line">                + 遍历每个商品，商品skuid作为key</span><br><span class="line">                + 商品To（sku秒杀信息、详细信息、随机码、开始结束时间）作为value（转为json）</span><br><span class="line">                + 远程调用商品服务（查询详细信息）</span><br><span class="line">+ 根据sku id查询商品详细信息</span><br><span class="line">                    + 随机码（UUID）</span><br><span class="line">                    + 防止提前脚本发请求秒杀</span><br><span class="line">                    + 秒杀开始才暴露</span><br><span class="line">+ 秒杀商品设置分布式信号量（限流），作为库存扣减信息</span><br><span class="line">                    + 引入redisson</span><br><span class="line">                    + 配置redisson客户端</span><br><span class="line">                    + key：商品随机码</span><br><span class="line">                    + value：商品秒杀数量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304223213629.png" alt="image-20220304223213629"></p><p>幂等性保证</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304223954144.png" alt="image-20220304223954144"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 加入分布式锁</span><br><span class="line">    + 防止多台机器同一时间上架</span><br><span class="line">    + 同时判断key不存在，导致同时追加，所以必须有锁</span><br><span class="line">+ 幂等性保证</span><br><span class="line">    + 缓存活动信息，判断key sessionid是否存在</span><br><span class="line">    + 缓存sku信息，key：场次 + 商品id，判断key sessionid_skuid是否存在</span><br><span class="line">    + 解决多场次同一商品问题</span><br><span class="line">    + 缓存信号量，跟商品是否上架一起执行</span><br></pre></td></tr></table></figure><p>查询秒杀商品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 展示首页秒杀商品</span><br><span class="line">    + controller：判断符合当前时间秒杀场次的商品（获取当前时间可以参与的秒杀商品信息）</span><br><span class="line">        + 确定当前时间属于哪个秒杀场次</span><br><span class="line">        + 遍历所有keys，截取字符串，判断时间</span><br><span class="line">        + 获取秒杀场次的所有商品信息</span><br><span class="line">            + 获取场次所有商品id</span><br><span class="line">            + 根据id获取hash中的商品详情</span><br><span class="line">            + 封装Vo</span><br></pre></td></tr></table></figure><p>秒杀页面渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 秒杀预告</span><br><span class="line">+ 商品页面，查询当前sku是否参与秒杀优惠</span><br><span class="line">    + 远程调用秒杀服务，根据skuid 查询redis商品详情hash</span><br><span class="line">        + 找到所有秒杀商品的key</span><br><span class="line">        + 遍历key正则匹配，找到商品</span><br><span class="line">    + 判断秒杀是否开始，未开始则不暴露随机码</span><br><span class="line">    + feign调用、封装</span><br><span class="line">    + 异步编排</span><br><span class="line">+ 前端取值，格式化日期，三个时间区间判断</span><br><span class="line">        + 未到</span><br><span class="line">        + 正在秒杀</span><br><span class="line">        + 已过，不显示</span><br><span class="line">+ 首页跳转</span><br></pre></td></tr></table></figure><h2 id="秒杀业务（登录检查、）"><a href="#秒杀业务（登录检查、）" class="headerlink" title="秒杀业务（登录检查、）"></a>秒杀业务（登录检查、）</h2><p>登录检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 处于秒杀阶段商品，加入购物车改为立即抢购</span><br><span class="line">+ 秒杀前端跳转请求</span><br><span class="line">    + 登录判断</span><br><span class="line">    + 参数</span><br><span class="line">        + 场次_商品id</span><br><span class="line">        + 随机码（令牌）</span><br><span class="line">        + 件数</span><br><span class="line">+ 处理秒杀请求</span><br><span class="line">    + controller</span><br><span class="line">        + 登录拦截</span><br><span class="line">        + 引入spring-session</span><br><span class="line">                + 序列化器等配置</span><br><span class="line">                + 存储类型为redis</span><br><span class="line">            + 引入登录拦截器</span><br><span class="line">            + 注册拦截器</span><br></pre></td></tr></table></figure><p><strong>秒杀流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一套流程：</span><br><span class="line">+ 购物车——订单确认页——提交订单结算</span><br><span class="line">+ 多个服务都收到高并发流量</span><br><span class="line">+ 同时也错峰了一部分流量</span><br><span class="line">+ 融合和兼容秒杀购买与正常购买流程</span><br><span class="line"></span><br><span class="line">第二套流程：</span><br><span class="line">+ 点击秒杀，合法校验通过直接获取信号量</span><br><span class="line">+ 发送消息给MQ，直接返回秒杀成功</span><br><span class="line">+ 订单等其他服务慢慢处理MQ请求</span><br><span class="line">+ 订单创建完成，用户确认结算即可</span><br><span class="line">+ 优点</span><br><span class="line">    + 流程快速，除了创建订单无需操作数据库、远程调用等</span><br><span class="line">    + 订单服务需要高可用</span><br><span class="line">    + 整个业务独立</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304224859675.png" alt="image-20220304224859675"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponFeignService couponFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductFeignService productFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SESSION__CACHE_PREFIX = <span class="string">&quot;seckill:sessions:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SECKILL_CHARE_PREFIX = <span class="string">&quot;seckill:skus&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SKU_STOCK_SEMAPHORE = <span class="string">&quot;seckill:stock:&quot;</span>;    <span class="comment">//+商品随机码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadSeckillSkuLatest3Days</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、扫描最近三天的商品需要参加秒杀的活动</span></span><br><span class="line">        R lates3DaySession = couponFeignService.getLates3DaySession();</span><br><span class="line">        <span class="keyword">if</span> (lates3DaySession.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//上架商品</span></span><br><span class="line">            List&lt;SeckillSessionWithSkusVo&gt; sessionData = lates3DaySession.getData(<span class="string">&quot;data&quot;</span>, <span class="keyword">new</span> TypeReference&lt;List&lt;SeckillSessionWithSkusVo&gt;&gt;() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//缓存到Redis</span></span><br><span class="line">            <span class="comment">//1、缓存活动信息</span></span><br><span class="line">            saveSessionInfos(sessionData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、缓存活动的关联商品信息</span></span><br><span class="line">            saveSessionSkuInfo(sessionData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存秒杀活动信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveSessionInfos</span><span class="params">(List&lt;SeckillSessionWithSkusVo&gt; sessions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sessions.stream().forEach(session -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前活动的开始和结束时间的时间戳</span></span><br><span class="line">            <span class="keyword">long</span> startTime = session.getStartTime().getTime();</span><br><span class="line">            <span class="keyword">long</span> endTime = session.getEndTime().getTime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存入到Redis中的key</span></span><br><span class="line">            String key = SESSION__CACHE_PREFIX + startTime + <span class="string">&quot;_&quot;</span> + endTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断Redis中是否有该信息，如果没有才进行添加</span></span><br><span class="line">            Boolean hasKey = redisTemplate.hasKey(key);</span><br><span class="line">            <span class="comment">//缓存活动信息</span></span><br><span class="line">            <span class="keyword">if</span> (!hasKey) &#123;</span><br><span class="line">                <span class="comment">//获取到活动中所有商品的skuId</span></span><br><span class="line">                List&lt;String&gt; skuIds = session.getRelationSkus().stream()</span><br><span class="line">                        .map(item -&gt; item.getPromotionSessionId() + <span class="string">&quot;-&quot;</span> + item.getSkuId().toString()).collect(Collectors.toList());</span><br><span class="line">                redisTemplate.opsForList().leftPushAll(key,skuIds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存秒杀活动所关联的商品信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveSessionSkuInfo</span><span class="params">(List&lt;SeckillSessionWithSkusVo&gt; sessions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sessions.stream().forEach(session -&gt; &#123;</span><br><span class="line">            <span class="comment">//准备hash操作，绑定hash</span></span><br><span class="line">            BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">            session.getRelationSkus().stream().forEach(seckillSkuVo -&gt; &#123;</span><br><span class="line">                <span class="comment">//生成随机码</span></span><br><span class="line">                String token = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                String redisKey = seckillSkuVo.getPromotionSessionId().toString() + <span class="string">&quot;-&quot;</span> + seckillSkuVo.getSkuId().toString();</span><br><span class="line">                <span class="keyword">if</span> (!operations.hasKey(redisKey)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//缓存我们商品信息</span></span><br><span class="line">                    SeckillSkuRedisTo redisTo = <span class="keyword">new</span> SeckillSkuRedisTo();</span><br><span class="line">                    Long skuId = seckillSkuVo.getSkuId();</span><br><span class="line">                    <span class="comment">//1、先查询sku的基本信息，调用远程服务</span></span><br><span class="line">                    R info = productFeignService.getSkuInfo(skuId);</span><br><span class="line">                    <span class="keyword">if</span> (info.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">                        SkuInfoVo skuInfo = info.getData(<span class="string">&quot;skuInfo&quot;</span>,<span class="keyword">new</span> TypeReference&lt;SkuInfoVo&gt;()&#123;&#125;);</span><br><span class="line">                        redisTo.setSkuInfo(skuInfo);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2、sku的秒杀信息</span></span><br><span class="line">                    BeanUtils.copyProperties(seckillSkuVo,redisTo);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3、设置当前商品的秒杀时间信息</span></span><br><span class="line">                    redisTo.setStartTime(session.getStartTime().getTime());</span><br><span class="line">                    redisTo.setEndTime(session.getEndTime().getTime());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//4、设置商品的随机码（防止恶意攻击）</span></span><br><span class="line">                    redisTo.setRandomCode(token);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//序列化json格式存入Redis中</span></span><br><span class="line">                    String seckillValue = JSON.toJSONString(redisTo);</span><br><span class="line">                    operations.put(seckillSkuVo.getPromotionSessionId().toString() + <span class="string">&quot;-&quot;</span> + seckillSkuVo.getSkuId().toString(),seckillValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果当前这个场次的商品库存信息已经上架就不需要上架</span></span><br><span class="line">                    <span class="comment">//5、使用库存作为分布式Redisson信号量（限流）</span></span><br><span class="line">                    <span class="comment">// 使用库存作为分布式信号量</span></span><br><span class="line">                    RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);</span><br><span class="line">                    <span class="comment">// 商品可以秒杀的数量作为信号量</span></span><br><span class="line">                    semaphore.trySetPermits(seckillSkuVo.getSeckillCount());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到当前可以参加秒杀商品的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;getCurrentSeckillSkusResource&quot;,blockHandler = &quot;blockHandler&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SeckillSkuRedisTo&gt; <span class="title">getCurrentSeckillSkus</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">&quot;seckillSkus&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//1、确定当前属于哪个秒杀场次</span></span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从Redis中查询到所有key以seckill:sessions开头的所有数据</span></span><br><span class="line">            Set&lt;String&gt; keys = redisTemplate.keys(SESSION__CACHE_PREFIX + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="comment">//seckill:sessions:1594396764000_1594453242000</span></span><br><span class="line">                String replace = key.replace(SESSION__CACHE_PREFIX, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                String[] s = replace.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">                <span class="comment">//获取存入Redis商品的开始时间</span></span><br><span class="line">                <span class="keyword">long</span> startTime = Long.parseLong(s[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//获取存入Redis商品的结束时间</span></span><br><span class="line">                <span class="keyword">long</span> endTime = Long.parseLong(s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断是否是当前秒杀场次</span></span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line">                    <span class="comment">//2、获取这个秒杀场次需要的所有商品信息</span></span><br><span class="line">                    List&lt;String&gt; range = redisTemplate.opsForList().range(key, -<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">                    BoundHashOperations&lt;String, String, String&gt; hasOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">                    <span class="keyword">assert</span> range != <span class="keyword">null</span>;</span><br><span class="line">                    List&lt;String&gt; listValue = hasOps.multiGet(range);</span><br><span class="line">                    <span class="keyword">if</span> (listValue != <span class="keyword">null</span> &amp;&amp; listValue.size() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        List&lt;SeckillSkuRedisTo&gt; collect = listValue.stream().map(item -&gt; &#123;</span><br><span class="line">                            String items = (String) item;</span><br><span class="line">                            SeckillSkuRedisTo redisTo = JSON.parseObject(items, SeckillSkuRedisTo.class);</span><br><span class="line">                            <span class="comment">// redisTo.setRandomCode(null);当前秒杀开始需要随机码</span></span><br><span class="line">                            <span class="keyword">return</span> redisTo;</span><br><span class="line">                        &#125;).collect(Collectors.toList());</span><br><span class="line">                        <span class="keyword">return</span> collect;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;资源被限流&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SeckillSkuRedisTo&gt; <span class="title">blockHandler</span><span class="params">(BlockException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;getCurrentSeckillSkusResource被限流了,&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据skuId查询商品是否参加秒杀活动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillSkuRedisTo <span class="title">getSkuSeckilInfo</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、找到所有需要秒杀的商品的key信息---seckill:skus</span></span><br><span class="line">        BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到所有的key</span></span><br><span class="line">        Set&lt;String&gt; keys = hashOps.keys();</span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//4-45 正则表达式进行匹配</span></span><br><span class="line">            String reg = <span class="string">&quot;\\d-&quot;</span> + skuId;</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="comment">//如果匹配上了</span></span><br><span class="line">                <span class="keyword">if</span> (Pattern.matches(reg,key)) &#123;</span><br><span class="line">                    <span class="comment">//从Redis中取出数据来</span></span><br><span class="line">                    String redisValue = hashOps.get(key);</span><br><span class="line">                    <span class="comment">//进行序列化</span></span><br><span class="line">                    SeckillSkuRedisTo redisTo = JSON.parseObject(redisValue, SeckillSkuRedisTo.class);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//随机码</span></span><br><span class="line">                    Long currentTime = System.currentTimeMillis();</span><br><span class="line">                    Long startTime = redisTo.getStartTime();</span><br><span class="line">                    Long endTime = redisTo.getEndTime();</span><br><span class="line">                    <span class="comment">//如果当前时间大于等于秒杀活动开始时间并且要小于活动结束时间</span></span><br><span class="line">                    <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line">                        <span class="keyword">return</span> redisTo;</span><br><span class="line">                    &#125;</span><br><span class="line">                    redisTo.setRandomCode(<span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">return</span> redisTo;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前商品进行秒杀（秒杀开始）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> killId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">kill</span><span class="params">(String killId, String key, Integer num)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取当前用户的信息</span></span><br><span class="line">        MemberResponseVo user = LoginUserInterceptor.loginUser.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取当前秒杀商品的详细信息从Redis中获取</span></span><br><span class="line">        BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">        String skuInfoValue = hashOps.get(killId);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(skuInfoValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(合法性效验)</span></span><br><span class="line">        SeckillSkuRedisTo redisTo = JSON.parseObject(skuInfoValue, SeckillSkuRedisTo.class);</span><br><span class="line">        Long startTime = redisTo.getStartTime();</span><br><span class="line">        Long endTime = redisTo.getEndTime();</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//判断当前这个秒杀请求是否在活动时间区间内(效验时间的合法性)</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、效验随机码和商品id</span></span><br><span class="line">            String randomCode = redisTo.getRandomCode();</span><br><span class="line">            String skuId = redisTo.getPromotionSessionId() + <span class="string">&quot;-&quot;</span> +redisTo.getSkuId();</span><br><span class="line">            <span class="keyword">if</span> (randomCode.equals(key) &amp;&amp; killId.equals(skuId)) &#123;</span><br><span class="line">                <span class="comment">//3、验证购物数量是否合理和库存量是否充足</span></span><br><span class="line">                Integer seckillLimit = redisTo.getSeckillLimit();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取信号量</span></span><br><span class="line">                String seckillCount = redisTemplate.opsForValue().get(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">                Integer count = Integer.valueOf(seckillCount);</span><br><span class="line">                <span class="comment">//判断信号量是否大于0,并且买的数量不能超过库存</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; num &lt;= seckillLimit &amp;&amp; count &gt; num ) &#123;</span><br><span class="line">                    <span class="comment">//4、验证这个人是否已经买过了（幂等性处理）,如果秒杀成功，就去占位。userId-sessionId-skuId</span></span><br><span class="line">                    <span class="comment">//SETNX 原子性处理</span></span><br><span class="line">                    String redisKey = user.getId() + <span class="string">&quot;-&quot;</span> + skuId;</span><br><span class="line">                    <span class="comment">//设置自动过期(活动结束时间-当前时间)</span></span><br><span class="line">                    Long ttl = endTime - currentTime;</span><br><span class="line">                    Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(redisKey, num.toString(), ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (aBoolean) &#123;</span><br><span class="line">                        <span class="comment">//占位成功说明从来没有买过,分布式锁(获取信号量-1)</span></span><br><span class="line">                        RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">                        <span class="comment">//TODO 秒杀成功，快速下单</span></span><br><span class="line">                        <span class="keyword">boolean</span> semaphoreCount = semaphore.tryAcquire(num, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="comment">//保证Redis中还有商品库存</span></span><br><span class="line">                        <span class="keyword">if</span> (semaphoreCount) &#123;</span><br><span class="line">                            <span class="comment">//创建订单号和订单信息发送给MQ</span></span><br><span class="line">                            <span class="comment">// 秒杀成功 快速下单 发送消息到 MQ 整个操作时间在 10ms 左右</span></span><br><span class="line">                            String timeId = IdWorker.getTimeId();</span><br><span class="line">                            SeckillOrderTo orderTo = <span class="keyword">new</span> SeckillOrderTo();</span><br><span class="line">                            orderTo.setOrderSn(timeId);</span><br><span class="line">                            orderTo.setMemberId(user.getId());</span><br><span class="line">                            orderTo.setNum(num);</span><br><span class="line">                            orderTo.setPromotionSessionId(redisTo.getPromotionSessionId());</span><br><span class="line">                            orderTo.setSkuId(redisTo.getSkuId());</span><br><span class="line">                            orderTo.setSeckillPrice(redisTo.getSeckillPrice());</span><br><span class="line">                            rabbitTemplate.convertAndSend(<span class="string">&quot;order-event-exchange&quot;</span>,<span class="string">&quot;order.seckill.order&quot;</span>,orderTo);</span><br><span class="line">                            <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">                            log.info(<span class="string">&quot;耗时...&quot;</span> + (s2 - s1));</span><br><span class="line">                            <span class="keyword">return</span> timeId;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> s3 = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗时...&quot;</span> + (s3 - s1));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ Service kill</span><br><span class="line">    + 登录判断 √</span><br><span class="line">    + 合法性校验</span><br><span class="line">        + 获取当前秒杀商品的详细信息</span><br><span class="line">        + redis根据killid 获取sku信息</span><br><span class="line">        + json转为To数据</span><br><span class="line">        + 判断当前时间是否为秒杀时间</span><br><span class="line">        + 比较开始结束时间</span><br><span class="line">        + 判断随机码是否正确</span><br><span class="line">        + 判断购物数量是否合适</span><br><span class="line">    + 判断是否重复秒杀（幂等性）</span><br><span class="line">    + 到redis站位，setnx</span><br><span class="line">            + 指定key：userid_sessionid_skuid</span><br><span class="line">            + 拦截器获取user信息</span><br><span class="line">            + 设置自动过期时间（当前场次结束时间）</span><br><span class="line">            + 结束时间减去当前时间作为ttl</span><br><span class="line">            + 站位成功则说明未秒杀</span><br><span class="line">    + 获取分布式信号量</span><br><span class="line">    + 根据购买件数扣减信号量</span><br><span class="line">    + 调用tryAcquire（尝试性获取，非阻塞）</span><br><span class="line">    //+ 100毫秒尝试时间</span><br><span class="line">    + 无需等待</span><br><span class="line">    + 拿到信号量则成功秒杀</span><br><span class="line">    + 快速下单</span><br><span class="line">        + 创建订单号</span><br><span class="line">        + 发送消息给mq</span><br><span class="line">            + 引入rabbitmq</span><br><span class="line">            + 序列化、可靠消息等配置</span><br><span class="line">+ 秒杀订单To</span><br><span class="line">+ 发送消息</span><br><span class="line">    + 直接返回订单号</span><br><span class="line">    + 订单服务</span><br><span class="line">+ 队列、binding</span><br><span class="line">+ 监听秒杀队列</span><br><span class="line">+ 创建秒杀单，保存订单信息</span><br><span class="line">            + 保存订单项信息（订单关联sku表）</span><br><span class="line">            + TODO 其他</span><br></pre></td></tr></table></figure><h1 id="2、Sentinel、Sleuth-Zipkin"><a href="#2、Sentinel、Sleuth-Zipkin" class="headerlink" title="2、Sentinel、Sleuth + Zipkin"></a>2、Sentinel、Sleuth + Zipkin</h1><h2 id="Sentinel：流控、熔断降级、系统负载保护"><a href="#Sentinel：流控、熔断降级、系统负载保护" class="headerlink" title="Sentinel：流控、熔断降级、系统负载保护"></a>Sentinel：流控、熔断降级、系统负载保护</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304230038114.png" alt="image-20220304230038114"><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304230504257.png" alt="image-20220304230504257"></p><p>熔断：</p><p>  A 服务调用 B 服务的某个功能，由于网络不稳定问题，或者 B 服务卡机，导致功能时 间超长。如果这样子的次数太多。我们就可以直接将 B 断路了（A 不再请求 B 接口），凡是 调用 B 的直接返回降级数据，不必等待 B 的超长执行。 这样 B 的故障问题，就不会级联影响到 A。 熔断是被调方多次故障，触发系统的主动保护规则。</p><p>降级：</p><p>  整个网站处于流量高峰期，服务器压力剧增，根据当前业务情况及流量，对一些服务和 页面进行有策略的降级[停止服务，所有的调用直接返回降级数据]。以此缓解服务器资源的 的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到正确的相应。</p><p>流量控制几个角度：</p><p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系； </p><p>运行指标，例如 QPS、线程池、系统负载等； </p><p>控制的效果，例如直接限流、冷启动、排队等。</p><p>Sentinel相比Hystrix：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ Sentinel相比Hystrix：</span><br><span class="line">+ 隔离策略</span><br><span class="line">        + 线程池隔离</span><br><span class="line">            + 为请求分配自带线程池</span><br><span class="line">            + 优点</span><br><span class="line">                + 线程池之间隔离，池子炸了与其他请求无关</span><br><span class="line">        + 信号量隔离</span><br><span class="line">            + 为请求分配信号量</span><br></pre></td></tr></table></figure><p>sentinel-定义资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 定义resource</span><br><span class="line">    + 主流框架默认适配</span><br><span class="line">    + 抛出异常方式定义资源</span><br><span class="line">    + 返回布尔值方式定义资源</span><br><span class="line">    + 注解方式定义资源（可配置回调）</span><br><span class="line">    + 异步调用支持</span><br><span class="line">+ 自定义定义资源</span><br><span class="line">+ try-catch</span><br><span class="line">+ 基于注解 </span><br><span class="line">+ 调用链路</span><br><span class="line">        + 自定义blockhandler：限流、降级、系统保护时调用</span><br><span class="line">        + fallback：处理异常</span><br></pre></td></tr></table></figure><p>sentinel-限流模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 限流模式</span><br><span class="line">    + 链路限流模式</span><br><span class="line">        + 只统计某个入口进入的流量</span><br><span class="line">    + 关联模式</span><br><span class="line">        + 其他人流量大限制自己</span><br><span class="line">    + 直接拒绝</span><br><span class="line">    + warm up</span><br><span class="line">        + 预热：指定时间内将流量慢慢增加到限流阈值</span><br><span class="line">    + 排队等待</span><br></pre></td></tr></table></figure><p>Sentinel-熔断降级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 熔断降级</span><br><span class="line">+ 限流是对请求进行流控</span><br><span class="line">    + 远程调用需要用熔断降级进行保护</span><br><span class="line">    + 调用方熔断保护</span><br><span class="line">        + 开启feign-sentinel</span><br><span class="line">        + 对调用方接口加入fallback</span><br><span class="line">        + 实现feign接口</span><br><span class="line">            + 实现fallback方法</span><br><span class="line">    + 指定降级策略</span><br><span class="line">    + 远程服务（服务提供方）降级保护</span><br><span class="line">        + 流量过大时全局考虑，将某些服务提供方降级处理</span><br></pre></td></tr></table></figure><p>Sentinel-网关流控</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231223789.png" alt="image-20220304231223789"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 网关限流功能</span><br><span class="line">+ 引入sentinel与gateway适配整合</span><br><span class="line">+ 网关页面</span><br><span class="line">        + 流控</span><br><span class="line">        + api分组（对整个组进行流控设置）</span><br><span class="line">    + 定制网关流控返回</span><br><span class="line">    + Mono Webflux</span><br><span class="line">        + 响应式编程</span><br><span class="line">        + 天然支持高并发系统</span><br></pre></td></tr></table></figure><h2 id="Sleuth-Zipkin：链路追踪"><a href="#Sleuth-Zipkin：链路追踪" class="headerlink" title="Sleuth + Zipkin：链路追踪"></a>Sleuth + Zipkin：链路追踪</h2><p><strong>为什么用</strong></p><p>  微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务 单元。由于服务单元数量众多，业务的复杂性，如果<strong>出现了错误和异常，很难去定位</strong>。主要 体现在，<strong>一个请求可能需要调用很多个服务</strong>，而内部服务的调用复杂性，决定了问题难以 定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与， 参与的顺序又是怎样的，从而<strong>达到每个请求的步骤清晰可见，出了问题，很快定位</strong>。 </p><p>链路追踪组件有 Google 的 Dapper，Twitter 的 Zipkin，以及阿里的 Eagleeye （鹰眼）等，它们都是非常优秀的链路追踪开源组件。 </p><p><strong>基本术语</strong></p><p>Span（跨度）：基本工作单元，发送一个远程调度任务 就会产生一个 Span，Span 是一 个 64 位 ID 唯一标识的，Trace 是用另一个 64 位 ID 唯一标识的，Span 还有其他数据信息，比如摘要、时间戳事件、Span 的 ID、以及进度 ID。 </p><p>Trace（跟踪）：一系列 Span 组成的一个树状结构。请求一个微服务系统的 API 接口， 这个 API 接口，需要调用多个微服务，调用每个微服务都会产生一个新的 Span，所有 由这个请求产生的 Span 组成了这个 Trace。 </p><p>Annotation（标注）：用来及时记录一个事件的，一些核心注解用来定义一个请求的开 始和结束 。这些注解包括以下：  </p><ul><li><p>cs - Client Sent -客户端发送一个请求，这个注解描述了这个 Span 的开始  </p></li><li><p>sr - Server Received -服务端获得请求并准备开始处理它，如果将其 sr 减去 cs 时间戳 便可得到网络传输的时间。 </p></li><li><p>ss - Server Sent （服务端发送响应）–该注解表明请求处理的完成(当请求返回客户 端)，如果 ss 的时间戳减去 sr 时间戳，就可以得到服务器请求的时间。  </p></li><li><p>cr - Client Received （客户端接收响应）-此时 Span 的结束，如果 cr 的时间戳减去 cs 时间戳便可以得到整个请求所消耗的时间。 </p></li></ul><p>Sleuth原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231626939.png" alt="image-20220304231626939"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 每一个服务一个span</span><br><span class="line">    + trace id</span><br><span class="line">    + span id</span><br><span class="line">    + annotation标注</span><br><span class="line">    + 用来计算时间</span><br></pre></td></tr></table></figure><p>Sleuth + Zipkin</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231702938.png" alt="image-20220304231702938"></p><p>链路追踪</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231828856.png" alt="image-20220304231828856"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——支付宝支付&amp;RSA加密&amp;内网穿透</title>
      <link href="/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98&amp;RSA%E5%8A%A0%E5%AF%86&amp;%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98&amp;RSA%E5%8A%A0%E5%AF%86&amp;%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1、支付"><a href="#1、支付" class="headerlink" title="1、支付"></a>1、支付</h1><p>支付宝&amp;蚂蚁金服开发者平台：</p><p><a href="https://gitee.com/link?target=https://open.alipay.com/platform/home.htm">https://open.alipay.com/platform/home.htm</a></p><p>文档地址：</p><p>创建应用对应文档 <a href="https://gitee.com/link?target=https://openhome.alipay.com/docCenter/docCenter.htm">https://openhome.alipay.com/docCenter/docCenter.htm</a></p><p>网页移动应用文档 <a href="https://gitee.com/link?target=https://opendocs.alipay.com/open/200/105304">https://opendocs.alipay.com/open/200/105304</a></p><h2 id="支付宝支付流程"><a href="#支付宝支付流程" class="headerlink" title="支付宝支付流程"></a>支付宝支付流程</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230726942.png" alt="image-20220228230726942"></p><p>跳转的页面是根据AlipayTemplate定义的回调地址来进行跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">// 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息</span></span><br><span class="line">    <span class="keyword">private</span>  String notify_url = <span class="string">&quot;http://member.gulimall.com/memberOrder.html&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">//同步通知，支付成功，一般跳转到成功页</span></span><br><span class="line">    <span class="keyword">private</span>  String return_url = <span class="string">&quot;http://member.gulimall.com/memberOrder.html&quot;</span>;</span><br></pre></td></tr></table></figure><p>支付成功后异步回调接口处理，需要有服务器或配置了内网穿透才能接收到该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付宝异步通知回调接口,需要拥有内网穿透或服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/payed/notify&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleAlipayed</span><span class="params">(PayAsyncVo vo, HttpServletRequest request)</span> <span class="keyword">throws</span> UnsupportedEncodingException, AlipayApiException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重要一步验签名</span></span><br><span class="line"><span class="comment">         *  防止别人通过postman给我们发送一个请求，告诉我们请求成功，为了防止这种效果通过验签</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        Map&lt;String,String[]&gt; requestParams = request.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            String name = (String) iter.next();</span><br><span class="line">            String[] values = (String[]) requestParams.get(name);</span><br><span class="line">            String valueStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                valueStr = (i == values.length - <span class="number">1</span>) ? valueStr + values[i]</span><br><span class="line">                        : valueStr + values[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//乱码解决，这段代码在出现乱码时使用</span></span><br><span class="line">            valueStr = <span class="keyword">new</span> String(valueStr.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            params.put(name, valueStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 支付宝验签 防止恶意提交</span></span><br><span class="line">        <span class="keyword">boolean</span> signVerified = AlipaySignature.rsaCheckV1(params</span><br><span class="line">                , alipayTemplate.getAlipay_public_key()</span><br><span class="line">                , alipayTemplate.getCharset()</span><br><span class="line">                , alipayTemplate.getSign_type());</span><br><span class="line">        <span class="keyword">if</span> (signVerified) &#123;</span><br><span class="line">            String result = orderService.handleAlipayed(vo);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收单问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228233211250.png" alt="image-20220228233211250"></p><h2 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ 支付跳转</span><br><span class="line">    + controller</span><br><span class="line">        + 根据订单号查询封装订单Vo</span><br><span class="line">        + 调用支付方法</span><br><span class="line">+ 响应返回一个页面（支付宝收银台）</span><br><span class="line">+ 直接交给浏览器即可</span><br><span class="line">+ 跳转到会员订单列表页</span><br><span class="line">    + 支付成功跳转controller</span><br><span class="line">    + 会员服务feign远程调用订单服务</span><br><span class="line">            + 查询用户订单详情controller</span><br><span class="line">                + 根据id查询订单</span><br><span class="line">                + 遍历订单</span><br><span class="line">                    + 根据订单id查询订单项</span><br><span class="line">                    + 封装订单项详情</span><br><span class="line">    + 配置feign cookie同步拦截器（请求带上cookie）</span><br><span class="line">+ 异步通知（支付宝推荐）</span><br><span class="line">+ 不断通知，直到商户返回收到（最大努力通知型方案）</span><br><span class="line">+ 保证外网能够访问到</span><br><span class="line">            + 内网穿透</span><br><span class="line">            + server_name 加上外网的地址，保证可以进行server的跳转</span><br><span class="line">+ 异步通知获取参数接口</span><br><span class="line">+ 抽取异步参数的Vo</span><br><span class="line">+ 修改状态之前，需要验签（是否支付宝的数据）</span><br><span class="line">+ 验签代码，从demo中复制</span><br><span class="line">+ 支付成功处理（修改状态）</span><br><span class="line">+ 保存交易流水</span><br><span class="line">+ 数据库保证订单号、交易号等唯一</span><br><span class="line">+ 修改订单状态</span><br><span class="line">+ 查询订单，改为已支付</span><br><span class="line">+ 收单</span><br><span class="line">+ 问题</span><br><span class="line">        + 在支付页面过久，关单后才支付</span><br><span class="line">        + 库存关单后解锁，订单支付后变为已支付</span><br><span class="line">+ 支付宝自动收单功能（自动关闭收银台）</span><br><span class="line">    + 解锁库存完，支付完的异步通知才到</span><br><span class="line">    + 订单解锁，手动收单</span><br></pre></td></tr></table></figure><h1 id="2、RSA、加密加签、密钥"><a href="#2、RSA、加密加签、密钥" class="headerlink" title="2、RSA、加密加签、密钥"></a>2、RSA、加密加签、密钥</h1><p>对称加密：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230515319.png" alt="image-20220228230515319"></p><p>对称加密</p><ul><li>加密解密用同一把钥匙</li><li>一把钥匙不安全</li></ul><p>非对称加密 ：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230534327.png" alt="image-20220228230534327"></p><p>非对称加密</p><ul><li>加密解密使用不同钥匙</li></ul><p>公钥私钥：</p><p>公钥和私钥是一个相对概念，它们的公私性是相对于生成者来说的。 </p><p>一对密钥生成后，保存在生成者手里的就是私钥， 生成者发布出去大家用的就是公钥</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228231813227.png" alt="image-20220228231813227"></p><h1 id="3、内网穿透"><a href="#3、内网穿透" class="headerlink" title="3、内网穿透"></a>3、内网穿透</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228231656684.png" alt="image-20220228231656684"></p><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>内网穿透功能可以允许我们使用外网的网址来访问主机 正常的外网需要访问我们项目的流程是:</p><p>1、买服务器并且有公网固定IP</p><p>2、买域名映射到服务器的IP</p><p>3、域名需要进行备案和审核</p><h2 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h2><p>1、开发测试(微信、支付宝)</p><p>2、智慧互联</p><p>3、远程控制</p><p>4、私有云</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 优点</span><br><span class="line">+ 免服务器部署，直接在本地启动项目指定端口进行内网穿透即可</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——柔性事务-可靠消息+最终一致性解决方案（异步确保型）</title>
      <link href="/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF+%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF+%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="柔性事务-可靠消息-最终一致性解决方案（异步确保型）"><a href="#柔性事务-可靠消息-最终一致性解决方案（异步确保型）" class="headerlink" title="柔性事务-可靠消息+最终一致性解决方案（异步确保型）"></a>柔性事务-可靠消息+最终一致性解决方案（异步确保型）</h1><h2 id="RabbitMQ延时队列（实现定时任务）"><a href="#RabbitMQ延时队列（实现定时任务）" class="headerlink" title="RabbitMQ延时队列（实现定时任务）"></a>RabbitMQ延时队列（实现定时任务）</h2><p>场景： </p><p>比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 常用解决方案 </span><br><span class="line">+ spring的 schedule 定时任务轮询数据库 </span><br><span class="line">+ 缺点 </span><br><span class="line">+ 消耗系统内存、增加了数据库的压力、存在较大的时间误差 </span><br><span class="line">+ 解决</span><br><span class="line">+ rabbitmq的消息TTL和死信Exchange结合</span><br></pre></td></tr></table></figure><p>TTL存活时间</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102109187.png" alt="image-20220228102109187"></p><p>DLX死信交换机（Dead Letter Exchanges）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102131676.png" alt="image-20220228102131676"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102251153.png" alt="image-20220228102251153"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 模拟延迟场景</span><br><span class="line">    + 消息设置30m过期（队列不被监听）</span><br><span class="line">    + 30m后进入死信交换机</span><br><span class="line">    + 消息进入另一个队列（被监听）</span><br></pre></td></tr></table></figure><h3 id="延时队列实现"><a href="#延时队列实现" class="headerlink" title="延时队列实现"></a>延时队列实现</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102330181.png" alt="image-20220228102330181"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 给队列设置消息过期时间(推荐)</span><br><span class="line">+ 给消息设置消息过期时间</span><br><span class="line">+ rabbitmq懒检查</span><br><span class="line">    + 只会检查第一个消息是否过期</span><br><span class="line">    + 若后面消息ttl小，仍无法出队列</span><br><span class="line">    + 所以给队列设置过期时间</span><br></pre></td></tr></table></figure><h2 id="基于MQ可靠消息的一致性解决"><a href="#基于MQ可靠消息的一致性解决" class="headerlink" title="基于MQ可靠消息的一致性解决"></a>基于MQ可靠消息的一致性解决</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%81%E7%A8%8B.jpg" alt="消息队列流程"></p><p>监听库存解锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 解锁场景</span><br><span class="line">+ 未支付场景、手动取消订单</span><br><span class="line">+ 锁定成功，其他业务失败，订单回滚，自动解锁库存、</span><br><span class="line">+ 解锁之前，保存工作单（追溯）</span><br><span class="line">+ 库存锁成功时</span><br><span class="line">    + 保存工作单详情</span><br><span class="line">    + 给MQ发送消息到延时队列（消息包含工作单详情）</span><br></pre></td></tr></table></figure><p>库存解锁逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 监听解锁队列（延时过期队列）</span><br><span class="line">+ 根据消息查找库存工作单</span><br><span class="line">+ 没有：失败正常回滚</span><br><span class="line">    + 有：库存锁定成功，远程调用查询订单</span><br><span class="line">        + 没有订单：必须解锁</span><br><span class="line">        + 有订单，查看订单状态</span><br><span class="line">            + 已取消：解锁库存</span><br><span class="line">            + 没取消：不解锁</span><br><span class="line">    + ack</span><br><span class="line">+ 库存解锁，更新工作单状态</span><br></pre></td></tr></table></figure><p>定时关单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 监听器——关闭订单</span><br><span class="line">    + 执行成功则ack</span><br><span class="line">    + 不成功拒绝消息，重回队列</span><br><span class="line">+ 订单创建成功后，发送消息（订单）到MQ延时队列</span><br><span class="line">    + 消息过期到达监听器</span><br><span class="line">        + 查询订单的最新状态（可能已支付）</span><br><span class="line">        + 仍在代付款状态，则关单</span><br><span class="line">            + 更新订单状态为已取消</span><br></pre></td></tr></table></figure><p>问题：</p><p>1、订单消息卡顿，导致关单比库存解锁慢</p><p>2、库存解锁判断订单</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228103933963.png" alt="image-20220228103933963"></p><p>解决：关单后发送消息解锁库存（主动解锁库存补偿）</p><p>关单解锁库存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 查询库存工作单状态，防止重复解锁库存</span><br><span class="line">+ 按照工作单找到所有未解锁的库存（状态为1）进行解锁</span><br></pre></td></tr></table></figure><p>库存解锁总结：两种消息监听（库存解锁延迟消息、order主动关闭消息）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 主动补偿：关单解锁</span><br><span class="line">+ 被动补偿：自动解锁</span><br><span class="line">+ 若判断解锁过则放过消息</span><br><span class="line">+ 解决高并发</span><br><span class="line">+ 解决系统异构</span><br></pre></td></tr></table></figure><h2 id="消息丢失、积压、重复等解决方案"><a href="#消息丢失、积压、重复等解决方案" class="headerlink" title="消息丢失、积压、重复等解决方案"></a>消息丢失、积压、重复等解决方案</h2><h3 id="消息丢失：ack，防重表"><a href="#消息丢失：ack，防重表" class="headerlink" title="消息丢失：ack，防重表"></a>消息丢失：ack，防重表</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104351405.png" alt="image-20220228104351405"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104549154.png" alt="image-20220228104549154"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 消息丢失</span><br><span class="line">+ 网络问题，发送失败</span><br><span class="line">+ 加上try-catch</span><br><span class="line">    + 日志记录</span><br><span class="line">            + 数据库保存发送的消息详细信息，记录消息状态</span><br><span class="line">            + 定期扫描数据库，发送失败消息</span><br><span class="line">    + 消息抵达broker，尚未持久化完成（未抵达队列），宕机</span><br><span class="line">    + 发送端加入消息确认回调机制（e-&gt;q）</span><br><span class="line">    + 自动ack，消费者没来得及消费，宕机</span><br><span class="line">    + 开启手动ack模式，消费成功才移除消息</span><br><span class="line">    + 总结</span><br><span class="line">    + 做好消息确认机制（ pulisher，consumer 手动ack）</span><br><span class="line">+ 每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `mq_message` (</span><br><span class="line">`message_id` <span class="type">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`content` text,</span><br><span class="line">`to_exchane` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`routing_key` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`class_type` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`message_status` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0-新建 1-已发送 2-错误抵达 3-已抵达&#x27;</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`message_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br></pre></td></tr></table></figure><h3 id="消息重复：幂等性"><a href="#消息重复：幂等性" class="headerlink" title="消息重复：幂等性"></a>消息重复：幂等性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 消息重复</span><br><span class="line">    + 消息消费成功，ack前宕机，再次被消费</span><br><span class="line">    + 消费失败，重试机制</span><br><span class="line">    + ack宕机，unack变为ready，broker重新发送消息，同1</span><br><span class="line">    + 解决</span><br><span class="line">        + 业务逻辑解锁库存方法设为幂等性：判断库存工单状态，已解锁则无需解锁</span><br><span class="line">        + 保证幂等：使用防重表，处理后保存唯一标识id，免再次处理</span><br><span class="line">        + 消息的redelivered属性，判断是否为重新投递</span><br><span class="line">            + 无法判断上次是否处理成功</span><br></pre></td></tr></table></figure><h3 id="消息积压："><a href="#消息积压：" class="headerlink" title="消息积压："></a>消息积压：</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104743095.png" alt="image-20220228104743095"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 消息积压</span><br><span class="line">    + 消费者宕机</span><br><span class="line">    + 消费能力不足</span><br><span class="line">    + 发送流量太大</span><br><span class="line">        + 限制业务流量</span><br><span class="line">        + 上线更多消费者</span><br><span class="line">        + 批量取出消息保存到数据库中，离线业务慢慢处理</span><br></pre></td></tr></table></figure><p>1、分离消息微服务，考虑消息可靠性</p><p>2、调用微服务去发送消息</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——幂等性&amp;分布式事务&amp;Raft原理</title>
      <link href="/2022/02/27/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%B9%82%E7%AD%89%E6%80%A7&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1&amp;%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF&amp;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/02/27/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%B9%82%E7%AD%89%E6%80%A7&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1&amp;%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF&amp;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1、订单链路"><a href="#1、订单链路" class="headerlink" title="1、订单链路"></a>1、订单链路</h1><h2 id="订单中心"><a href="#订单中心" class="headerlink" title="订单中心"></a>订单中心</h2><p>电商系统涉及到 3 流，分别时信息流，资金流，物流，而订单系统作为中枢将三者有机的集合起来。 </p><p>订单模块是电商系统的枢纽，在订单这个环节上需求获取多个模块的数据和信息，同时对这些信息进行加工处理后流向下个环节，这一系列就构成了订单的信息流通。 </p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228080432263.png" alt="image-20220228080432263"></p><h2 id="订单流程"><a href="#订单流程" class="headerlink" title="订单流程"></a>订单流程</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228081824936.png" alt="image-20220228081824936"></p><h2 id="Feign远程异步调用丢失请求头、上下文问题"><a href="#Feign远程异步调用丢失请求头、上下文问题" class="headerlink" title="Feign远程异步调用丢失请求头、上下文问题"></a>Feign远程异步调用丢失请求头、上下文问题</h2><p>Feign远程调用丢失请求头问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228091104146.png" alt="image-20220228091104146"></p><p>feign异步情况丢失上下文问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228091118962.png" alt="image-20220228091118962"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ Feign远程调用丢失请求头问题</span><br><span class="line">    + 原因</span><br><span class="line">    + fegin调用没带session</span><br><span class="line">        + 创建一个新request，没有请求头</span><br><span class="line">    + 解决（同步老请求cookie）</span><br><span class="line">        + 加个feign请求调用的拦截器</span><br><span class="line">        + ThreadLocal获取老请求请求属性——cookie</span><br><span class="line">        + 设置新请求cookie</span><br><span class="line">+ feign异步情况丢失上下文问题</span><br><span class="line">+ 原因</span><br><span class="line">+ requecontexHolder底层是同一线程共享数据</span><br><span class="line">+ 通过ThreadLocal获取老请求，异步编排非同一线程</span><br><span class="line">+ 解决</span><br><span class="line">+ 执行异步前，提前共享请求数据</span><br></pre></td></tr></table></figure><p>也可以传传用户id，传用户会话，后者安全些，</p><p>1、id传参</p><p>2、传递cookie</p><h1 id="2、接口幂等性"><a href="#2、接口幂等性" class="headerlink" title="2、接口幂等性"></a>2、接口幂等性</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%E9%A1%B5%E6%B5%81%E7%A8%8B.png" alt="订单确认页流程"></p><p>保证幂等情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 用户多次点击按钮</span><br><span class="line">+ 用户页面回退再次提交</span><br><span class="line">+ 微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制</span><br><span class="line">+ 其他业务情况</span><br></pre></td></tr></table></figure><p>幂等解决方案：</p><h2 id="1、token机制"><a href="#1、token机制" class="headerlink" title="1、token机制"></a>1、token机制</h2><p>1、服务端提供了发送 token 的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取 token，服务器会把 token 保存到 redis 中。<br>2、然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。<br>3、服务器判断 token 是否存在 redis 中，存在表示第一次请求，然后删除 token,继续执行业务。<br>4、如果判断 token 不存在 redis 中，就表示是重复操作，直接返回重复标记给 client，这样就保证了业务代码，不被重复执行。</p><p>危险性(非原子操作)：<br>1、先删除 token 还是后删除 token；<br>    (1) 先删除可能导致，业务确实没有执行，重试还带上之前 token，由于防重设计导致， 请求还是不能执行。<br>    (2) 后删除可能导致，业务处理成功，但是服务闪断，出现超时，没有删除 token，别 人继续重试，导致业务被执行两边<br>    (3) 我们最好设计为先删除 token，如果业务调用失败，就重新获取 token 再次请求。<br>2、Token 获取、比较和删除必须是原子性<br>    (1) redis.get(token) 、token.equals、redis.del(token)如果这两个操作不是原子，可能导 致，高并发下，都 get 到同样的数据，判断都成功，继续业务并发执行<br>    (2) 可以在 redis 使用 lua 脚本完成这个操作 if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">必须原子性：lua脚本</span><br><span class="line">1、获取令牌</span><br><span class="line">2、对比token</span><br><span class="line">3、删除令牌</span><br></pre></td></tr></table></figure><h2 id="2、各种锁机制"><a href="#2、各种锁机制" class="headerlink" title="2、各种锁机制"></a>2、各种锁机制</h2><p>数据库悲观锁</p><p>select * from xxxx where id = 1 for update; 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。 另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。</p><p>数据库乐观锁</p><p>这种方法适合在更新的场景中， update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1 根据 version 版本，也就是在操作库存前先获取当前商品的 version 版本号，然后操作的时候 带上此 version 号。我们梳理下，我们第一次操作库存时，得到 version 为 1，调用库存服务 version 变成了 2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订 单服务传如的 version 还是 1，再执行上面的 sql 语句时，就不会执行；因为 version 已经变 为 2 了，where 条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。乐观锁主要使用于处理读多写少的问题</p><p>业务层分布式锁</p><p>如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数 据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</p><h2 id="3、各种唯一约束"><a href="#3、各种唯一约束" class="headerlink" title="3、各种唯一约束"></a>3、各种唯一约束</h2><p>数据库唯一约束</p><p>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。 这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键 的要求不是自增的主键，这样就需要业务生成全局唯一的主键。 如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p><p>redis set防重</p><p>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的 set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理。</p><h2 id="4、防重表"><a href="#4、防重表" class="headerlink" title="4、防重表"></a>4、防重表</h2><p>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且 他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。 </p><p>redis 防重也算</p><h2 id="5、全局请求唯一id"><a href="#5、全局请求唯一id" class="headerlink" title="5、全局请求唯一id"></a>5、全局请求唯一id</h2><p>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。 </p><p>可以使用 nginx 设置每一个请求的唯一 id；</p><p>proxy_set_header X-Request-Id $request_id;</p><p>总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ token令牌</span><br><span class="line">+ 原子性获取、对比、删除token</span><br><span class="line">+ 锁</span><br><span class="line">+ 数据库乐观锁、悲观锁</span><br><span class="line">+ 分布式锁</span><br><span class="line">+ 唯一约束</span><br><span class="line">+ 数据库主键唯一约束</span><br><span class="line">+ MD5加密redis set</span><br><span class="line">+ 防重表</span><br><span class="line">+ 操作之后以唯一索引放入去重表中，且与业务表同一数据库保证同一事务</span><br><span class="line">+ 全局请求唯一id</span><br><span class="line">+ 调用接口生成唯一id，放到redis中去重</span><br><span class="line">+ 链路追踪</span><br></pre></td></tr></table></figure><h1 id="3、分布式事务"><a href="#3、分布式事务" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h1><h2 id="1、本地事务"><a href="#1、本地事务" class="headerlink" title="1、本地事务"></a>1、本地事务</h2><h3 id="事务的基本性质"><a href="#事务的基本性质" class="headerlink" title="事务的基本性质"></a>事务的基本性质</h3><p>数据库事务的几个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称就是 ACID。</p><ul><li><p>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败；</p></li><li><p>一致性：数据在事务的前后，业务整体一致；</p></li><li><p>隔离性：事务之间互相隔离；</p></li><li><p>持久性：一旦事务成功，数据一定会落盘在数据库。</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li><p>READ UNCOMMITTED（读未提交）：该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。</p></li><li><p>READ COMMITTED（读提交）：一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。</p></li><li><p>REPEATABLE READ（可重复读）：该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL的 InnoDB 引擎可以通过 next-key locks 机制（参考下文”行锁的算法”一节）来避免幻读。</p></li><li><p>SERIALIZABLE（序列化）：在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p></li></ul><h3 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别"></a>事务的传播级别</h3><ol><li><p>PROPAGATION_REQUIRED： ：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p></li><li><p>PROPAGATION_SUPPORTS： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p></li><li><p>PROPAGATION_MANDATORY： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p></li><li><p>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p></li><li><p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p>PROPAGATION_NEVER： 以非事务方式执行，如果当前存在事务，则抛出异常。</p></li><li><p>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</p></li></ol><p>问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 远程调用超时——假异常</span><br><span class="line">    + 抛出异常导致全部回滚</span><br><span class="line">+ 扣减积分异常</span><br><span class="line">    + 扣减积分可以回滚</span><br><span class="line">    + 本地的订单可以回滚</span><br><span class="line">    + 远程锁库存无法回滚</span><br><span class="line">        + 事务无法控制远程服务</span><br><span class="line">        + 还需手动释放库存</span><br></pre></td></tr></table></figure><h2 id="2、SpringBoot事务"><a href="#2、SpringBoot事务" class="headerlink" title="2、SpringBoot事务"></a>2、SpringBoot事务</h2><p>@Transactional</p><p>内部事务互调问题：</p><p>在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。</p><p>原因：同一对象内事务互调默认失效，绕过了代理对象。</p><p>解决：</p><ol><li><p>导入 spring-boot-starter-aop</p></li><li><p>@EnableTransactionManagement(proxyTargetClass = true)</p></li><li><p>@EnableAspectJAutoProxy(exposeProxy=true)</p></li><li><p>AopContext.currentProxy() 调用方法</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 本地事务互调解决</span><br><span class="line">    + 使用代理对象调用事务方法</span><br><span class="line">        + 引入aop的aspectj</span><br><span class="line">        + 开启aspectj动态代理功能</span><br><span class="line">        + spring中bean可以代替 aspectj</span><br></pre></td></tr></table></figure><h2 id="3、分布式事务-1"><a href="#3、分布式事务-1" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228092926460.png" alt="image-20220228092926460"></p><p>1、远程服务假失败</p><p>2、远程事务回滚</p><h3 id="分布式CAP定理"><a href="#分布式CAP定理" class="headerlink" title="分布式CAP定理"></a>分布式CAP定理</h3><p>分布式系统经常出现的异常机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失…</p><p>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094112202.png" alt="image-20220228094112202"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ CAP定理</span><br><span class="line">+ 一致、可用二选一，分区容错性无法避免</span><br></pre></td></tr></table></figure><h3 id="Raft原理"><a href="#Raft原理" class="headerlink" title="Raft原理"></a>Raft原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094509282.png" alt="image-20220228094509282"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ 分布式系统实现一致性的Raft算法、paxos等</span><br><span class="line">    + leader选举</span><br><span class="line">        + 随从自旋时间（随机），等待命令</span><br><span class="line">        + 自旋结束的随从变成候选人，开启一轮新的选举</span><br><span class="line">        + 随从若当前未投票可发送投票</span><br><span class="line">        + 随从投过票后重新自旋</span><br><span class="line">        + leader发送追加日志信息给随从</span><br><span class="line">            + 消息发送以间隔（心跳时间）发送</span><br><span class="line">            + 随从收到消息后重置自旋时间</span><br><span class="line">        + leader宕机</span><br><span class="line">            + 随从自旋时间结束，变为候选者</span><br><span class="line">            + 开启选举，成为leader</span><br><span class="line">        + 如果出现两个候选者，出现投票分离</span><br><span class="line">            + 谁的投票请求先到投谁，其他的拒收</span><br><span class="line">            + 票数一样</span><br><span class="line">            + 重写来一轮自旋，候选者选举</span><br><span class="line">            + 直到候选者票数最多选出leader</span><br><span class="line">    + 日志复制</span><br><span class="line">    + leader将所有改变复制给其他node</span><br><span class="line">            + 使用追加日志方式复制（在每一个心跳时发送）</span><br><span class="line">            + 随从收到同步后回复消息</span><br><span class="line">            + leader收到大多数回复后提交，并响应客户端</span><br><span class="line">            + 在下一个心跳时间，请求其他node提交</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094701842.png" alt="image-20220228094701842"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094710919.png" alt="image-20220228094710919"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 出现分区错误</span><br><span class="line">    + 分区之后</span><br><span class="line">        + 接收不到消息，选举领导</span><br><span class="line">        + 大多数同意才能进行改变</span><br><span class="line">    + 恢复网络分区</span><br><span class="line">        + 低轮次leader退位</span><br><span class="line">        + 处于低轮次的node未提交日志全部回滚</span><br><span class="line">        + 匹配新leader日志</span><br><span class="line">        + 全部node一致</span><br></pre></td></tr></table></figure><p>Raft算法官网：<a href="https://raft.github.io/">https://raft.github.io/</a></p><h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>是对 CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可以采用适当的采取弱一致性，即<strong>最终一致性</strong>。 </p><p>BASE 是指</p><ul><li><p>基本可用（Basically Available）</p></li><li><ul><li>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。</li></ul></li><li><ul><li><ul><li>响应时间上的损失：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。</li><li>功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li></ul></li><li><p>软状态（ Soft State）</p></li><li><ul><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。</li></ul></li><li><p>最终一致性（ Eventual Consistency）</p></li><li><ul><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ base</span><br><span class="line">    + 基本可用</span><br><span class="line">        + 允许损失部分可用性</span><br><span class="line">    + 软状态</span><br><span class="line">        + 允许系统存在中间状态</span><br><span class="line">    + 最终一致性</span><br><span class="line">        + 经历一定时间后，最终能达到一致性状态</span><br></pre></td></tr></table></figure><h3 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h3><p>​    从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是 <strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是 <strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是 <strong>最终一致性。</strong></p><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><h4 id="2PC模式"><a href="#2PC模式" class="headerlink" title="2PC模式"></a>2PC模式</h4><p>数据库支持的 2PC【2 phase commit 二阶提交】，又叫做 XA Transactions。</p><p>MySQL 从 5.5 版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：</p><p>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</p><p>第二阶段：事务协调器要求每个数据库提交数据。</p><p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228100342688.png" alt="image-20220228100342688"></p><ul><li><p>XA 协议比较简单，而且一旦商业数据库实现了 XA 协议，使用分布式事务的成本也比较低。</p></li><li><p>XA  性能不理想，特别是在交易下单链路，往往并发量很高，XA 无法满足高并发场景</p></li><li><p>XA 目前在商业数据库支持的比较理想，在 在 mysql  数据库中支持的不太理想，mysql 的XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</p></li><li><p>许多 nosql 也没有支持 XA，这让 XA 的应用场景变得非常狭隘。</p></li><li><p>也有 3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 2PC模式（XA）：二阶段提交</span><br><span class="line">    + 使用场景小</span><br><span class="line">    + 高并发性能差</span><br></pre></td></tr></table></figure><h4 id="柔性事务-TCC"><a href="#柔性事务-TCC" class="headerlink" title="柔性事务-TCC"></a>柔性事务-TCC</h4><p>刚性事务：遵循 ACID 原则，强一致性。</p><p>柔性事务：遵循 BASE 理论，最终一致性；</p><p>与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1629027928516-e4e2272b-2df1-48ec-ac90-dee09d1c96ab.png" alt="image.png"></p><p>一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。</p><p>二阶段 commit 行为：调用 自定义 的 commit 逻辑。</p><p>二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。</p><p>所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228100848491.png" alt="image-20220228100848491"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 柔性事务-TCC事务补偿型方案</span><br><span class="line">    + 一阶段prepare——try</span><br><span class="line">    + 二阶段commit——confirm</span><br><span class="line">    + 二阶段rollback——cancel</span><br></pre></td></tr></table></figure><h4 id="柔性事务-最大努力通知型方案（结合MQ）"><a href="#柔性事务-最大努力通知型方案（结合MQ）" class="headerlink" title="柔性事务-最大努力通知型方案（结合MQ）"></a>柔性事务-最大努力通知型方案（结合MQ）</h4><p>按规律进行通知， <strong>不保证数据一定能通知成功，但会提供可查询操作接口进行核对</strong>。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。</p><p>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调。</p><h4 id="柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="柔性事务-可靠消息 + 最终一致性方案（异步确保型）"></a>柔性事务-可靠消息 + 最终一致性方案（异步确保型）</h4><p>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><p>防止消息丢失：</p><ol><li>做好消息确认机制（ pulisher ， consumer 【手动 ack 】）</li><li>每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍.</li></ol><h3 id="Seata分布式事务"><a href="#Seata分布式事务" class="headerlink" title="Seata分布式事务"></a>Seata分布式事务</h3><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/145942191-7a2d469f-94c8-4cd2-8c7e-46ad75683636.png" alt="image"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 创建UNDO_LOG表（每一个数据库）（AT模式：自动模式）</span><br><span class="line">    + 回滚表</span><br><span class="line">    + 自动补偿</span><br><span class="line">+ 安装事务协调器：seata-server</span><br><span class="line">+ 使用seata DataSourceProxy代理自己的数据源</span><br><span class="line">+ 全局事务注解</span><br><span class="line">    + GlobalTransactional</span><br></pre></td></tr></table></figure><p>问题：AT模式吞吐量低，不支持高并发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ seata默认AT模式</span><br><span class="line">    + 不用做高并发场景</span><br><span class="line">    + 后台简单场景，不要求高并发</span><br><span class="line">    + 包含各种锁机制</span><br></pre></td></tr></table></figure><p>高并发场景：考虑基于消息服务的柔性事务方案</p><p>1、锁库存成功数据库保存锁库存工作单</p><p>2、引入延迟队列——完成库存自动解锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228101557537.png" alt="image-20220228101557537"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——session共享&amp;sso&amp;ThreadLocal</title>
      <link href="/2022/02/17/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-session%E5%85%B1%E4%BA%AB&amp;sso&amp;ThreadLocal/"/>
      <url>/2022/02/17/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-session%E5%85%B1%E4%BA%AB&amp;sso&amp;ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="1、MD5-amp-盐值-amp-BCrypt"><a href="#1、MD5-amp-盐值-amp-BCrypt" class="headerlink" title="1、MD5&amp;盐值&amp;BCrypt"></a>1、MD5&amp;盐值&amp;BCrypt</h1><p>MD5 （Message Digest algorithm 5，信息摘要算法） </p><p>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。 </p><p>2、容易计算：从原数据计算出MD5值很容易。 </p><p>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 </p><p>4、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 </p><p>5、不可逆 </p><p>加盐： </p><p>1、通过生成随机数与MD5生成字符串进行组合 </p><p>2、数据库同时存储MD5值与salt值。验证正确性时使用salt进行MD5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ Spring的加密</span><br><span class="line">+ 自动加盐</span><br><span class="line">+ match匹配（与encode匹配）</span><br></pre></td></tr></table></figure><h1 id="2、分布式session共享"><a href="#2、分布式session共享" class="headerlink" title="2、分布式session共享"></a>2、分布式session共享</h1><p>问题：</p><p>不同服务session不共享</p><p>同一服务session不同步</p><h2 id="session原理"><a href="#session原理" class="headerlink" title="session原理"></a>session原理</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218001900202.png" alt="image-20220218001900202"></p><h2 id="分布式session解决方案"><a href="#分布式session解决方案" class="headerlink" title="分布式session解决方案"></a>分布式session解决方案</h2><h3 id="1、session复制"><a href="#1、session复制" class="headerlink" title="1、session复制"></a>1、session复制</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002213539.png" alt="image-20220218002213539"></p><p>Session复制（tomcat之间同步）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + web-server（Tomcat）原生支持，只需要修改配置文件 </span><br><span class="line">+ 缺点：</span><br><span class="line">+ session同步需要数据传输，占用大量网络带宽，降低了服务器群的业务处理能力 </span><br><span class="line">    + 任意一台web-server保存的数据都是所有web-server的session总和，受到内存限制无法水平扩展更多的web-server </span><br><span class="line">    + 大型分布式集群情况下，由于所有web-server都全量保存数据，所以此方案不可取。</span><br></pre></td></tr></table></figure><h3 id="2、客户端存储"><a href="#2、客户端存储" class="headerlink" title="2、客户端存储"></a>2、客户端存储</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002226115.png" alt="image-20220218002226115"></p><p>放到cookie中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 优点</span><br><span class="line">+ 服务器不需存储session，用户保存自己的session信息到cookie中。</span><br><span class="line">+ 节省服务端资源</span><br><span class="line">+ 缺点</span><br><span class="line">    + 都是缺点，这只是一种思路。</span><br><span class="line">    + 每次http请求，携带用户在cookie中的完整信息，浪费网络带宽</span><br><span class="line">    + session数据放在cookie中，cookie有长度限制4K，不能保存大量信息</span><br><span class="line">    + session数据放在cookie中，存在泄漏、篡改、窃取等安全隐患</span><br></pre></td></tr></table></figure><h3 id="3、hash一致性"><a href="#3、hash一致性" class="headerlink" title="3、hash一致性"></a>3、hash一致性</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002507539.png" alt="image-20220218002507539"></p><p>Hash一致性（修改负载均衡）</p><p>+ 服务器闪断会丢失</p><p>+ 服务器数量变化重新hash，部分会丢失</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + 只需要改nginx配置，不需要修改应用代码 负载均衡，只要hash属性的值分布是均匀的，多台web-server的负载是均衡的 </span><br><span class="line">    + 可以支持web-server水平扩展（session同步法是不行的，受内存限制） </span><br><span class="line">缺点</span><br><span class="line">    + session还是存在web-server中的，所以web-server重 </span><br><span class="line">    启可能导致部分session丢失，影响业务，如部分用户 </span><br><span class="line">    需要重新登录 </span><br><span class="line">    + 如果web-server水平扩展，rehash后session重新分布， </span><br><span class="line">    也会有一部分用户路由不到正确的session </span><br><span class="line">+ 但是以上缺点问题也不是很大，因为session本来都是有有 </span><br></pre></td></tr></table></figure><h3 id="4、统一存储"><a href="#4、统一存储" class="headerlink" title="4、统一存储"></a>4、统一存储</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002612719.png" alt="image-20220218002612719"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + 没有安全隐患</span><br><span class="line">    + 可以水平扩展，数据库/缓存水平切分即可</span><br><span class="line">    + web-server重启或者扩容都不会有 session丢失</span><br><span class="line">+ 不足</span><br><span class="line">    + 增加了一次网络调用，并且需要修改应 用代码；如将所有的getSession方法替换为从Redis查数据的方式。redis获取数 据比内存慢很多</span><br><span class="line">    + 上面缺点可以用SpringSession完美解决</span><br></pre></td></tr></table></figure><h3 id="5、扩大cookie作用域"><a href="#5、扩大cookie作用域" class="headerlink" title="5、扩大cookie作用域"></a>5、扩大cookie作用域</h3><p>解决子域共享问题</p><p>问题：多域名</p><h2 id="SpringSession"><a href="#SpringSession" class="headerlink" title="SpringSession"></a>SpringSession</h2><p>配置类：json编码、cooki子域问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">//放大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">&quot;gulimall.com&quot;</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">&quot;GULISESSION&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理：装饰者模式"><a href="#原理：装饰者模式" class="headerlink" title="原理：装饰者模式"></a>原理：装饰者模式</h3><p>狸猫换太子</p><p>@EnableRedisHttpSession 导入 RedisHttpSessionConfiguration 配置</p><p>1、给容器中添加了一个组件 RedisOperationsSessionRepository：Redis操作session，session的增删改查封装类；</p><p>2、继承 SpringHttpSessionConfiguration 初始化了一个 SessionRepositoryFilter：session 存储过滤器；每个请求过来都必须经过 Filter 组件；创建的时候，自动从容器中获取到了 SessionRepository；</p><p> SessionRepositoryFilter：</p><ul><li>将原生的 HttpServletRequest Response 包装成 SessionRepositoryRequestWrapper ResponseWrapper；包装后的对象应用到了后面整个执行链；</li><li>以后获取 request.getSession(); 都会调用 wrappedRequesr.getSession(); 从SessionRepository获取；</li></ul><p>3、装饰者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    request.setAttribute(SESSION_REPOSITORY_ATTR, <span class="keyword">this</span>.sessionRepository);</span><br><span class="line">    SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper wrappedRequest = <span class="keyword">new</span> SessionRepositoryFilter.SessionRepositoryRequestWrapper(request, response);</span><br><span class="line">    SessionRepositoryFilter.SessionRepositoryResponseWrapper wrappedResponse = <span class="keyword">new</span> SessionRepositoryFilter.SessionRepositoryResponseWrapper(wrappedRequest, response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filterChain.doFilter(wrappedRequest, wrappedResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        wrappedRequest.commitSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、sso单点登录"><a href="#3、sso单点登录" class="headerlink" title="3、sso单点登录"></a>3、sso单点登录</h1><p>跨域名单点登录简单实现：</p><p>1、服务端：未登录跳转认证中心（附带参数保存原地址）</p><p>2、认证中心：登录成功本地保存cookie（sso_token）</p><p>3、认证中心：保存登录用户登录状态到redis中</p><p>4、认证中心：重定向url中附带token跳转回原页面</p><p>5、服务端：根据token查询redis获取用户信息保存session</p><p>6、其他服务端：未登录跳转到认证中心，直接登录成功返回</p><p>服务端：根据有无session判断是否登录</p><p>认证中心：根据有无sso_token判断是否登录</p><p>可实现：filter、jwt、springsecurity</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" alt="单点登录流程"></p><h1 id="4、ThreadLocal同一个线程共享数据"><a href="#4、ThreadLocal同一个线程共享数据" class="headerlink" title="4、ThreadLocal同一个线程共享数据"></a>4、ThreadLocal同一个线程共享数据</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218004911488.png" alt="image-20220218004911488"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; toThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">toThreadLocal.set(userInfoTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">UserInfoTo userInfoTo = CartInterceptor.toThreadLocal.get();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——缓存&amp;分布式锁&amp;检索&amp;异步&amp;线程池</title>
      <link href="/2022/02/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E7%BC%93%E5%AD%98&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;%E6%A3%80%E7%B4%A2&amp;%E5%BC%82%E6%AD%A5/"/>
      <url>/2022/02/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E7%BC%93%E5%AD%98&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;%E6%A3%80%E7%B4%A2&amp;%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1、缓存"><a href="#1、缓存" class="headerlink" title="1、缓存"></a>1、缓存</h1><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220216234206407.png" alt="image-20220216234206407"></h2><h2 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h2><p>1、缓存穿透：</p><p>不存在数据</p><p>缓存null、设置短的过期时间</p><p>2、缓存雪崩：</p><p>大面积同时失效</p><p>失效加随机值</p><p>3、缓存击穿</p><p>热点key失效</p><p>加锁</p><h2 id="缓存数据一致性解决"><a href="#缓存数据一致性解决" class="headerlink" title="缓存数据一致性解决"></a>缓存数据一致性解决</h2><p>双写模式：</p><p>+ 改完数据库同时改缓存</p><p>+ 脏数据</p><p>​    + 加锁</p><p>​    + 是否允许暂时不一致性——缓存过期后可读正确数据</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220216234700247.png" alt="image-20220216234700247"></p><p>失效模式</p><p>+ 删除缓存数据</p><p>+ 等待下次查询主动更新</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003139062.png" alt="image-20220217003139062"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003318428.png" alt="image-20220217003318428"></p><p>+ 并发量小不考虑</p><p>+ 菜单等，用canal</p><p>​    + 自动更新缓存（db从库）</p><p>​    + 数据异构（访问记录表 和 商品 进行分析计算——用户推荐）</p><p>+ 过期时间保证 最终一致性</p><p>+ 加读写锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003503499.png" alt="image-20220217003503499"></p><p>我们系统的一致性<strong>解决方案</strong>： </p><p>1、缓存的所有数据都有过期时间，数据过期下一次查询触发主动更新 </p><p>2、读写数据的时候，加上分布式的<strong>读写锁</strong>。 （经常写，经常读）</p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>使用大量aop切面编程，最终都是动态代理机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ @Cacheable：结果缓存</span><br><span class="line">+ key、value</span><br><span class="line">+ ttl</span><br><span class="line">+ 序列化：json</span><br><span class="line">+ @CacheEvict：删除缓存</span><br><span class="line">+ @CachePut：调用方法且缓存</span><br><span class="line">+ 双写模式</span><br><span class="line">+ @Caching：多个操作</span><br><span class="line">+ 开启缓存空值</span><br><span class="line">+ 防止缓存穿透</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 读模式</span><br><span class="line">+ 缓存穿透：缓存null</span><br><span class="line">+ 缓存击穿：加锁</span><br><span class="line">+ 缓存雪崩：过期时间加随机</span><br><span class="line">+ 写模式（缓存与数据库一致）</span><br><span class="line">+ 读写加锁</span><br><span class="line">+ canal感知数据库</span><br><span class="line">+ 读多写多，直接去数据库</span><br></pre></td></tr></table></figure><h1 id="2、分布式锁"><a href="#2、分布式锁" class="headerlink" title="2、分布式锁"></a>2、分布式锁</h1><h3 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h3><p>redis setnx</p><p>问题：异常退出死锁</p><h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><p>同时原子设置过期时间</p><p>问题：锁过期，删错锁</p><h3 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h3><p>唯一标识value验证</p><p>问题：获取value和删除key非原子，仍存在删错锁</p><h3 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h3><p>lua脚本，解锁保证原子性</p><p>问题：未执行完锁过期，续期问题</p><h3 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h3><p>锁时间放长，finally解锁</p><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217001540526.png" alt="image-20220217001540526"></p><p>使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，更进一步简化了分布式环境中程序相互之间的协作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+lock锁</span><br><span class="line">+自动续期</span><br><span class="line">+看门狗：判断线程 + 定时任务（重设过期时间）</span><br><span class="line">+ trylock（获取一次）</span><br><span class="line">+ fair lock公平锁（队列）</span><br><span class="line">+ readwritelock读写锁</span><br><span class="line">    + 写锁限制读和写操作（保证读数据一致性）</span><br><span class="line">    + 读锁单独无限制（无锁）</span><br><span class="line">    + 只要有写操作，就需要等待（读写，写读）</span><br><span class="line">+ 信号量（固定车位）</span><br><span class="line">+ 分布式限流</span><br><span class="line">+ acquire（阻塞）、Tryacquire</span><br><span class="line">+ 闭锁（走完关门）</span><br></pre></td></tr></table></figure><p>看门狗原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/816762-20210425105548419-1714180337.jpg" alt="img"></p><h1 id="3、检索"><a href="#3、检索" class="headerlink" title="3、检索"></a>3、检索</h1><p>vo封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询到的所有商品信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SkuEsModel&gt; product;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer totalPages;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; pageNavs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的品牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BrandVo&gt; brands;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的所有属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AttrVo&gt; attrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的所有分类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CatalogVo&gt; catalogs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================以上是返回给页面的所有信息============================//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 面包屑导航数据 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;NavVo&gt; navs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NavVo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String navName;</span><br><span class="line">        <span class="keyword">private</span> String navValue;</span><br><span class="line">        <span class="keyword">private</span> String link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long brandId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String brandName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String brandImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AttrVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long attrId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String attrName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; attrValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CatalogVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long catalogId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String catalogName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DSL</p><p>模糊匹配、过滤（属性、分类、品牌、价格区间、库存）</p><p>排序、分页、高亮、聚合分析</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">GET mall_product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [ &#123;<span class="attr">&quot;match&quot;</span>: &#123;  <span class="attr">&quot;skuTitle&quot;</span>: <span class="string">&quot;华为&quot;</span> &#125;&#125; ], # 检索出华为</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [ # 过滤</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;catalogId&quot;</span>: <span class="string">&quot;225&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;brandId&quot;</span>: [ <span class="string">&quot;2&quot;</span>] &#125; &#125;, </span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;hasStock&quot;</span>: <span class="string">&quot;false&quot;</span>&#125; &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;skuPrice&quot;</span>: &#123; # 价格1K~7K</span><br><span class="line">              <span class="attr">&quot;gte&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">              <span class="attr">&quot;lte&quot;</span>: <span class="number">7000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;nested&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;attrs&quot;</span>, # 聚合名字</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;attrs.attrId&quot;</span>: &#123; <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;6&quot;</span>&#125; &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [ &#123;<span class="attr">&quot;skuPrice&quot;</span>: &#123;<span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125; ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;  </span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;<span class="attr">&quot;skuTitle&quot;</span>: &#123;&#125;&#125;, # 高亮的字段</span><br><span class="line">    <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;b style=&#x27;color:red&#x27;&gt;&quot;</span>,  # 前缀</span><br><span class="line">    <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/b&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123; # 查完后聚合</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123; # 子聚合</span><br><span class="line">        <span class="attr">&quot;brandNameAgg&quot;</span>: &#123;  # 每个商品id的品牌</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandName&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      </span><br><span class="line">        <span class="attr">&quot;brandImgAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandImg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;catalogAgg&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;catalogId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;catalogNameAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;catalogName&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;attrs&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;nested&quot;</span>: &#123;<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;attrs&quot;</span> &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;attrIdAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;attrs.attrId&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;attrNameAgg&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;attrs.attrName&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、异步-amp-线程池"><a href="#4、异步-amp-线程池" class="headerlink" title="4、异步&amp;线程池"></a>4、异步&amp;线程池</h1><p>1）、继承 Thread </p><p>2）、实现 Runnable 接口 </p><p>3）、实现 Callable 接口 + FutureTask （可以拿到返回结果，可以处理异常） </p><p>4）、线程池：调度、资源控制</p><p>线程池七大参数：</p><p>核心线程数、最大线程数、超时时间、超时时间单位、阻塞队列，线程工厂、拒绝策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行流程： </span><br><span class="line">1、线程池创建，准备好 core 数量的核心线程，准备接受任务 </span><br><span class="line">2、新的任务进来，用 core 准备好的空闲线程执行。 </span><br><span class="line">  (1) 、core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队 列获取任务执行 </span><br><span class="line">  (2) 、阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量</span><br><span class="line">  (3) 、max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自 动销毁。最终保持到 core 大小 </span><br><span class="line">  (4) 、如果线程数开到了 max 的数量，还有新任务进来，就会使用 reject 指定的拒绝策 略进行处理 </span><br><span class="line">3、所有的线程创建都是由指定的 factory 创建的。</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h2><p>  很多语言，比如 Node.js，采用回调的方式实现异步编程。Java 的一些框架，比如 Netty，自 己扩展了 Java 的 <code>Future</code>接口，提供了<code>addListener</code>等多个扩展方法；Google guava 也提供了 通用的扩展 Future；Scala 也提供了简单易用且功能强大的 Future/Promise 异步编程模式。</p><p>  在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以 通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。 CompletableFuture 类实现了 Future 接口，所以你还是可以像以前一样通过<code>get</code>方法阻塞或 者轮询的方式获得结果，但是这种方式不推荐使用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ 启动异步任务</span><br><span class="line">+ runAsync</span><br><span class="line">+ supplyAsync</span><br><span class="line">+ 完成回调与异常感知</span><br><span class="line">+ whenComplete</span><br><span class="line">+ exceptionally</span><br><span class="line">+ whenCompleteAsync</span><br><span class="line">+ handle最终处理</span><br><span class="line">+ 和 complete 一样</span><br><span class="line">+ 可对结果做最后的处理（可处理异常），可改变返回值</span><br><span class="line">+ 线程串行化方法</span><br><span class="line">+ thenApply</span><br><span class="line">+ thenAccept</span><br><span class="line">+ thenRun</span><br><span class="line">+ 两任务组合</span><br><span class="line">    + 都要完成</span><br><span class="line">    + 一个完成</span><br><span class="line">+ 多任务组合</span><br><span class="line">+ allOf</span><br><span class="line">+ anyOf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——性能压测</title>
      <link href="/2022/02/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%8E%8B%E6%B5%8B/"/>
      <url>/2022/02/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%8E%8B%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1、jvm-内存模型"><a href="#1、jvm-内存模型" class="headerlink" title="1、jvm 内存模型"></a>1、jvm 内存模型</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214153035740.png" alt="image-20220214153035740"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 程序计数器 Program Counter Register： </span><br><span class="line"> + 记录的是正在执行的虚拟机字节码指令的地址， </span><br><span class="line"> + 此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OutOfMemoryError的区域 </span><br><span class="line">+ 虚拟机：VM Stack </span><br><span class="line"> + 描述的是 JAVA 方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法接口等信息</span><br><span class="line"> + 局部变量表存储了编译期可知的各种基本数据类型、对象引用  </span><br><span class="line"> + 线程请求的栈深度不够会报 StackOverflowError 异常  </span><br><span class="line"> + 栈动态扩展的容量不够会报 OutOfMemoryError 异常  </span><br><span class="line"> + 虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈  </span><br><span class="line">+ 本地方法：Native Stack  </span><br><span class="line"> + 本地方法栈类似于虚拟机栈，只不过本地方法栈使用的是本地方法  </span><br><span class="line">+ 堆：Heap </span><br><span class="line"> + 几乎所有的对象实例都在堆上分配内存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145444465.png" alt="image-20220214145444465"></p><h1 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h1><p>所有的对象实例以及数组都要在堆上分配。堆是垃圾收集器管理的主要区域，也被称为“GC堆”；也是我们优化最多考虑的地方。 堆可以细分为： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 新生代 </span><br><span class="line"> + Eden 空间 </span><br><span class="line"> + From Survivor 空间 </span><br><span class="line"> + To Survivor 空间 </span><br><span class="line">+ 老年代</span><br><span class="line">+ 永久代/元空间 </span><br><span class="line"> + Java8 以前永久代，受 jvm 管理，java8 以后元空间，直接使用物理内存。因此， 默认情况下，元空间的大小仅受本地内存限制。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145921888.png" alt="image-20220214145921888"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145742455.png" alt="image-20220214145742455"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145909109.png" alt="image-20220214145909109"></p><h1 id="3、JVM-分析-amp-调优"><a href="#3、JVM-分析-amp-调优" class="headerlink" title="3、JVM 分析&amp;调优"></a>3、JVM 分析&amp;调优</h1><p>Full gc 最会影响性能，根据代码问题，避免 full gc 频率。可以适当调大年轻代容量，让大对象可以在年轻代触发 yong gc，调整大对象在年轻代的回收频次，尽可能保证大对象在年轻代回收，减小老年代缩短回收时间。</p><h1 id="4、压测"><a href="#4、压测" class="headerlink" title="4、压测"></a>4、压测</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214152417181.png" alt="image-20220214152417181"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214152548781.png" alt="image-20220214152548781"></p><p>现阶段优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 中间件</span><br><span class="line"> + nginx 动静分离</span><br><span class="line"> + gateway</span><br><span class="line">+ db</span><br><span class="line"> + 索引</span><br><span class="line"> + 操作</span><br><span class="line">+ log</span><br><span class="line">+ redis</span><br><span class="line">+ page cache</span><br><span class="line">+ jvm内存</span><br><span class="line">+ 业务流程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——分布式基础-全栈开发篇</title>
      <link href="/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1、写在前面"><a href="#1、写在前面" class="headerlink" title="1、写在前面"></a>1、写在前面</h1><p>仿京东商城大型分布式架构电商平台：微服务架构+分布式+全栈+集群+部署+自动化运维+可视化CICD</p><p>Gitee仓库：<a href="https://gitee.com/namdev/gulimall">https://gitee.com/namdev/gulimall</a></p><p>后台接口文档：<a href="https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd">https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd</a></p><p>b站视频地址：<a href="https://www.bilibili.com/video/BV1np4y1C7Yf">全网最强电商教程《谷粒商城》对标阿里P6/P7，40-60万年薪</a></p><h1 id="2、架构"><a href="#2、架构" class="headerlink" title="2、架构"></a>2、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201439633.png" alt="image-20220212201439633"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201228064.png" alt="image-20220212201228064"></p><h1 id="3、基础环境"><a href="#3、基础环境" class="headerlink" title="3、基础环境"></a>3、基础环境</h1><p>linux、docker</p><p>数据库</p><p>人人后台</p><p>分布式组件</p><h1 id="4、商品、订单、仓库服务后台"><a href="#4、商品、订单、仓库服务后台" class="headerlink" title="4、商品、订单、仓库服务后台"></a>4、商品、订单、仓库服务后台</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211040144.png" alt="image-20220212211040144"></p><h2 id="pms库"><a href="#pms库" class="headerlink" title="pms库"></a>pms库</h2><p>Attr：属性表</p><p>Attr_group：属性分组表</p><p>Attr_attrgroup_relation：属性分组关联表</p><p>Product_attr_value：商品id属性值表</p><p>Spu_info：商品spu</p><p>Sku_info：商品sku</p><p>Sku_images：商品sku图片</p><p>Sku_sale_attr_values：商品sku销售属性值</p><p>三级分类——属性分组——属性</p><p>属性——商品（spu）属性集——商品型号（sku）属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211136464.png" alt="image-20220212211136464"></p><h2 id="保存商品"><a href="#保存商品" class="headerlink" title="保存商品"></a>保存商品</h2><p>Spu_info：基本信息</p><p>Spu_info_desc：id + 描述图片</p><p>Spu_images：id + 图片集</p><p>Product_attr_value：spu规格参数 spuid + 属性值</p><p>Spu_bounds：商品积分 （sms库）</p><p>Sku_info：sku基本信息 + spuid</p><p>Sku_images：skuid + sku图片信息</p><p>Sku_sale_attr_value：sku销售属性 skuid + 属性值</p><p>Sku优惠满减信息（sms库）：skuid</p><p>Sku_ladder：打折表</p><p>Sku_full_reduction：满减表</p><p>Member_price：会员价格表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211157512.png" alt="image-20220212211157512"></p><h2 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h2><p>单表、多表、多库、远程调用、属性拷贝等暂时省略</p><h1 id="5、jsr303校验"><a href="#5、jsr303校验" class="headerlink" title="5、jsr303校验"></a>5、jsr303校验</h1><p>开启校验（错误返回） + bean校验注解</p><p>统一异常处理</p><p>枚举类</p><p>jsr303分组校验</p><p>jsr303自定义校验注解</p><h1 id="5、object"><a href="#5、object" class="headerlink" title="5、object"></a>5、object</h1><p>1.PO(persistant object) 持久对象 </p><p>PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 </p><p>2.DO（Domain Object）领域对象就是从现实世界中抽象出来的有形或无形的业务实体。 </p><p>3.TO(Transfer Object) 数据传输对象</p><p>不同的应用程序之间传输的对象 </p><p>4.DTO（Data Transfer Object）数据传输对象</p><p>这个概念来源于 J2EE 的设计模式，原来的目的是为了 EJB 的分布式应用提供粗粒度的 数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。 </p><p>5.VO(value object) 值对象 </p><p>通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已。但应是抽象出 的业务对象 , 可以和表对应 , 也可以不 , 这根据业务的需要 。用 new 关键字创建，由 GC 回收的。 View object：视图对象； 接受页面传递来的数据，封装对象将业务处理完成的对象，封装成页面要用的数据 </p><p><strong>6.BO(business object)</strong> <strong>业务对象</strong> </p><p>从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 </p><p>java 对 象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。business object: 业务对象主要作 用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简 历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经 历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。</p><p>7.POJO(plain ordinary java object) 简单无规则 java 对象 </p><p>传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护 数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增 加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及 setter 和 getter 方法！。POJO 是 DO/DTO/BO/VO 的统称。 </p><p>8.DAO(data access object) 数据访问对象 </p><p>是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久 层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作.</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——金融业务平台</title>
      <link href="/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/"/>
      <url>/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/</url>
      
        <content type="html"><![CDATA[<h1 id="1、产品架构"><a href="#1、产品架构" class="headerlink" title="1、产品架构"></a>1、产品架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207192011048.png" alt="image-20220207192011048"></p><h1 id="2、业务流程"><a href="#2、业务流程" class="headerlink" title="2、业务流程"></a>2、业务流程</h1><p>1、账户绑定</p><p>（用户表、用户绑定表）</p><p>用户——绑定信息提交（借款、出借）——调用第三方托管平台账户创建（阿里云短信）——绑定完成（异步更新）</p><p>2、申请借款额度</p><p>（用户表、积分表、借款人表、借款人图片表）垂直分表</p><p>提交借款人个人信息（身份证等证件资源：对象存储）——后台系统评估——审核通过——获取额度</p><p>3、借款额度审核</p><p>后台借款额度申请列表——借款人信息——借款额度审核</p><p>4、借款申请</p><p>（借款信息表、积分等级配置表、标的准备表）</p><p>获取借款额度（用户积分）——提交借款申请——获取借款申请状态</p><p>5、借款审核</p><p>后台借款信息列表——借款详情——借款审批</p><p>6、标的管理</p><p>（标的表）</p><p>审核完成——新标的、标的详情、标的列表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207194625467.png" alt="image-20220207194625467"></p><p>7、我要投资</p><p>前端标的列表</p><p>8、充值</p><p>（用户账号表[余额等]、交易流水表）</p><p>注册 + 账户绑定——充值——第三方托管支付——完成（异步修改）</p><p>幂等性保证（重复请求）：判断流水是否存在，存在则退出</p><p>9、投标</p><p>收益根据还款方式：等额本息、等额本金、按期付息到期还本、一次还本付息</p><p>（标的表、标的出借记录表、还款记录表、标的出借回款记录表）标的id</p><p>标的详情——输入金额计算收益——投标支付——完成（异步回调：标的状态、投资流水、金额、标的信息）</p><p>10、放款</p><p>（还款人还款记录表、投资人回款记录表）</p><p>管理平台放款——（1）标的状态和标的平台收益（2）<strong>给借款账号转入金额</strong>（3）增加借款交易流水（4）<strong>解冻并扣除投资人资金</strong>（5）增加投资人交易流水（6）生成借款人还款计划和出借人回款计划</p><p>11、投资列表展示</p><p>后台列表——前台列表——后台还款计划——前台还款计划——前台回款计划</p><p>12、提现和还款</p><p>第三方托管提现</p><p>还款——转出金额——分配转入投资方——流水明细、回款明细</p><p>13、个人中心</p><p>流水明细、用户账号明细</p><p>14、消息队列</p><p>监听消息队列发送短信（充值、绑定、转出等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/27528777bac0634fd778ca60094057b4.png" alt="27528777bac0634fd778ca60094057b4"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——MongoDB、业务流程</title>
      <link href="/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/"/>
      <url>/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<h1 id="1、架构"><a href="#1、架构" class="headerlink" title="1、架构"></a>1、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222116806.png" alt="image-20220206222116806"></p><h1 id="2、MongoDB"><a href="#2、MongoDB" class="headerlink" title="2、MongoDB"></a>2、MongoDB</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于分布式文件存储的开源数据库系统</p><p>字段值可以包含其他文档，数组及文档数组。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222409680.png" alt="image-20220206222409680"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MongoDB 是一个面向文档存储的数据库</p><p>MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序</p><p>可以通过本地或者网络创建数据镜像，实现高扩展性</p><p>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上，分片</p><p>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>1、网站数据、大数据、缓存</p><p>2、高伸缩性</p><p>3、对象、json数据</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>MongoTemplate</p><p>MongoRepository（SpringData方法定义规范）</p><h1 id="3、预约挂号业务"><a href="#3、预约挂号业务" class="headerlink" title="3、预约挂号业务"></a>3、预约挂号业务</h1><p>1、排班和挂号详情信息——【医院+科室——规则——日期——排班、挂号信息】</p><p>2、确认挂号信息——【就诊人、排班信息】</p><p>3、生成预约挂号订单【就诊人 + 排班 —— 生成订单】</p><p>4、挂号订单支付（微信）【微信支付、订单状态】</p><p>5、取消预约订单【退款、取消订单】</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206221759069.png" alt="image-20220206221759069"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——前后端分离+微服务</title>
      <link href="/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1、MP"><a href="#1、MP" class="headerlink" title="1、MP"></a>1、MP</h1><p>基本流程</p><p>主键自动生成</p><p>自动填充</p><p>乐观锁实现</p><p>select、分页</p><p>delete：逻辑删除、物理删除</p><p>mp性能分析插件</p><p>条件查询Querywrapper</p><h1 id="2、后端1"><a href="#2、后端1" class="headerlink" title="2、后端1"></a>2、后端1</h1><p>json时区</p><p>swagger测试</p><p>统一返回格式</p><p>@requestbody</p><p>统一、指定、自定义异常处理</p><p>日志输出、日志级别</p><h1 id="3、前端1"><a href="#3、前端1" class="headerlink" title="3、前端1"></a>3、前端1</h1><p>es6语法：</p><p>数组解构、对象赋值、模拟字符串、对象方法、箭头函数</p><p>vue指令、组件</p><p>vue生命周期：</p><p>Create、Mounted</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220205230634449.png" alt="image-20220205230634449"></p><p>断点</p><p>Vue路由</p><p>Axios</p><p>Element-ui</p><p>Node.js</p><p>npm</p><p>Babel</p><p>前端模块化</p><p>Webpack</p><p>vue-admin-template、目录结构</p><p>跨域</p><p>路由切换</p><p><strong>开发流程</strong></p><p>服务端渲染技术</p><p>NUST框架</p><h1 id="4、oss、视频点播、短信、微信支付、微信注册"><a href="#4、oss、视频点播、短信、微信支付、微信注册" class="headerlink" title="4、oss、视频点播、短信、微信支付、微信注册"></a>4、oss、视频点播、短信、微信支付、微信注册</h1><p>阿里云对象存储</p><p>阿里云视频点播：上传、播放、删除</p><p>阿里云短信服务</p><p>微信支付</p><p>微信注册</p><h1 id="5、后端2"><a href="#5、后端2" class="headerlink" title="5、后端2"></a>5、后端2</h1><p>nginx</p><p>EasyExcel读写</p><p>Vue tree</p><p>vo</p><p>bean转换</p><p>树形结构：遍历、循环</p><p>路由、隐藏路由、动态路由</p><p>富文本编辑器</p><p>多表联查——SQL</p><p>openfeign、nacos</p><p>远程调用流程：</p><p>1、接口化请求调用</p><p>2、Feign</p><p>3、Hystrix</p><p>4、Ribbon</p><p>5、Httpclient</p><h1 id="6、后端3"><a href="#6、后端3" class="headerlink" title="6、后端3"></a>6、后端3</h1><p>redis缓存：</p><p>Cacheable、Cacheput、Cacheevict</p><p>sso单点登录</p><p>jwt：json web token</p><p>1、jwt头信息</p><p>2、有效载荷</p><p>3、签名哈希</p><p>sso实现：</p><p>1、session复制</p><p>2、Cookie带着唯一key在中redis 查询 </p><p>3、Token：用户信息加密成的字符串（自包含令牌）</p><p>（1）cookie 或者 地址栏</p><p>（2）访问时携带字符串</p><p>Reids过期时间、token过期时间 均可设置过期</p><p>密码加密：</p><p>1、MD5工具类</p><p>2、密码加密和数据库比较</p><p>token解析</p><h1 id="7、前端2"><a href="#7、前端2" class="headerlink" title="7、前端2"></a>7、前端2</h1><p>二维码</p><p>定时器</p><p>token实现：</p><p>(1) 登录返回token</p><p>(2) Token放到cookie中</p><p>(3) 前端拦截器（请求拦截）：判断cookie是否有token，把token放到请求头中</p><p>(4) 根据请求头的token获取用户信息，用户信息放到cookie中</p><p>(5) 显示用户信息</p><p>验证——获得token（放到cookie）——拦截：获取token放到header——调用api获取用户信息（放到cookie）</p><p>cookie：json字符串转为json对象</p><p>OAuth2</p><p>微信登录：</p><p>1、使用httpclient发送get请求（工具类 + 依赖）</p><p>2、从json字符串获取值（转为map）</p><p>3、再请求一个地址，获取扫码人信息</p><p>4、自动注册（未注册）</p><p>token路径传递</p><p>1、通过路径获取token</p><p>以下同前面</p><p>2、Token——cookie、拦截器：token——header</p><p>存在cookie中是因为有拦截器会将cookie中的token存到header中，后端也是从hader中取token的，cookie相当于转存的介质</p><p>3、Token + header = member——cookie</p><p>播放器组件</p><p>评论组件</p><p>微信支付：</p><p>(1) 生成订单</p><p>① 根据课程id获取课程信息——远程调用</p><p>② 根据用户id（jwt从header获取id）获取用户信息——远程调用</p><p>(2) 根据id查询订单信息</p><p>(3) 生成微信支付二维码</p><p>① 、获取订单参数</p><p>②、发送httpclient请求（参数xml）</p><p>③、获取返回结果</p><p>(4) 查询支付状态</p><p>①Service——发送httpclient请求——返回包含状态</p><p>②添加支付记录，更改订单状态</p><p>③定时器</p><p>根据Url下载二维码组件</p><p>Echarts</p><p>定时任务</p><h1 id="8、后端4"><a href="#8、后端4" class="headerlink" title="8、后端4"></a>8、后端4</h1><p>canal数据同步</p><p>Gateway：路由、断言、过滤器</p><p>权限管理</p><p>权限关系表</p><p>递归分级</p><p>SpringSecurity</p><p>nacos配置中心</p><h1 id="9、Jenkins"><a href="#9、Jenkins" class="headerlink" title="9、Jenkins"></a>9、Jenkins</h1><p>Jenkins、github action</p><h1 id="10、产品开发流程"><a href="#10、产品开发流程" class="headerlink" title="10、产品开发流程"></a>10、产品开发流程</h1><p>1、需求调研（产品经理）</p><p>2、需求评审（产品/设计/前端/后端/测试/运营）</p><p>3、立项（项目经理、品管）</p><p>4、UI设计</p><p>5、开发</p><p>· 架构、数据库设计、API文档、MOCK数据、开发、单元测试</p><p>· 前端</p><p>· 后端</p><p>6、前端后端联调</p><p>7、项目提测：黑盒白盒、压力测试（qps）  loadrunner</p><p>8、bug修改</p><p>9、回归测试</p><p>10、运维和部署上线</p><p>11、灰度发布</p><p>12、全量发布</p><p>13、维护和运营</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mycat</title>
      <link href="/2022/01/28/Mycat/"/>
      <url>/2022/01/28/Mycat/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><p>① Java与数据库紧耦合。 </p><p>② 高访问量高并发对数据库的压力。 </p><p>③ 读写请求数据不一致</p><p>对比：<img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195056298.png" alt="image-20220128195056298"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>读写分离：配合主从复制、主备模式</p><p>数据分片：分库分表</p><p>多数据源整合</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195358045.png" alt="image-20220128195358045"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>拦截</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195439600.png" alt="image-20220128195439600"></p><p>三个重要配置文件</p><p>1、逻辑库、表、分片节点</p><p>2、分片规则</p><p>3、用户、系统配置</p><h1 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h1><p>Myqsl：从接入点开始复制</p><h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><p>日志格式</p><p>balance属性：读写分离</p><p>复制原理：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195544208.png" alt="image-20220128195544208"></p><h2 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h2><p>主备切换</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195329105.png" alt="image-20220128195329105"></p><h1 id="3、分库分表"><a href="#3、分库分表" class="headerlink" title="3、分库分表"></a>3、分库分表</h1><h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195834488.png" alt="image-20220128195834488"></p><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><p>多表联查</p><p>全局表：全局一致性（广播）</p><p>常用分片规则：</p><p>取模、分片枚举、范围约定、日期</p><h2 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h2><p>1、本地文件</p><p>2、时间戳</p><p>3、数据库方式</p><p>4、reids、雪花算法等</p><h1 id="4、基于HA机制的Mycat高可用"><a href="#4、基于HA机制的Mycat高可用" class="headerlink" title="4、基于HA机制的Mycat高可用"></a>4、基于HA机制的Mycat高可用</h1><p>Mycat集群保证数据库高可用</p><p>haproxy保证mycat高可用（负载均衡）</p><p>Keepalived保证haproxy高可用（创建虚拟ip）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200457657.png" alt="image-20220128200457657"></p><p>安全权限</p><p>user、privileges、sql拦截</p><h1 id="6、监控"><a href="#6、监控" class="headerlink" title="6、监控"></a>6、监控</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200635053.png" alt="image-20220128200635053"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mycat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2022/01/27/RocketMQ/"/>
      <url>/2022/01/27/RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h2><p>限流削峰（请求存在队列中）</p><p>异步解耦</p><p>数据采集</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213121974.png" alt="image-20220127213121974"></p><h2 id="MQ常见协议"><a href="#MQ常见协议" class="headerlink" title="MQ常见协议"></a>MQ常见协议</h2><p>JMS</p><p>STOMP</p><p>AMQP</p><p>MQTT</p><h1 id="2、RocketMQ"><a href="#2、RocketMQ" class="headerlink" title="2、RocketMQ"></a>2、RocketMQ</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>消息、主题、标签、队列、消息标识（消息唯一id：生产者、broker）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213610678.png" alt="image-20220127213610678"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213633953.png" alt="image-20220127213633953"></p><p>生产者</p><p>消费者</p><p>（一个消费者组，消费者消费队列不同）</p><p>Name Server（注册中心）：broker管理、路由信息管理</p><p>路由注册、路由剔除（心跳包）、路由发现、选择策略：轮询</p><p>broker</p><p>组成：实体、客户端管理、存储、高可用（集群数据同步）、索引（ID）</p><p>集群部署：主备集群</p><p>主从、主备</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213923298.png" alt="image-20220127213923298"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>1、启动server、监听端口</p><p>2、Broker与serve长连接</p><p>3、创建topic</p><p>4、生产者发送消息：和server建立连接，获取路由（topic、broker）。</p><p>与broker长连接，向broker发送消息。路由信息每30s缓存在本地。</p><p>5、消费者，server连接，获取路由。与broker长连接，消费。</p><p>Consumer发送心跳，确认broker存活状态。</p><h3 id="Topic的创建模式"><a href="#Topic的创建模式" class="headerlink" title="Topic的创建模式"></a>Topic的创建模式</h3><p>集群、broker模式</p><h3 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h3><p>一般情况数量一样</p><p>设计目的：方便topic的缩容</p><p>写队列先缩容，读队列消费完后再缩容，不丢失任何消息。</p><h2 id="集群搭建理论"><a href="#集群搭建理论" class="headerlink" title="集群搭建理论"></a>集群搭建理论</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214305521.png" alt="image-20220127214305521"></p><h3 id="数据复制与刷盘策略"><a href="#数据复制与刷盘策略" class="headerlink" title="数据复制与刷盘策略"></a>数据复制与刷盘策略</h3><p>生产者、消费者：groupname相同即可</p><p>Nameserver集群：相互不通信，启动即可</p><p>Broker集群：多个主备小集群</p><p>数据复制：master向slave复制</p><h3 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h3><p>刷盘：由内存写入到磁盘</p><p>同步、异步复制（ACK时机）</p><p>同步：slave成功后ack</p><p>异步：master写入后ack</p><h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p>同步、异步刷盘</p><p>同步：broker写入磁盘ack</p><p>异步：broker写入内存ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214313364.png" alt="image-20220127214313364"></p><p>多master集群：宕机后无法消费</p><h3 id="多master多slave集群"><a href="#多master多slave集群" class="headerlink" title="多master多slave集群"></a>多master多slave集群</h3><p>一个master一个slave：主备模式</p><p>Master处理消息读写</p><p>Slave负责消息备份和宕机后的自动切换</p><p>最好使用RAID阵列</p><p>同步双写：同步复制</p><p>安全性最高，RT响应时间长</p><p>Slave不能自动切换</p><p>RAID10磁盘阵列 + 异步复制</p><h2 id="磁盘阵列RAID"><a href="#磁盘阵列RAID" class="headerlink" title="磁盘阵列RAID"></a>磁盘阵列RAID</h2><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h1 id="3、RocketMQ的工作原理"><a href="#3、RocketMQ的工作原理" class="headerlink" title="3、RocketMQ的工作原理"></a>3、RocketMQ的工作原理</h1><h2 id="消息的生产"><a href="#消息的生产" class="headerlink" title="消息的生产"></a>消息的生产</h2><p>1、生产者向servre发送请求，获取topic路由</p><p>2、Server返回topic路由表及broker列表</p><p>（1）路由表：map&lt;topic,queuedata&gt;，queuedata：broker——queue</p><p>找到queue对应的broker</p><p>（2）Broker列表</p><p>3、选择queue</p><p>4、生产者对消息特殊处理</p><p>5、生产者向broker发出RPC请求，发送到queue（底层netty）</p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><p>轮询（问题：性能）、最小投递延迟（问题：分配不均）</p><h2 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h2><h3 id="store目录"><a href="#store目录" class="headerlink" title="store目录"></a>store目录</h3><p>刷盘、消息、配置、队列、消息索引、全局资源锁</p><h3 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h3><p>第n个文件名：前n-1个文件大小之和</p><p>消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214852355.png" alt="image-20220127214852355"></p><h3 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h3><p>消费队列</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214940291.png" alt="image-20220127214940291"></p><p>索引条目：</p><p>是commitlog的索引文件——定位具体消息</p><p>消息条目——偏移量、消息长度、消息tag</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215015213.png" alt="image-20220127215015213"></p><h3 id="对文件的读写"><a href="#对文件的读写" class="headerlink" title="对文件的读写"></a>对文件的读写</h3><p>消息写入</p><p>1、根据queueid，得到comsumequeue要写入的偏移量</p><p>2、封装消息单元</p><p>3、写入commitlog</p><p>4、形成索引条目</p><p>消息拉取</p><p>1、获取所在queue的偏移量</p><p>2、发送broker拉取请求，queue等信息</p><p>3、得到consumequeue中位置</p><p>4、查找指定tag索引</p><p>5、定位commitlog</p><p>6、读取其中的消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215053467.png" alt="image-20220127215053467"></p><p>性能提升：</p><p>文件读写：通过mmap零拷贝</p><p>Comsuequeue读取：</p><p>引入pagecache预读取机制，接近内存读取（顺序读写）</p><p>本质：缓存</p><p>写：先写入pagecache，再异步写入磁盘</p><p>读：首先读pagecache，若没有命中，将磁盘数据加载到pacache，同时对相邻数据预读取</p><p>Commitlog读取：随机访问，会影响性能</p><p>与kafka对比：</p><p>RocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。</p><p>mappedFile文件就类似于Kafka中的segment段</p><h2 id="indexfile"><a href="#indexfile" class="headerlink" title="indexfile"></a>indexfile</h2><p>根据key进行消息查询（前提：消息包含key）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215235908.png" alt="image-20220127215235908"></p><p>Indexheader：该索引索引相关信息（数量，偏移量等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215241833.png" alt="image-20220127215241833"></p><p>Slot</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215249106.png" alt="image-20220127215249106"></p><p>Index</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215257689.png" alt="image-20220127215257689"></p><p>创建</p><p>indexfile查询流程：</p><p>1、根据key、time找到indexfile</p><p>2、传入时间与文件名差值</p><p>3、计算key的hash——Slot序号——读取slot——最新的indexNo</p><p>4、根据indexN找到index位置</p><p>5、相比Index中的diff</p><p>（1）若时间差小，往前找</p><p>（2）若时间差大，index中定位位置，找到消息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215406692.png" alt="image-20220127215406692"></p><h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><h3 id="两种消息获取方式"><a href="#两种消息获取方式" class="headerlink" title="两种消息获取方式"></a>两种消息获取方式</h3><p>Push（consumer主动拉取），注意拉取时间间隔</p><p>pull（broker主动推动，实时性高），向queue注册监听器，基于长连接</p><h3 id="两种消息消费模式"><a href="#两种消息消费模式" class="headerlink" title="两种消息消费模式"></a>两种消息消费模式</h3><p>广播模式：每个消费者都接收topic全部消息</p><p>集群模式：消费者平分消息</p><h3 id="消息进度保存"><a href="#消息进度保存" class="headerlink" title="消息进度保存"></a>消息进度保存</h3><p>广播模式：消费者保存</p><p>集群模式：保存broker中共享，消息进度参与负载均衡</p><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>Queue和consumer的之间重新分配</p><p>增加减少消费者，提升消息并行</p><p>消费者要小于队列</p><p>危害：</p><p>消息暂停：重分配后才能再消费</p><p>消费重复：异步提交，导致可能重复消费</p><p>一次性读取消息数量需要均衡：重复消费、性能</p><p>消息突刺：重复消费过多消息、积压时间过长</p><p>产生的原因和过程</p><p>1、Queue数量变化</p><p>（1）broker扩缩容</p><p>（2）Broker升级运维</p><p>（3）网络异常</p><p>（4）Queue扩缩容</p><p>2、消费者数量变化</p><p>（1）consumergroup扩缩容</p><p>（2）Consumer升级运维</p><p>（3）网络异常</p><p>过程：</p><p>Broker发现变化，向consumergroup发出Rebalance通知</p><p>Consumer采用分配算法，自主进行Rebalance</p><p>Broker中group coordinate选举consumer leader</p><p>由lerder完成分区的再分配，上报coordinate，coordinate同步给consumer实例</p><p>Kafka的Rebalance由选举的comsumer leader完成。</p><p>Rocket的Rebalance由每个consumer完成</p><p>Queue分配算法</p><p>平均分配</p><p>环形平均策略：类似轮询</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215711998.png" alt="image-20220127215711998"></p><p>一致性hash策略：先把consumer放到环上，再把queue的hash值放环上，顺时针找consumer （缺点：分配不均）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215721201.png" alt="image-20220127215721201"></p><p>同机房策略</p><p>一致性hash：减少扩缩容的rebalance</p><p>扩缩容需要rebalance，变化较大</p><p>一致性hash扩缩容变化较小：应用场景，consumer变化较多</p><p>至少一次原则</p><h2 id="订阅关系的一致性"><a href="#订阅关系的一致性" class="headerlink" title="订阅关系的一致性"></a>订阅关系的一致性</h2><h2 id="offset管理"><a href="#offset管理" class="headerlink" title="offset管理"></a>offset管理</h2><p>Consumer的消费进度offset</p><h3 id="Offset本地管理"><a href="#Offset本地管理" class="headerlink" title="Offset本地管理"></a>Offset本地管理</h3><p>广播，消费进度保存在consumer中</p><h3 id="Offset远程管理"><a href="#Offset远程管理" class="headerlink" title="Offset远程管理"></a>Offset远程管理</h3><p>集群消费，保存在broker文件中</p><p>所有consumer共享queue的消费进度</p><p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制</p><p>Rebalance后，新的consumer可以读取相应消费进度继续消费</p><p>NextBeginOffset：下次消费起始</p><p>消费异常：异常消息提交broker的重试队列</p><p>同步、异步提交offset</p><p>异步：提交offset、无需等待broker响应，直接从broker获取next</p><h2 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h2><h3 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h3><p>重复消费影响相同</p><p>1、发送重复：Broker对生产者ack失败，生产者重复发送相同消息（msgid相同）</p><p>2、消费重复：consumer对broker的ack失败，broker再次投递相同消息</p><p>3、Rebalance：consumer、queue变化，没提交ack前Rebalance可能重复消费</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>幂等令牌：具备唯一业务表示的字符串，唯一id</p><p>唯一性处理：服务端采用算法，保证成功执行一次</p><p>1、通过缓存去重，缓存是否命中幂等令牌</p><p>2、数据库查询是否有幂等令牌（缓存可能过期）</p><p>3、同一事务中：唯一性处理、幂等令牌写入缓存，幂等令牌写入DB</p><h3 id="支付场景中的解决方案"><a href="#支付场景中的解决方案" class="headerlink" title="支付场景中的解决方案"></a>支付场景中的解决方案</h3><p>1、首先redis获取流水号</p><p>（1）不为空，调用重复逻辑</p><p>2、无缓存，查询DB</p><p>（1）不为空，调用重复逻辑</p><p>3、为空，在分布式事务完成</p><p>（1）完成支付</p><p>（2）流水号作为key，存入redis（过期时间）</p><p>（3）流水号作为主键存入DB</p><p>消费幂等的实现</p><p>最好以业务唯一标识作为依据</p><h2 id="消息堆积与消费延迟"><a href="#消息堆积与消费延迟" class="headerlink" title="消息堆积与消费延迟"></a>消息堆积与消费延迟</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220321282.png" alt="image-20220127220321282"></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>消费速度跟不上生产速度</p><p>1、上下游能力不匹配</p><p>2、实时性要求较高，延迟造成堆积</p><p>长轮询PULL模式</p><p>1、消息拉取：批量拉取，缓存到本地缓存队列</p><p>2、消息消费：取决于消费并发、消费耗时度</p><p>本地缓存队列达到上限，停止从服务端拉取消息</p><h3 id="消费耗时的深入分析"><a href="#消费耗时的深入分析" class="headerlink" title="消费耗时的深入分析"></a>消费耗时的深入分析</h3><p>主要耗时：外部IO代码</p><p>1、mysql 、redis访问</p><p>2、下游系统调用:dubbo的RPC远程调用、springcloud的http接口调用</p><p>下游系统服务异常等原因</p><p>消息堆积——消息消费——消息耗时——外部IO——下游DB、RPC、http调用——服务异常、容量限制——网络宽带等</p><h3 id="消息并发度的深入分析"><a href="#消息并发度的深入分析" class="headerlink" title="消息并发度的深入分析"></a>消息并发度的深入分析</h3><p>普通消息 并发度 = 单节点线程数 * 节点数（consumer）</p><p>顺序消息：topic的queue分区数量</p><p>全局顺序消息</p><p>分区顺序消息</p><p>单机线程数的计算</p><h3 id="避免消息堆积与消费延迟"><a href="#避免消息堆积与消费延迟" class="headerlink" title="避免消息堆积与消费延迟"></a>避免消息堆积与消费延迟</h3><p>消费耗时</p><p>1、避免循环、递归</p><p>2、IO操作是否可以本地缓存</p><p>3、是否可以异步化处理</p><p>设置消费并发度</p><h2 id="消息的清理"><a href="#消息的清理" class="headerlink" title="消息的清理"></a>消息的清理</h2><p>以commitlog为单位进行清理</p><p>文件过期、磁盘占用率</p><h1 id="4、RocketMQ的应用"><a href="#4、RocketMQ的应用" class="headerlink" title="4、RocketMQ的应用"></a>4、RocketMQ的应用</h1><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>同步发送消息：收到ack后继续发送</p><p>1、创建生产者、group名称</p><p>2、Nameserver配置</p><p>3、开启生产者，发送消息</p><p>4、关闭生产者</p><p>SendResult：状态、msgid</p><p>异步发送消息：无需等待mq的ack消息，发送的回调接口异步响应</p><p>指定回调函数</p><p>单向发送消息：不接收ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220358071.png" alt="image-20220127220358071"></p><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>顺序消息：</p><p>严格按发送顺序进行消费——只有一条queue——一个消费者消费</p><p>相同订单号消息放到同一queue中</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220514365.png" alt="image-20220127220514365"></p><h3 id="消息有序性的分类"><a href="#消息有序性的分类" class="headerlink" title="消息有序性的分类"></a>消息有序性的分类</h3><p>全局有序：只有一个queue</p><p>分区有序</p><p>生产者可以指定queue选择器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220623422.png" alt="image-20220127220623422"></p><h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>指定时长后才可被处理：实现定时任务</p><p>发送延迟消息：过时且判断未支付，放回票池</p><h3 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220640775.png" alt="image-20220127220640775"></p><p>1、先发给延迟topic延迟队列</p><p>2、根据定时管理器，时间到了——发送给commitlog——正常消息</p><p>写入commitqueue</p><p>原本Tage的hashcode改为消息投递时间（定时结束时间）</p><h3 id="再次投递"><a href="#再次投递" class="headerlink" title="再次投递"></a>再次投递</h3><p>1、定时管理器中有相应timertask——负责消息消费和投递</p><p>2、检测相应queue中第一条消息是否到期</p><p>3、若到期，投递</p><p>管理器作为生产者，重新写入commitlog</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220802767.png" alt="image-20220127220802767"></p><p>1、TM向TC发指令，开启全局事务</p><p>2、工行给TC发送事务消息M</p><p>3、TC给broker发送半事务消息（预提交）</p><p>4、Broker预提交返回执行结果</p><p>（1）失败——TC——TM，全局事务结束</p><p>5、成功——调用——预扣款——返回执行结果（本地事务）——TC——TM</p><p>（1）预扣款成功——commit——TC——broker（branch commit）——M可被建行看到</p><p>（2）预扣款失败——rollback——TC——broker（branch rollback）</p><h3 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h3><p>事务消息</p><p>半事务消息：暂不能被消费者看到</p><p>本地事务状态：生产者回调操作执行的结果——TC——TM——全局事务确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220933007.png" alt="image-20220127220933007"></p><p>消息回查：重新查看本地事务的执行状态</p><p>（1）状态（UNKNOWN）</p><p>（2）TC未收到TM的最终全局事务确认指令</p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>XA：分布式事务处理模式</p><p>三剑客</p><p>（1）TC：事务协调者（broker）维护全局事务</p><p>（2）TM：事务管理器（生产者）全局事务发起者</p><p>（3）RM：资源管理器（生产者、broker）报告事务状态</p><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221048552.png" alt="image-20220127221048552"></p><p>1、TM向TC发指令开启全局事务</p><p>2、RM向TC注册分支事务，TC——RM——预执行</p><p>3、RM执行结果返回，TC汇总结果——TM</p><p>（1）global commit——TC——RM</p><p>（2）Global rollback——TC——RM</p><p>事务消息：同步的，先broker再生产者</p><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>Topic、刷盘策略一样</p><p>不能是延时、事务消息</p><p>消息——字符串：topic、body、日志、properties相关属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221147787.png" alt="image-20220127221147787"></p><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>默认一次拉取32条消息</p><p>默认最大一次消费32条</p><p>分割器</p><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>tag过滤</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221233544.png" alt="image-20220127221233544"></p><p>SQL过滤：Properties中的属性，支持运算符</p><h2 id="消息重试机制"><a href="#消息重试机制" class="headerlink" title="消息重试机制"></a>消息重试机制</h2><h3 id="发送-1"><a href="#发送-1" class="headerlink" title="发送"></a>发送</h3><p>1、同步异步会重试，单向无法重试（只管发送）</p><p>2、顺序消息没有重试</p><p>3、可能消息重复、重复消息（负载变化、网络原因）</p><p>4、发送重试策略：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</p><p>同步发送失败</p><p>失败隔离：选择不同broker</p><p>异步发送失败</p><p>消息刷盘失败策略：刷盘失败，默认不会发送到其他broker</p><h3 id="消费-1"><a href="#消费-1" class="headerlink" title="消费"></a>消费</h3><p>顺序消息消费重试：不断重试直至消费成功</p><p>广播消费：消费失败——无消费重试</p><p>若重复完仍然失败——死信队列</p><p>需要重试消费的消息——&gt;重试队列（基于延时消息实现）</p><p>消息监听接口配置</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列：处理异常消息</p><p>详见RabbitMQ</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/01/25/RabbitMQ/"/>
      <url>/2022/01/25/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>消息队列</p><p>流量削峰</p><p>应用解耦：上游只需发送消息</p><p>异步处理：异步处理回调消息</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><p>生产者、交换机、队列、消费者</p><h2 id="六大核心模式"><a href="#六大核心模式" class="headerlink" title="六大核心模式"></a>六大核心模式</h2><p>简单、工作队列、发布订阅、路由、主题、发布确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223147422.png" alt="image-20220125223147422"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>Broker</strong></p><p><strong>Virtual host</strong></p><p><strong>Connection</strong></p><p><strong>Channel</strong></p><p><strong>Exchange</strong></p><p><strong>Queue</strong></p><p><strong>Binding</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223250580.png" alt="image-20220125223250580"></p><h1 id="2、核心"><a href="#2、核心" class="headerlink" title="2、核心"></a>2、核心</h1><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><strong>轮询</strong>分发消息</p><p>消息应答：消费者是否处理消息</p><p>自动应答、手动应答（批量应答）</p><p>消息自动重新入队</p><p>rabbitmq持久化：队列持久化、消息持久化</p><p>不公平分发</p><p>预取值：通道中堆积消息个数</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>单个确认发布</p><p>批量确认发布</p><p>异步确认发布：异步通知——交换机确认收到、未确认收到</p><p>并发链路式队列——发消息和监听线程之间传递消息——本质：map</p><p>1、发送消息时进记录队列</p><p>2、确认回调再删除</p><p>未删除的——未确认消息</p><p>跳表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224155047.png" alt="image-20220125224155047"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224048175.png" alt="image-20220125224048175"></p><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p><p>无名 exchange</p><p>临时队列</p><p>bindings</p><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h3><p>广播：路由key为空</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224517818.png" alt="image-20220125224517818"></p><h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>发送路由key对应队列——无论队列个数</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224644373.png" alt="image-20220125224644373"></p><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p>没有*和#：fanout、direct模式</p><p>*(星号)可以代替一个单词</p><p>#(井号)可以替代零个或多个单词</p><h1 id="3、高级"><a href="#3、高级" class="headerlink" title="3、高级"></a>3、高级</h1><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>发送异常消息——进入死信队列</p><p>死信队列的来源：</p><p>消息 TTL 过期</p><p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p><p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224938734.png" alt="image-20220125224938734"></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延迟队列——消息过期进入死信队列</p><p>存放需要在指定时间被处理的元素的队列</p><p>应用场景</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225016545.png" alt="image-20220125225016545"></p><p>缺陷：ttl不灵活</p><h3 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h3><p>QC队列不设置过期时间，由生产者设置ttl</p><p>缺陷：队列FIFO</p><h3 id="基于插件优化"><a href="#基于插件优化" class="headerlink" title="基于插件优化"></a>基于插件优化</h3><p>基于插件的交换机：在交换机处延迟</p><p>延迟交换机：类型、延迟类型（直接：路由key固定）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225256329.png" alt="image-20220125225256329"></p><p>其他延时队列：</p><p>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz，或者利用 kafka 的时间轮。RabbitMQ安全，完善。</p><h2 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h2><h3 id="交换机回调"><a href="#交换机回调" class="headerlink" title="交换机回调"></a>交换机回调</h3><p>交换机确认消息是否收到</p><p>写回调方法、注入</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225816018.png" alt="image-20220125225816018"></p><p>生产者只管给交换机消息，只接受交换机的接收结果</p><p>路由错误无法接收结果</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>无法路由时，消息回退给交换机，通知生产者</p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>无法投递的消息给备份交换机</p><p>没有什么是加一层解决不了的</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230021103.png" alt="image-20220125230021103"></p><p>备份优先级更高</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等性：重复提交</p><p>消费者ack中断，造成重新消费</p><p>解决思路：生成全局唯一id，消费之前判断是否被消费过</p><p>1、唯一ID + 指纹码机制（数据库）</p><p>2、Redis原子性：利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>设置优先级参数</p><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>消息存到磁盘中，消费者从磁盘取</p><p>内存占比非常小，取消息慢</p><h1 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h1><h2 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125221757500.png" alt="image-20220125221757500"></p><h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125222245390.png" alt="image-20220125222245390"></p><h2 id="高负载均衡"><a href="#高负载均衡" class="headerlink" title="高负载均衡"></a>高负载均衡</h2><p><strong>nginx、gateway</strong>、Haproxy等集群，进行反向代理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230327710.png" alt="image-20220125230327710"></p><p>以下暂用不到</p><h2 id="Shovel集群"><a href="#Shovel集群" class="headerlink" title="Shovel集群"></a>Shovel集群</h2><p>远程同步</p><h2 id="Federation-联邦集群"><a href="#Federation-联邦集群" class="headerlink" title="Federation 联邦集群"></a>Federation 联邦集群</h2><p>Federation Exchange、Federation Queue</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/acae23ba5952abdce66bb65e8b00a5a0.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ</title>
      <link href="/2022/01/24/ActiveMQ/"/>
      <url>/2022/01/24/ActiveMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221656632.png" alt="image-20220124221656632"></p><p>解耦、异步、削峰</p><p>分布式系统</p><p>只要消息发送，尽量异步</p><p>只要解耦，尽量引入消息中间件</p><h2 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h2><p>JMS编码架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221810182.png" alt="image-20220124221810182"></p><p>原生API：</p><p>生产者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息生产者</p><p>消息生产者发送消息</p><p>（1）创建消息</p><p>（2）通过生产者发送</p><p>关闭资源（倒序：生产者、session、连接）</p><p>消费者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息消费者</p><p>消费生产者接收消息——接收消息（一直型、定时型）、消息类型要一致</p><p>关闭资源（倒序：消费者、session、连接）</p><p>1、receive</p><p>2、监听</p><p>队列同时监听：轮询</p><p>主题：先订阅再有生产消息</p><h2 id="3、JMS"><a href="#3、JMS" class="headerlink" title="3、JMS"></a>3、JMS</h2><p>JavaEE</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222038405.png" alt="image-20220124222038405"></p><p>JMS：java消息服务</p><p>消息头</p><p>消息体</p><p>消息属性</p><p>可靠性：持久化、事务、签收、集群</p><h2 id="4、Broker"><a href="#4、Broker" class="headerlink" title="4、Broker"></a>4、Broker</h2><h2 id="5、spring-boot整合"><a href="#5、spring-boot整合" class="headerlink" title="5、spring boot整合"></a>5、spring boot整合</h2><p>间隔定投</p><p>注解监听</p><h2 id="6、传输协议"><a href="#6、传输协议" class="headerlink" title="6、传输协议"></a>6、传输协议</h2><p>种类</p><p>NIO + 多协议</p><h2 id="7、消息存储和持久化"><a href="#7、消息存储和持久化" class="headerlink" title="7、消息存储和持久化"></a>7、消息存储和持久化</h2><p>AMQ</p><p>KahaDB：事务日志 + 索引文件</p><p>Db.log：存储消息、Db.data：B树索引、Lock：文件锁</p><p>LevelDB：基于文件的本地数据库：redis aof</p><p>JDBC + Mysql：</p><p>建库，自动建表：消息表、订阅关系表、记录master表</p><p>JDBC With Journal：</p><p>存到高速缓存日志，减少数据库压力</p><h2 id="8、多节点集群"><a href="#8、多节点集群" class="headerlink" title="8、多节点集群"></a>8、多节点集群</h2><p>Zookeeper和Replicated LevelDB集群</p><p>原理：对外暴露master</p><p>主从复制 + Zookeeper集群</p><p>已被舍弃</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222731107.png" alt="image-20220124222731107"></p><h2 id="9、高级特性、面试考点"><a href="#9、高级特性、面试考点" class="headerlink" title="9、高级特性、面试考点"></a>9、高级特性、面试考点</h2><p>异步投递：</p><p>发送是否成功：写回调函数：成功、失败的信息</p><p>延时投递和定时投递：消息头属性中设置</p><p>分发策略</p><p>消息重试机制：消息侧回滚、消费侧没有commit等</p><p>有毒消息：重发超过6次，放到DLQ（死信队列）</p><p>死信队列：查看出错消息，人工干预修复，可自定义</p><p>防止重复调用，幂等性：数据库主键、redis key</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security</title>
      <link href="/2022/01/24/Spring%20Security/"/>
      <url>/2022/01/24/Spring%20Security/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h2><p>认证</p><p>授权</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220153579.png" alt="image-20220124220153579"></p><h2 id="2、web权限"><a href="#2、web权限" class="headerlink" title="2、web权限"></a>2、web权限</h2><p>查询数据库认证</p><p>自定义登录页面</p><p>方法注解</p><p>注销</p><p>原理分析</p><p>CSRF</p><h2 id="3、微服务权限"><a href="#3、微服务权限" class="headerlink" title="3、微服务权限"></a>3、微服务权限</h2><p>流程</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220433500.png" alt="image-20220124220433500"></p><p>数据库分表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220446710.png" alt="image-20220124220446710"></p><p>JWT：JWT 头、内容、签名哈希</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220917745.png" alt="image-20220124220917745"></p><h2 id="4、源码解析"><a href="#4、源码解析" class="headerlink" title="4、源码解析"></a>4、源码解析</h2><p><strong>Spring Security</strong> 采取<strong>过滤链</strong>实现认证与授权</p><p>认证流程</p><p>权限访问流程</p><p>请求间共享认证信息</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2022/01/24/nginx/"/>
      <url>/2022/01/24/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>nginx</p><p>正向代理</p><p>反向代理</p><p>负载均衡</p><p>动静分离</p><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>高可用集群（主从模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215235206.png" alt="image-20220124215235206"></p><p>高可用集群（双主模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215307904.png" alt="image-20220124215307904"></p><h2 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h2><p><img src="https://img-blog.csdnimg.cn/20191103213303224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hcml0aC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="Nginx 整体架构"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2022/01/24/zookeeper/"/>
      <url>/2022/01/24/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="1、入门"><a href="#1、入门" class="headerlink" title="1、入门"></a>1、入门</h2><p>概述：工作机制</p><p>数据结构：ZNode 树型文件系统</p><p>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下</p><p>线、软负载均衡等</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h2 id="3、集群"><a href="#3、集群" class="headerlink" title="3、集群"></a>3、集群</h2><p>选举机制：</p><p>第一次启动</p><p>非第一次启动：任期id——事务id——id</p><p>节点类型：</p><p>持久、短暂、有序号、无序号</p><p>监听器</p><p>写数据原理：</p><p>发给leader</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213707456.png" alt="image-20220124213707456"></p><p>发给follower</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213720276.png" alt="image-20220124213720276"></p><h2 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h2><p>服务器动态上下线</p><p>分布式锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213847011.png" alt="image-20220124213847011"></p><p>Curator框架实现分布式锁</p><h2 id="5、源码"><a href="#5、源码" class="headerlink" title="5、源码"></a>5、源码</h2><p>选举机制：第一次、非第一次</p><p>分布式一致性：</p><p>Paxos算法</p><p>ZAB协议：消息广播、崩溃恢复</p><p>异常发生——leader选举 + 数据恢复</p><p>数据恢复——一个follower所有事务提交之后才变为follower</p><p>CAP理论：保证CP</p><p>持久化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214406672.png" alt="image-20220124214406672"></p><p>序列化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214429678.png" alt="image-20220124214429678"></p><p>服务端初始化源码-启动脚本</p><p>初始化-解析参数</p><p>初始化-过期快照删除</p><p>初始化-通信初始化</p><p>服务端加载数据源码</p><p>选举-选举准备</p><p>选举-选举执行</p><p>Follower 和 Leader 状态同步源码</p><p>状态同步细节</p><p>Leader启动</p><p>Follower启动</p><p>客户端启动</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214747431.png" alt="image-20220124214747431"></p><p>选举</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo</title>
      <link href="/2022/01/24/dubbo/"/>
      <url>/2022/01/24/dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>分布式系统演变</p><p>RPC原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212540495.png" alt="image-20220124212540495"></p><p>dubbo核心原理</p><p>监控中心</p><h2 id="2、dubbo配置"><a href="#2、dubbo配置" class="headerlink" title="2、dubbo配置"></a>2、dubbo配置</h2><h2 id="3、高可用"><a href="#3、高可用" class="headerlink" title="3、高可用"></a>3、高可用</h2><p>zookeeper</p><p>集群负载均衡</p><p>hystrix、服务熔断、服务降级</p><h2 id="4、原理"><a href="#4、原理" class="headerlink" title="4、原理"></a>4、原理</h2><h3 id="RPC原理："><a href="#RPC原理：" class="headerlink" title="RPC原理："></a>RPC原理：</h3><p>一次完整的RPC调用流程（同步调用，异步另说）如下： </p><p><strong>1）服务消费方（client）调用以本地调用方式调用服务；</strong> </p><p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p><p>3）client stub找到服务地址，并将消息发送到服务端； </p><p>4）server stub收到消息后进行解码； </p><p>5）server stub根据解码结果调用本地的服务； </p><p>6）本地服务执行并将结果返回给server stub； </p><p>7）server stub将返回结果打包成消息并发送至消费方； </p><p>8）client stub接收到消息，并进行解码； </p><p><strong>9）服务消费方得到最终结果。</strong></p><p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h3 id="netty通信原理"><a href="#netty通信原理" class="headerlink" title="netty通信原理"></a>netty通信原理</h3><p>BIO</p><p>NIO</p><h3 id="dubbo原理"><a href="#dubbo原理" class="headerlink" title="dubbo原理"></a>dubbo原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212904106.png" alt="image-20220124212904106"></p><p>框架设计</p><p>启动解析、加载配置信息</p><p>服务暴露</p><p>服务引用</p><p>服务调用</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch</title>
      <link href="/2022/01/24/elasticsearch/"/>
      <url>/2022/01/24/elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="入门-HTTP"><a href="#入门-HTTP" class="headerlink" title="入门-HTTP"></a>入门-HTTP</h1><h1 id="入门-JavaAPI"><a href="#入门-JavaAPI" class="headerlink" title="入门-JavaAPI"></a>入门-JavaAPI</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>进阶：文档、字段、映射、分片、副本、分配</p><p>系统架构：</p><p>选举主节点，master调度管理集群</p><p>P1P2P3分片、R2R0R1副本，不在一个机器上</p><p>每一个分片就是底层的LUCENE的索引</p><p>分布式集群：</p><p>故障转移、水平扩容、应对故障</p><p>路由计算 &amp; 分片控制</p><p>数据写流程</p><p>数据读流程</p><p>更新流程 &amp; 批量操作流程</p><p>倒排索引</p><p>文档搜索</p><p>文档刷新 &amp; 文档刷写 &amp; 文档合并</p><p>文档分析</p><p>文档处理</p><p>文档展示-Kibana</p><h1 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h1><p>SpringData-整体介绍</p><p>文档搜索</p><p>Spark streaming</p><p>Flink</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>硬件选择</p><p>分片策略</p><p>路由选择</p><p>写入速度优化</p><p>重要配置</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>为什么使用elasticsearch</p><p>Master选举</p><p>集群脑裂</p><p>索引文档的流程</p><p>更新和删除文档</p><p>搜索流程</p><p>Linux设置部署优化</p><p>GC方面，注意</p><p>上亿数据的聚合实现</p><p>并发情况下，如何保证读写—致</p><p>监控</p><p>字典树</p><p>集群、节点、索引、文档、类型</p><p>倒排索引</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>为什么使用es</p><p>概念：集群、节点、索引、文档、类型</p><p>基本操作：索引、更新、删除、搜索</p><p>集群：master选举、脑裂</p><p>字典树</p><p>倒排索引</p><p>优化：linux部署设置、GC、</p><p>海量数据：如何聚合</p><p>高并发：如何保证读写一致</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/01/24/docker/"/>
      <url>/2022/01/24/docker/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/docker%E6%80%BB%E7%BB%93.png" alt="docker总结"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/01/24/redis/"/>
      <url>/2022/01/24/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h2><p>Memcache</p><p>Redis</p><p>MongoDB</p><h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>单线程+多路IO复用</p><p>应用场景：</p><p>缓存、session共享、持久化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124203929901.png" alt="image-20220124203929901"></p><h2 id="五大常用数据类型"><a href="#五大常用数据类型" class="headerlink" title="五大常用数据类型"></a>五大常用数据类型</h2><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><h2 id="三大新数据类型"><a href="#三大新数据类型" class="headerlink" title="三大新数据类型"></a>三大新数据类型</h2><h2 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h2><p>网络连接：心跳检测、连接时长</p><p>通用：日志级别、库</p><p>存储策略</p><h2 id="reids的发布和订阅"><a href="#reids的发布和订阅" class="headerlink" title="reids的发布和订阅"></a>reids的发布和订阅</h2><p>Bitmaps：统计</p><p>HyperLogLog：基数计算：不重复数据个数的计算</p><p>Geographic：地理</p><h2 id="Jedis、RedisTemplate"><a href="#Jedis、RedisTemplate" class="headerlink" title="Jedis、RedisTemplate"></a>Jedis、RedisTemplate</h2><h2 id="事务、锁机制、秒杀"><a href="#事务、锁机制、秒杀" class="headerlink" title="事务、锁机制、秒杀"></a>事务、锁机制、秒杀</h2><p>事务：</p><p>Multi、Exec、discard</p><p>悲观锁、乐观锁</p><p>监视key</p><p>特点：单独的隔离操作、没有隔离级别的概念、不保证原子性</p><p>秒杀：</p><p>乐观锁 + 连接池 + LUA脚本（原子化）  解决库存遗留问题</p><h2 id="持久化RDB、AOF"><a href="#持久化RDB、AOF" class="headerlink" title="持久化RDB、AOF"></a>持久化RDB、AOF</h2><p>RDB：临时文件 –&gt; 覆盖</p><p>AOF：只记录写的操作，只能追加，redis读取这些操作重写构建数据</p><p>写操作追加到缓存区，根据策略进行持久化同步，根据重写策略进行重写压缩</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>一主二仆</p><p>薪火相传：分组传递</p><p>宕机上位</p><p>连接时：全量复制</p><p>同步时：增量复制</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124205643714.png" alt="image-20220124205643714"></p><p>主从复制原理</p><p>哨兵模式：</p><p>Master down ，sentinel自动监控 —&gt; 选举某从机作为主机</p><p>Master 再次上线后 变为从机</p><p>选举规则：</p><p>1、Priority最小</p><p>2、偏移量最全</p><p>3、Runid最小的（随机生成）</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>无中心化</p><p>集群节点的插槽计算：计算key所属的插槽，平均分摊压力</p><p>哈希槽分区</p><h2 id="应用问题"><a href="#应用问题" class="headerlink" title="应用问题"></a>应用问题</h2><p>缓存穿透</p><p>解决方案：</p><p>缓存空值（设置过期时间）、设置白名单（bitmaps）</p><p>布隆过滤器（底层bitmap）、实时监控redis（设置黑名单）</p><p>缓存击穿</p><p>解决方案：</p><p>预先设置热门key（增加时长）、实时调整（频繁访问key增加时长）</p><p>锁（先上锁，查完数据库放锁）</p><p>缓存雪崩</p><p>构建多层缓存（多级缓存处理）、锁和队列（不适合高并发）</p><p>设置过期标志（更新时长）、分散缓存失效时间（过期时间不同）</p><p>分布式锁</p><p>reids分布式锁：</p><p>setnx  同时设置过期时间</p><p>Redisson</p><p>总结：</p><p>Uuid + 过期时间 + 加锁</p><p>Lua释放锁（uuid比较）</p><h2 id="Redis6新功能"><a href="#Redis6新功能" class="headerlink" title="Redis6新功能"></a>Redis6新功能</h2><p>Acl用户权限</p><p>Io多线程：网络数据读写和协议解析</p><p>工具支持cluster</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud + SpringCloud Alibaba分布式集群总结</title>
      <link href="/2022/01/24/SpringCoud%20Alibaba/"/>
      <url>/2022/01/24/SpringCoud%20Alibaba/</url>
      
        <content type="html"><![CDATA[<h2 id="eureka："><a href="#eureka：" class="headerlink" title="eureka："></a>eureka：</h2><p>单机eureka、集群eureka</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="zookeeper："><a href="#zookeeper：" class="headerlink" title="zookeeper："></a>zookeeper：</h2><p>linux docker部署zookeeper，配置注册地址</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="consul："><a href="#consul：" class="headerlink" title="consul："></a>consul：</h2><p>命令本地启动consul，8500端口页面</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="Ribbon："><a href="#Ribbon：" class="headerlink" title="Ribbon："></a>Ribbon：</h2><p>Irule配置或自定义负载均衡算法，@Ribbonclient配置调用的服务和算法</p><p>手写轮询算法，CAS锁</p><h2 id="Openfeign："><a href="#Openfeign：" class="headerlink" title="Openfeign："></a>Openfeign：</h2><p>接口注解调用，默认支持ribbon自带负载均衡</p><p>ribbon超时控制，日志显示</p><h2 id="Hystrix："><a href="#Hystrix：" class="headerlink" title="Hystrix："></a>Hystrix：</h2><p>服务降级：@HystrixCommand，调用中出现错误、超时、宕机等，启用兜底方法，fallback方法分离</p><p>服务熔断：配置熔断情况，时间窗口，请求阈值，错误百分比阈值等，half open</p><p>hystrixDashboard可视化监控，监控服务访问</p><h2 id="Zuul、Gataway："><a href="#Zuul、Gataway：" class="headerlink" title="Zuul、Gataway："></a>Zuul、Gataway：</h2><p>路由转发、断言匹配、执行过滤器链，支持负载均衡</p><p>作为中转站进行路由映射，过滤器生命周期pre、post，常用过滤器：请求头、参数匹配等，自定义过滤器</p><h2 id="Config："><a href="#Config：" class="headerlink" title="Config："></a>Config：</h2><p>服务端实时获取Github配置，文件配置映射，生产模式配置，客户端父子配置文件，设置文件映射和配置中心</p><p>Post请求动态刷新客户端配置</p><h2 id="Bus："><a href="#Bus：" class="headerlink" title="Bus："></a>Bus：</h2><p>支持RabbitMQ和kafka，自动进行消息监听配置中心变化，全局订阅实现配置更新，称为消息总线</p><p>加入bus依赖，rabbitmq配置，自动监听，一次发送处处生效</p><p>定点刷新，post附带服务端端口号</p><h2 id="Stream："><a href="#Stream：" class="headerlink" title="Stream："></a>Stream：</h2><p>统一底层差异，设置生产者、消费者、监听进行消息发送</p><p>分组消费，配置group，支持消息持久化</p><h2 id="Sleuth："><a href="#Sleuth：" class="headerlink" title="Sleuth："></a>Sleuth：</h2><p>zipkin可视化监控，本地命令启动，全局链路id关联调用链路</p><p>配置zikpin地址，采样率设置</p><h2 id="Nacos："><a href="#Nacos：" class="headerlink" title="Nacos："></a>Nacos：</h2><p>nacos服务注册中心，本地命令启动，支持CP、AP切换</p><p>作为配置中心，加入配置匹配格式，配置名称空间，分组等进行匹配，自带动态刷新</p><p>namespace：环境、group：分组，不同微服务模块、service：微服务模块、cluster：集群，杭州虚拟划分，实现容灾，instance：微服务实例</p><p>持久化配置，默认嵌入式数据库derby，连接到mysql即可</p><p>nacos集群，linux docker部署，请求到Nginx集群，nacos集群，底层db集群</p><h2 id="Sentinel："><a href="#Sentinel：" class="headerlink" title="Sentinel："></a>Sentinel：</h2><p>sentinel可视化控制台，本地命令启动，yaml配置地址，默认懒加载</p><p>流控规则，</p><p>统计规则：慢调用比例，异常比例、异常数，</p><p>流控模式：直接、关联，关联的资源达到阈值限流自己、链路，统计指定资源到当前资源，对请求来源限流，</p><p>流控效果：直接、预热，阈值从冷启动因子经过预热时长后达到正常阈值，秒杀应用、排队等待，匀速排队，阈值必须为qps，处理间隔突发的流量</p><p>服务降级，降级策略：RT平均响应时间、异常比例、异常数，分钟统计，支持半开状态</p><p>热点key限流，支持参数索引，排除特殊参数。系统规则，全局限流</p><p>@SentinelResource，blockhandler：限流兜底方法，自定义限流处理逻辑，代码分离</p><p>服务熔断，整合ribbon，加上fallback即可，整合feign，消费者侧接口注解处fallback</p><p>规则持久化，yaml配置datasource，地址指向nacos，文件匹配</p><h2 id="seata："><a href="#seata：" class="headerlink" title="seata："></a>seata：</h2><p>ID+三组件，TC全局事务协调器，TM事务提交回滚，RM分支事务、分支注册、状态汇报等</p><p>seata service本机命令启动，配置文件，数据库，nacos地址</p><p>mysql建表，seata事务表，业务数据库回滚日志表</p><p>微服务配置，文件nacos匹配，yaml配置，seata代理数据库，@GlobalTransactional，异常回滚</p><p>执行流程：一阶段加载：解析sql语句找到业务数据保存为before image，执行业务sql，保存after iamge，生成行锁，二阶段提交：顺利提交，seata删除快照和行锁，完成数据清理即可，二阶段回滚：回滚执行的业务sql，通过一阶段回滚日志进行反向补偿，用before image还原业务数据，脏写校验，对比当前和after image</p><h2 id="分布式全局唯一id："><a href="#分布式全局唯一id：" class="headerlink" title="分布式全局唯一id："></a>分布式全局唯一id：</h2><p>UUID，入库性能差、数据库自增主键，B+树索引分裂、reids集群增长步长，需要维护，雪花算法</p><p><img src="https://z3.ax1x.com/2021/07/27/WhcJM9.png" alt="WhcJM9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud Alibaba </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
