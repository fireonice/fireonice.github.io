<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL——索引优化&amp;性能分析&amp;数据库调优</title>
      <link href="/2022/05/06/MySQL-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96&amp;%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90&amp;%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/"/>
      <url>/2022/05/06/MySQL-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96&amp;%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90&amp;%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h1><h2 id="索引的声明与使用"><a href="#索引的声明与使用" class="headerlink" title="索引的声明与使用"></a><strong>索引的声明与使用</strong></h2><h3 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a><strong>1.1</strong> <strong>索引的分类</strong></h3><ul><li>从<code>功能逻辑</code>上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照<code>物理实现方式</code>，索引可以分为 2 种：聚簇索引和非聚簇索引。</li><li>按照<code>作用字段个数</code>进行划分，分成单列索引和联合索引。</li></ul><h3 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a><strong>1.2</strong> <strong>创建索引</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type] </span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure><ul><li><code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li><code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；</li><li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li><li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li><code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</li></ul><p><strong>1.</strong> <strong>创建普通索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE book( </span><br><span class="line">    book_id INT , </span><br><span class="line">    book_name VARCHAR(100), </span><br><span class="line">    authors VARCHAR(100), </span><br><span class="line">    info VARCHAR(100) , </span><br><span class="line">    comment VARCHAR(100), </span><br><span class="line">    year_publication YEAR, </span><br><span class="line">    INDEX(year_publication) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>创建唯一索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test1( </span><br><span class="line">    id INT NOT NULL, </span><br><span class="line">    name varchar(30) NOT NULL, </span><br><span class="line">    UNIQUE INDEX uk_idx_id(id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>主键索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student ( </span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT, </span><br><span class="line">    student_no VARCHAR(200),</span><br><span class="line">    student_name VARCHAR(200), </span><br><span class="line">    PRIMARY KEY(id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除主键索引</span><br><span class="line">ALTER TABLE student drop PRIMARY KEY ;</span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>创建单列索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test2( </span><br><span class="line">    id INT NOT NULL, </span><br><span class="line">    name CHAR(50) NULL, </span><br><span class="line">    INDEX single_idx_name(name(20)) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>5.</strong> <strong>创建组合索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test3( </span><br><span class="line">    id INT(11) NOT NULL, </span><br><span class="line">    name CHAR(30) NOT NULL, </span><br><span class="line">    age INT(11) NOT NULL, </span><br><span class="line">    info VARCHAR(255), </span><br><span class="line">    INDEX multi_idx(id,name,age) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>6.</strong> <strong>创建全文索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `papers` ( </span><br><span class="line">    id` int(10) unsigned NOT NULL AUTO_INCREMENT, </span><br><span class="line">    `title` varchar(200) DEFAULT NULL, </span><br><span class="line">    `content` text, PRIMARY KEY (`id`), </span><br><span class="line">    FULLTEXT KEY `title` (`title`,`content`) </span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure><p><strong>7.</strong> <strong>创建空间索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test5( </span><br><span class="line">    geo GEOMETRY NOT NULL, </span><br><span class="line">    SPATIAL INDEX spa_idx_geo(geo) </span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>在已经存在的表上创建索引</strong></p><p><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name </span><br><span class="line">ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name </span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure><h3 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a><strong>1.3</strong> <strong>删除索引</strong></h3><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ 索引分类</span><br><span class="line">    + 功能逻辑</span><br><span class="line">        + 普通索引</span><br><span class="line">            + 没任何附加条件，普通字段（任何）的索引</span><br><span class="line">        + 唯一索引</span><br><span class="line">            + unique字段自动设置唯一索引</span><br><span class="line">        + 主键索引</span><br><span class="line">            + 主键约束、聚簇索引</span><br><span class="line">        + 全文索引</span><br><span class="line">            + 分词技术，elasticsearch</span><br><span class="line">    + 物理实现</span><br><span class="line">        + 聚簇索引、非聚簇索引</span><br><span class="line">    + 作用字段</span><br><span class="line">        + 单列索引</span><br><span class="line">        + 联合索引</span><br><span class="line">            + 多个字段组合</span><br><span class="line">+ 创建表、修改表</span><br><span class="line">    + 主键约束、唯一约束、外键约束字段自动添加索引</span><br><span class="line">    + 手动声明索引</span><br><span class="line">        + INDEX xxx(字段)</span><br><span class="line">        + UNIQUE INDXE xxx(字段)</span><br><span class="line">            + 自动添加唯一约束</span><br><span class="line">        + INDXE xxx(xxx,xxx)</span><br><span class="line">            + 联合索引</span><br><span class="line">            + 按先后顺序排序</span><br><span class="line">        + FULLTEXT INDXE xxx(xxx)</span><br><span class="line">            + 全文索引CHAR、VARCHAR、TEXT</span><br><span class="line">            + 不会用到</span><br><span class="line">        + SPATIAL</span><br><span class="line">            + 空间索引</span><br><span class="line">    + 删除索引</span><br><span class="line">        + 删除主键自动删除主键索引</span><br><span class="line">+ 创建索引（表创建之后）</span><br><span class="line">    + ALTER TABLE xxx ADD INDXE xxx(xxx)</span><br><span class="line">    + CREATEINDEX xxx ON xxx(xxx)</span><br><span class="line">+ 查看索引</span><br><span class="line">    + SHOW CREATE TBALE</span><br><span class="line">    + SHOW INDEX</span><br><span class="line">    + EXPLAIN工具</span><br><span class="line">+ 删除索引</span><br><span class="line">    + ALTER TABLE</span><br><span class="line">    + DROP INDEX</span><br></pre></td></tr></table></figure><h2 id="MySQL8-0索引新特性"><a href="#MySQL8-0索引新特性" class="headerlink" title="MySQL8.0索引新特性"></a><strong>MySQL8.0索引新特性</strong></h2><h3 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a><strong>2.1</strong> <strong>支持降序索引</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</span><br></pre></td></tr></table></figure><h3 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a><strong>2.2</strong> <strong>隐藏索引</strong></h3><p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。<code>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</code>。</p><p><strong>1.</strong> <strong>创建表时直接创建</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename( </span><br><span class="line">    propname1 type1[CONSTRAINT1], </span><br><span class="line">    propname2 type2[CONSTRAINT2], </span><br><span class="line">    ……</span><br><span class="line">    propnamen typen, </span><br><span class="line">    INDEX [indexname](propname1 [(length)]) INVISIBLE </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexname </span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename </span><br><span class="line">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p><strong>4.</strong> <strong>切换索引可见状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 </span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 8.0索引新特性</span><br><span class="line">    + 支持降序索引</span><br><span class="line">        + 8.0之前进行反向扫描，效率低</span><br><span class="line">    + 隐藏索引</span><br><span class="line">        + 将待删除的索引隐藏掉</span><br><span class="line">            + 如果查询仍然正常，则可彻底删除索引</span><br><span class="line">        + 软删除</span><br><span class="line">            + 先试探一下</span><br><span class="line">    + 测试</span><br><span class="line">    + 更新数据会更新索引</span><br><span class="line">    + 使隐藏索引对查询优化器可见</span><br></pre></td></tr></table></figure><h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a><strong>索引的设计原则</strong></h2><h3 id="3-1-哪些情况适合创建索引"><a href="#3-1-哪些情况适合创建索引" class="headerlink" title="3.1 哪些情况适合创建索引"></a><strong>3.1</strong> <strong>哪些情况适合创建索引</strong></h3><p><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong></p><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果<code>某个字段是唯一的</code>，就可以直接<code>创建唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><p><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></p><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p><strong>3.</strong> <strong>经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> <strong>的列</strong></p><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p><p><strong>4. UPDATE、DELETE</strong> <strong>的</strong> <strong>WHERE</strong> <strong>条件列</strong></p><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p><p><strong>5.DISTINCT</strong> <strong>字段需要创建索引</strong></p><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><p><strong>6.</strong> <strong>多表</strong> <strong>JOIN</strong> <strong>连接操作时，创建索引注意事项</strong></p><p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的<code>类型必须一致</code>。</p><p><strong>7.</strong> <strong>使用列的类型小的创建索引</strong> </p><p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。</p><p><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></p><p>区分度计算公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【<code>强制</code>】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会<code>高达 90% 以上</code>。</p><p><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></p><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2,5,8,2,5,8,2,5,8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，<strong>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</strong>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a)/count(*) from t1</code>计算区分度，越接近1越好，一般超过<code>33%</code>就算是比较高效的索引了。</p><p>拓展：联合索引把区分度高（散列性高）的列放在前面。</p><p><strong>10.</strong> <strong>使用最频繁的列放到联合索引的左侧</strong></p><p><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p><h3 id="3-2-限制索引的数目"><a href="#3-2-限制索引的数目" class="headerlink" title="3.2 限制索引的数目"></a><strong>3.2</strong> <strong>限制索引的数目</strong></h3><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><ul><li>每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</li><li>索引会影响<code>INSERT、DELETE、UPDATE等语句的性能</code>，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引来进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li></ul><h3 id="3-3-哪些情况不适合创建索引"><a href="#3-3-哪些情况不适合创建索引" class="headerlink" title="3.3 哪些情况不适合创建索引"></a><strong>3.3</strong> <strong>哪些情况不适合创建索引</strong></h3><p><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></p><p><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></p><p><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></p><p><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong> </p><p><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></p><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p><p><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></p><p><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ 设计原则</span><br><span class="line">+ 适合加索引</span><br><span class="line">    + 字段的数值有唯一性的限制</span><br><span class="line">        + unique约束自动添加唯一索引</span><br><span class="line">        + 唯一索引自动添加unique约束</span><br><span class="line">    + 频繁作为where查询条件的字段</span><br><span class="line">    + 经常GROUP BY和ORDER BY的列</span><br><span class="line">        + 本身索引排好序，便于排序</span><br><span class="line">        + 本身索引相同的挨着，便于分组</span><br><span class="line">        + 最左前缀原则</span><br><span class="line">    + UPDATE DELETE 的WHERE条件列</span><br><span class="line">    + DISTINCT字段需要创建索引</span><br><span class="line">        + 字段排序挨着，方便去重</span><br><span class="line">    + 多表JOIN连接操作时，创建索引事项</span><br><span class="line">        + WHERE条件创建索引</span><br><span class="line">        + 连接的字段创建索引</span><br><span class="line">            + 类型必须一致</span><br><span class="line">            + 若进行隐式转换，用到函数，索引失效</span><br><span class="line">    + 使用列的类型小的创建索引</span><br><span class="line">        + 二级索引更小，高效io</span><br><span class="line">    + 使用字符串前缀创建索引</span><br><span class="line">        + 前缀索引</span><br><span class="line">            + 减少字符串比较时间</span><br><span class="line">            + 建立索引节约空间</span><br><span class="line">        + 计算区分度：高达90%以上长度适合</span><br><span class="line">        + 无法通过索引排序</span><br><span class="line">    + 区分度高（散列性高）的列适合作为索引</span><br><span class="line">        + 计算区分度</span><br><span class="line">    + 使用最频繁的列放到联合索引的左侧</span><br><span class="line">    + 在多个字段都要创建所以的情况下，联合索引优于单值索引</span><br><span class="line">+ 限制索引的数目</span><br><span class="line">    + 影响增删改的性能</span><br><span class="line">    + 空间</span><br><span class="line">    + 优化器会对索引评估，选择适合的索引</span><br><span class="line">+ 不适合添加索引</span><br><span class="line">    + 不用WHRER</span><br><span class="line">    + 数据少</span><br><span class="line">    + 区分度低</span><br><span class="line">        + 大量重复</span><br><span class="line">    + 频繁更新</span><br><span class="line">    + 无序的值的列</span><br><span class="line">        + UUID</span><br><span class="line">        + 插入经常页分裂</span><br><span class="line">    + 冗余重复索引</span><br><span class="line">        + 联合索引最左字段</span><br></pre></td></tr></table></figure><h1 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h1><p>数据库服务器的优化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205061528471.png" alt="image-20220506152803512"></p><h2 id="统计SQL的查询成本：last-query-cost"><a href="#统计SQL的查询成本：last-query-cost" class="headerlink" title="统计SQL的查询成本：last_query_cost"></a><strong>统计SQL的查询成本：last_query_cost</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;last_query_cost&#x27;;</span><br></pre></td></tr></table></figure><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><ol><li><code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ol><p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 调优步骤</span><br><span class="line">+ SQL索引</span><br><span class="line">+ 数据库表结构</span><br><span class="line">+ 系统配置</span><br><span class="line">+ 硬件配置</span><br><span class="line">+ 查看系统性能参数</span><br><span class="line">    + SHOW xxx STATUS LIKE ‘xxx’;</span><br><span class="line">+ 统计SQL的查询成本</span><br><span class="line">    + SQL语句所需要读取的页的数量</span><br><span class="line">    + 从页加载的角度</span><br><span class="line">        + 位置</span><br><span class="line">            + 缓冲池 &gt; 内存 &gt; 磁盘</span><br><span class="line">        + 批量</span><br><span class="line">            + 顺序io读取，对页批量读取</span><br></pre></td></tr></table></figure><h2 id="定位执行慢的SQL：慢查询日志"><a href="#定位执行慢的SQL：慢查询日志" class="headerlink" title="定位执行慢的SQL：慢查询日志"></a>定位执行慢的SQL：慢查询日志</h2><p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阈值</code>的语句，具体指运行时间超过<code>long_query_time</code>的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p><p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<code>如果不是调优需要的话，一般不建议启动该参数</code>，因为开启慢查询日志会或多或少带来一定的性能影响。</p><h3 id="2-1-开启慢查询日志参数"><a href="#2-1-开启慢查询日志参数" class="headerlink" title="2.1 开启慢查询日志参数"></a><strong>2.1</strong> <strong>开启慢查询日志参数</strong></h3><p><strong>1.</strong> <strong>开启slow_query_log</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure><p>查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like `%slow_query_log%`;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>修改long_query_time阈值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 </span><br><span class="line">mysql &gt; set global long_query_time = 1; </span><br><span class="line">mysql&gt; show global variables like &#x27;%long_query_time%&#x27;; </span><br><span class="line"></span><br><span class="line">mysql&gt; set long_query_time=1; </span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="2-2-查看慢查询数目"><a href="#2-2-查看慢查询数目" class="headerlink" title="2.2 查看慢查询数目"></a><strong>2.2</strong> <strong>查看慢查询数目</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="2-3-慢查询日志分析工具：mysqldumpslow"><a href="#2-3-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="2.3 慢查询日志分析工具：mysqldumpslow"></a><strong>2.3</strong> <strong>慢查询日志分析工具：mysqldumpslow</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">得到返回记录集最多的10个SQL</span> </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log </span><br><span class="line"><span class="meta">#</span><span class="bash">得到访问次数最多的10个SQL</span> </span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta">#</span><span class="bash">得到按照时间排序的前10条里面含有左连接的查询语句</span> </span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log </span><br><span class="line"><span class="meta">#</span><span class="bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span> </span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure><h3 id="2-4-关闭慢查询日志"><a href="#2-4-关闭慢查询日志" class="headerlink" title="2.4 关闭慢查询日志"></a><strong>2.4</strong> <strong>关闭慢查询日志</strong></h3><p><strong>方式1：永久性方式</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="literal">OFF</span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="comment">#slow_query_log =OFF</span></span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=off;</span><br></pre></td></tr></table></figure><h2 id="查看-SQL-执行成本：SHOW-PROFILE"><a href="#查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="查看 SQL 执行成本：SHOW PROFILE"></a><strong>查看</strong> <strong>SQL</strong> <strong>执行成本：SHOW PROFILE</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;profiling&#x27;;</span><br><span class="line">#开启</span><br><span class="line">set profiling = &#x27;ON&#x27;;</span><br><span class="line">#查看</span><br><span class="line">show profiles;</span><br><span class="line">show profile cpu,block io for query 2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 慢查询日志</span><br><span class="line">    + 执行慢的SQL，可设置阈值时间</span><br><span class="line">    + 针对性优化SQL</span><br><span class="line">    + 调优时开启，写入到日志文件</span><br><span class="line">+ 开启慢查询日志</span><br><span class="line">+ 日志位置</span><br><span class="line">+ 修改阈值</span><br><span class="line">    + 命令</span><br><span class="line">    + 配置文件</span><br><span class="line">+ 查看慢查询数目</span><br><span class="line"></span><br><span class="line">+ 慢查询日志分析工具：mysqldumpslow</span><br><span class="line">+ 查看SQL执行成本</span><br><span class="line">    + SHOW PROFILE</span><br></pre></td></tr></table></figure><h2 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a><strong>分析查询语句：EXPLAIN</strong></h2><h3 id="4-1-基本语法"><a href="#4-1-基本语法" class="headerlink" title="4.1 基本语法"></a><strong>4.1</strong> <strong>基本语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT select_options </span><br><span class="line">#或者</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个<code>唯一的id</code></td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h3 id="4-2-EXPLAIN各列作用"><a href="#4-2-EXPLAIN各列作用" class="headerlink" title="4.2 EXPLAIN各列作用"></a><strong>4.2 EXPLAIN各列作用</strong></h3><p><strong>1. table</strong></p><p>不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行<code>单表访问</code>的，所以MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。</p><p><strong>2. id</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li><li><strong>关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好</strong></li></ul><p><strong>3. select_type</strong></p><p><strong>4. partitions</strong></p><p><strong>5. type（重点）</strong></p><p><strong>结果值从最好到最坏依次是：</strong> <strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong> </p><p><strong>SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）</strong></p><p><strong>6. possible_keys和key</strong></p><p><strong>7. key_len（重点）</strong></p><p><strong>key_len的长度计算公式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) </span><br><span class="line"></span><br><span class="line">varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) </span><br><span class="line"></span><br><span class="line">char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</span><br></pre></td></tr></table></figure><p><strong>8. ref</strong> </p><p><strong>9. rows（重点）</strong></p><p>预估的需要读取的记录条数</p><p><strong>10. filtered</strong></p><p><strong>11. Extra</strong></p><h2 id="EXPLAIN的进一步使用"><a href="#EXPLAIN的进一步使用" class="headerlink" title="EXPLAIN的进一步使用"></a><strong>EXPLAIN的进一步使用</strong></h2><h3 id="5-1-EXPLAIN四种输出格式"><a href="#5-1-EXPLAIN四种输出格式" class="headerlink" title="5.1 EXPLAIN四种输出格式"></a><strong>5.1 EXPLAIN四种输出格式</strong></h3><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p><p><strong>1.</strong> <strong>传统格式</strong></p><p><strong>2. JSON格式</strong> </p><p>JSON格式：在EXPLAIN单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。用于查看执行成本<code>cost_info</code></p><p><strong>3. TREE格式</strong></p><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p><p><strong>4.</strong> <strong>可视化输出</strong></p><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。</p><h3 id="5-2-SHOW-WARNINGS的使用"><a href="#5-2-SHOW-WARNINGS的使用" class="headerlink" title="5.2 SHOW WARNINGS的使用"></a><strong>5.2 SHOW WARNINGS的使用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;</span><br><span class="line"># 查看优化后的执行语句</span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">+ EXPLAIN</span><br><span class="line">    + 查看语句的执行计划等</span><br><span class="line">    + 不会真正执行</span><br><span class="line"></span><br><span class="line">+ 基本语法</span><br><span class="line">    + EXPLAIN xxx</span><br><span class="line">    + DESCRIBE xxx</span><br><span class="line">+ 列名</span><br><span class="line">    + 唯一id</span><br><span class="line">        + 一个SELECT一个id </span><br><span class="line">        + 优化器可能对子查询重写，多表连接</span><br><span class="line">            + 变为一个SELECT</span><br><span class="line">        + UNION去重时</span><br><span class="line">            + 使用临时表进行去重</span><br><span class="line">            + id为NULL</span><br><span class="line">        + 小结</span><br><span class="line">            + id相同为一组，从上往下优先级执行</span><br><span class="line">            + id每个号码代表一趟独立查询</span><br><span class="line">                + SQL趟数越少越好</span><br><span class="line">    + 查询类型select_type</span><br><span class="line">        + 小查询在大查询扮演什么角色</span><br><span class="line">            + 举例</span><br><span class="line">    + 表名table</span><br><span class="line">        + 一行记录对应一个单表</span><br><span class="line">            + s1驱动表</span><br><span class="line">            + s2被驱动表</span><br><span class="line">    + 匹配的分区信息partitions</span><br><span class="line">    + 针对单表的访问方法type</span><br><span class="line">        + 不同的访问方法</span><br><span class="line">            + 越前面的效率越好</span><br><span class="line">            + system</span><br><span class="line">            + const</span><br><span class="line">                + 唯一索引等值匹配</span><br><span class="line">            + eq_ref</span><br><span class="line">                + 连接查询，被驱动表唯一索引匹配</span><br><span class="line">            + ref</span><br><span class="line">                + 普通二级索引等值匹配</span><br><span class="line">            + ref_or_null</span><br><span class="line">                + ref或者null</span><br><span class="line">            + index_merge</span><br><span class="line">                + 索引一起查询</span><br><span class="line">                + OR</span><br><span class="line">            + unique_subquery</span><br><span class="line">                + 子查询，子查询唯一索引等值匹配</span><br><span class="line">            + range</span><br><span class="line">                + 索引获取范围</span><br><span class="line">            + index</span><br><span class="line">                + 索引覆盖，但是要扫描全部索引记录</span><br><span class="line">            + all</span><br><span class="line">                + 全表扫描</span><br><span class="line">        + 结论</span><br><span class="line">            + 最好出现在前面几个级别</span><br><span class="line">    + 可能用到的索引、实际用的索引、使用的索引长度</span><br><span class="line">        + possible_keys、key</span><br><span class="line">        + key_len</span><br><span class="line">    + 使用索引列等值查询，等值匹配的对象信息ref</span><br><span class="line">        + ref时，等值对象信息</span><br><span class="line">    + 预估读取的记录数</span><br><span class="line">    + 过滤后剩余百分比</span><br><span class="line">        + 更关心连接查询，被驱动执行次数</span><br><span class="line">    + 额外信息extra</span><br><span class="line">        + 情况示例</span><br><span class="line">            + 覆盖索引</span><br><span class="line">                + 要查的即为二级索引的字段 或者 加上主键字段</span><br><span class="line">                + 不用回表操作了</span><br><span class="line">            + 索引条件下推</span><br><span class="line">                + 先把索引条件查完，再回表</span><br><span class="line">            + 文件排序</span><br><span class="line">                + 性能差</span><br><span class="line">+ 小结</span><br><span class="line">    + 不考虑cache，只考虑sql语句本身</span><br><span class="line">    + 不能显示优化工作</span><br><span class="line">    + 不能告诉触发器、存储过程信息、用户自定义函数影响</span><br><span class="line">    + 部分统计估算，非精确</span><br><span class="line">+ 四种输出格式</span><br><span class="line">    + 传统格式</span><br><span class="line">    + JSON格式——信息最详尽</span><br><span class="line">        + 包含计划花费的成本</span><br><span class="line">    + TREE格式</span><br><span class="line">        + 展示层次结构</span><br><span class="line">    + 可视化输出</span><br><span class="line">+ SHOW WARNINGS</span><br><span class="line">    + 查询优化器优化后的语句</span><br></pre></td></tr></table></figure><h2 id="分析优化器执行计划：trace"><a href="#分析优化器执行计划：trace" class="headerlink" title="分析优化器执行计划：trace"></a><strong>分析优化器执行计划：trace</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 开启</span><br><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on; </span><br><span class="line"># 设置大小</span><br><span class="line">set optimizer_trace_max_mem_size=1000000;</span><br><span class="line"># 使用</span><br><span class="line">select * from student where id &lt; 10;</span><br><span class="line">select * from information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 分析执行计划：trace</span><br><span class="line">    + sql语句</span><br><span class="line">    + query字段对应语句的跟踪信息</span><br><span class="line">    + 权限</span><br><span class="line">+ 监控各个使用场景</span><br></pre></td></tr></table></figure><h2 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a><strong>MySQL监控分析视图-sys schema</strong></h2><p><strong>7.1 Sys schema视图使用场景</strong></p><p><strong>索引情况</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1. 查询冗余索引 </span><br><span class="line">select * from sys.schema_redundant_indexes; </span><br><span class="line">#2. 查询未使用过的索引 </span><br><span class="line">select * from sys.schema_unused_indexes; </span><br><span class="line">#3. 查询索引的使用情况 </span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema=&#x27;dbname&#x27; ;</span><br></pre></td></tr></table></figure><p><strong>表相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查询表的访问量 </span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; </span><br><span class="line"># 2. 查询占用bufferpool较多的表 </span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10; </span><br><span class="line"># 3. 查看表的全表扫描情况 </span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;;</span><br></pre></td></tr></table></figure><p><strong>语句相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1. 监控SQL执行的频率 </span><br><span class="line">select db,exec_count,query from sys.statement_analysis order by exec_count desc; </span><br><span class="line">#2. 监控使用了排序的SQL </span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1; </span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL </span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0 order by (tmp_tables+tmp_disk_tables) desc;</span><br></pre></td></tr></table></figure><p><strong>IO相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#1. 查看消耗磁盘IO的文件 </span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br></pre></td></tr></table></figure><p><strong>Innodb</strong> <strong>相关</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1. 行锁阻塞情况 </span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure><h1 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h1><h2 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a><strong>索引失效案例</strong></h2><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li></ul><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p><p><strong>1.1</strong> <strong>全值匹配我最爱</strong> </p><p><strong>1.2</strong> <strong>最佳左前缀法则</strong></p><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</strong>如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><p><strong>1.3</strong> <strong>主键插入顺序</strong></p><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p><p><strong>1.4</strong> <strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></p><p><strong>1.5</strong> <strong>类型转换导致索引失效</strong></p><p><strong>1.6</strong> <strong>范围条件右边的列索引失效</strong></p><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p></blockquote><p><strong>1.7</strong> <strong>不等于(!= 或者&lt;&gt;)索引失效</strong> </p><p><strong>1.8 is null可以使用索引，is not null无法使用索引</strong></p><blockquote><p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)</p><p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p></blockquote><p><strong>1.9 like以通配符%开头索引失效</strong></p><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><p><strong>1.10 OR</strong> <strong>前后存在非索引的列，索引失效</strong></p><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><p><strong>1.11</strong> <strong>数据库和表的字符集统一使用utf8mb4</strong></p><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+ 数据调优维度</span><br><span class="line">    + 索引建立</span><br><span class="line">        + 索引失效、没有利用索引</span><br><span class="line">    + SQL优化</span><br><span class="line">        + 关联太多JOIN</span><br><span class="line">        + 设计缺陷等</span><br><span class="line">    + 调整my.cnf</span><br><span class="line">        + 缓冲、线程数等参数</span><br><span class="line">    + 分库分表</span><br><span class="line">+ SQL查询优化</span><br><span class="line">    + 物理查询优化</span><br><span class="line">        + 索引</span><br><span class="line">        + 表连接</span><br><span class="line">    + 逻辑查询优化</span><br><span class="line">        + sql等价变换</span><br><span class="line">+ 索引失效案例</span><br><span class="line">    + 优化器 - 基于成本开销选择</span><br><span class="line">        + 数据库版本</span><br><span class="line">        + 数据量</span><br><span class="line">        + 数据选择度等</span><br><span class="line">    + 全值匹配</span><br><span class="line">    + 最佳左前缀</span><br><span class="line">        + 联合索引中，要想使用，必须有左边的字段</span><br><span class="line">        + 不能越过前面找后面，用前面的情况下才找下一个</span><br><span class="line">    + 主键插入顺序</span><br><span class="line">        + 防止页面分裂</span><br><span class="line">    + 计算、函数、类型转换等导致索引失效</span><br><span class="line">    + 类型转换导致索引失效</span><br><span class="line">    + 范围条件右边的列 索引失效</span><br><span class="line">        + 联合索引下，范围条件右边的失效</span><br><span class="line">        + WHERE顺序无所谓，优化器自动颠倒顺序</span><br><span class="line">        + 解决</span><br><span class="line">            + 确定等值的放到联合索引前面，范围放到后面</span><br><span class="line">    + 不等于（！=或者&lt;&gt;）索引失效</span><br><span class="line">    + is null可以使用索引，is not null无法使用索引</span><br><span class="line">        + is null相当于等值</span><br><span class="line">        + null值也可以建索引，而且放在null值排在最前面</span><br><span class="line">        + 可以设为0、空字符串代替null场景</span><br><span class="line">    + like以通配符%开头索引失效</span><br><span class="line">        + 开头不知道，不知道匹配谁？</span><br><span class="line">        + B+树懂了很简单</span><br><span class="line">    + OR前后存在非索引的列，索引失效</span><br><span class="line">        + or中非索引的列，还是要全表扫描</span><br><span class="line">    + 数据库和表的字符集统一使用utf8mb3、4</span><br><span class="line">        + 不同字符集比较会转换</span><br><span class="line">+ 总结</span><br><span class="line">    + 单列索引，选择当前query过滤性更好的索引</span><br><span class="line">    + 联合索引</span><br><span class="line">        + 过滤最好的字段越靠前越好</span><br><span class="line">        + 尽量选择包含where更多字段的索引</span><br><span class="line">        + 范围查询放到后面</span><br></pre></td></tr></table></figure><h2 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a><strong>关联查询优化</strong></h2><blockquote><p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p><p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p><p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p></blockquote><h3 id="2-1-Index-Nested-Loop-Join（索引嵌套循环连接）"><a href="#2-1-Index-Nested-Loop-Join（索引嵌套循环连接）" class="headerlink" title="2.1 Index Nested-Loop Join（索引嵌套循环连接）"></a>2.1 Index Nested-Loop Join（索引嵌套循环连接）</h3><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png" alt="image-20220401182649509"></p><h3 id="2-2-Block-Nested-Loop-Join（块嵌套循环连接）"><a href="#2-2-Block-Nested-Loop-Join（块嵌套循环连接）" class="headerlink" title="2.2 Block Nested-Loop Join（块嵌套循环连接）"></a>2.2 Block Nested-Loop Join（块嵌套循环连接）</h3><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png" alt="image-20220401183344880"></p><h3 id="2-3-Hash-Join"><a href="#2-3-Hash-Join" class="headerlink" title="2.3 Hash Join"></a>2.3 Hash Join</h3><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。<ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ 外连接</span><br><span class="line">    + 被驱动表字段添加索引</span><br><span class="line">        + 驱动表取数据，被驱动表根据索引进行查询连接</span><br><span class="line">    + 左外连接要驱动表所有数据</span><br><span class="line">+ 内连接</span><br><span class="line">    + 要两个表共同有的数据</span><br><span class="line">    + 两个表地位一样，查询优化器根据执行成本选择驱动和被驱动表</span><br><span class="line">        + 如果有一个索引，作为被驱动表</span><br><span class="line">        + 一般选择小表为驱动表，小表驱动大表</span><br><span class="line">+ JOIN语句原理</span><br><span class="line">+ 驱动表和被驱动表</span><br><span class="line">+ 简单嵌套循环连接</span><br><span class="line">+ 索引嵌套循环连接</span><br><span class="line">    + 被驱动表添加索引</span><br><span class="line">+ 块嵌套循环连接</span><br><span class="line">    + 参数</span><br><span class="line">        + 块的大小</span><br><span class="line">        + 开启</span><br><span class="line">+ 小结</span><br><span class="line">    + 索引&gt;块&gt;简单</span><br><span class="line">    + 本质减少外层循环数据量</span><br><span class="line">        + 行数*数据量</span><br><span class="line">    + 被驱动表添加索引</span><br><span class="line">    + 增加join buffer size大小，一次缓存更多数据</span><br><span class="line">    + 减少驱动表不必要字段查询</span><br><span class="line">+ 8.0 hash join</span><br><span class="line">    + 废弃BNLJ，使用hash join</span><br><span class="line">    + 小表建立散列表，扫描大表进行探测散列表匹配</span><br></pre></td></tr></table></figure><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a><strong>子查询优化</strong></h2><p><strong>子查询是</strong> <strong>MySQL</strong> <strong>的一项重要的功能，可以帮助我们通过一个</strong> <strong>SQL</strong> <strong>语句实现比较复杂的查询。但是，子查询的执行效率不高。</strong>原因：</p><p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p><strong>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</strong>连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p><blockquote><p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a><strong>排序优化</strong></h2><ol><li><p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p></li><li><p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p></li><li><p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ 子查询效率不高</span><br><span class="line">    + 内查询查询结果，建立临时表</span><br><span class="line">    + 临时表无索引</span><br><span class="line">+ 拆解多次查询，或用JOIN代替子查询</span><br><span class="line">+ 子查询改造——多表查询</span><br><span class="line">+ 排序优化ORDER BY</span><br><span class="line">    + 两种排序方式</span><br><span class="line">        + filesort</span><br><span class="line">            + 内存中进行排序</span><br><span class="line">        + index</span><br><span class="line">            + 索引保证数据有序性</span><br><span class="line">            + 数据量大，需要回表</span><br><span class="line">                + 优化器不使用索引</span><br><span class="line">            + 无需回表</span><br><span class="line">                + 覆盖索引</span><br><span class="line">+ 测试</span><br><span class="line">    + 联合索引，order by</span><br><span class="line">        + 顺序、方向、limit</span><br><span class="line">        + 要方向反，都为反</span><br><span class="line">+ mysql自动选择最优方案</span><br><span class="line">+ filesort算法</span><br><span class="line">    + 双路排序</span><br><span class="line">        + 先取列，排序，再取其他字段</span><br><span class="line">    + 单路排序</span><br><span class="line">        + 读取所有列进行排序</span><br><span class="line">    + sort_buffer容量</span><br><span class="line">        + 读取大小</span><br><span class="line">    + max_length_for_sort_data</span><br><span class="line">    + 查询字段，去掉不需要的字段</span><br></pre></td></tr></table></figure><h2 id="GROUP-BY优化"><a href="#GROUP-BY优化" class="headerlink" title="GROUP BY优化"></a><strong>GROUP BY优化</strong></h2><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h2 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a><strong>优化分页查询</strong></h2><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a</span><br><span class="line">WHERE t.id = a.id;</span><br></pre></td></tr></table></figure><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ group by</span><br><span class="line">    + 和order by差不多</span><br><span class="line">+ order by、distinct、group by等可以放到程序端做</span><br><span class="line">+ 分页查询优化</span><br></pre></td></tr></table></figure><h2 id="优先考虑覆盖索引"><a href="#优先考虑覆盖索引" class="headerlink" title="优先考虑覆盖索引"></a><strong>优先考虑覆盖索引</strong></h2><h3 id="7-1-什么是覆盖索引？"><a href="#7-1-什么是覆盖索引？" class="headerlink" title="7.1 什么是覆盖索引？"></a><strong>7.1</strong> <strong>什么是覆盖索引？</strong></h3><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p><h3 id="7-2-覆盖索引的利弊"><a href="#7-2-覆盖索引的利弊" class="headerlink" title="7.2 覆盖索引的利弊"></a><strong>7.2</strong> <strong>覆盖索引的利弊</strong></h3><p><strong>好处：</strong></p><p><strong>1.</strong> <strong>避免Innodb表进行索引的二次查询（回表）</strong></p><p><strong>2.</strong> <strong>可以把随机IO变成顺序IO加快查询效率</strong></p><p><strong>弊端：</strong></p><p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 覆盖索引</span><br><span class="line">    + 索引包含满足查询结果的数据</span><br><span class="line">    + 查询最多：索引的列 + 主键</span><br><span class="line">+ 规则，总是基于查询优化器成本</span><br><span class="line">+ 覆盖索引</span><br><span class="line">+ 利弊</span><br><span class="line">    + 好处</span><br><span class="line">        + 避免回表</span><br><span class="line">        + 随机io变为顺序io</span><br><span class="line">    + 缺点</span><br><span class="line">        + 索引字段的维护</span><br><span class="line">+ 学的深？</span><br><span class="line">    + 不断去问为什么</span><br></pre></td></tr></table></figure><h2 id="索引条件下推"><a href="#索引条件下推" class="headerlink" title="索引条件下推"></a><strong>索引条件下推</strong></h2><h3 id="8-1-使用前后的扫描过程"><a href="#8-1-使用前后的扫描过程" class="headerlink" title="8.1 使用前后的扫描过程"></a><strong>8.1</strong> <strong>使用前后的扫描过程</strong></h3><p><strong>在不使用ICP索引扫描的过程：</strong></p><p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层 </p><p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p><p><strong>使用ICP扫描的过程：</strong></p><p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p><p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 通过筛选where中包含的索引条目，过滤更多数据</span><br><span class="line">    + 索引字段失效了，使用索引条件下推</span><br><span class="line">+ 再回表操作等</span><br><span class="line">+ 开启、关闭</span><br><span class="line">+ 性能对比</span><br><span class="line">+ 使用条件</span><br><span class="line">    + 二级索引，回表</span><br><span class="line">    + 表访问类型</span><br></pre></td></tr></table></figure><h2 id="其它查询优化策略"><a href="#其它查询优化策略" class="headerlink" title="其它查询优化策略"></a><strong>其它查询优化策略</strong></h2><h3 id="9-1-EXISTS-和-IN-的区分"><a href="#9-1-EXISTS-和-IN-的区分" class="headerlink" title="9.1 EXISTS 和 IN 的区分"></a><strong>9.1 EXISTS</strong> <strong>和</strong> <strong>IN</strong> <strong>的区分</strong></h3><p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p><h3 id="9-2-COUNT-与COUNT-具体字段-效率"><a href="#9-2-COUNT-与COUNT-具体字段-效率" class="headerlink" title="9.2 COUNT(*)与COUNT(具体字段)效率"></a><strong>9.2 COUNT(*)与COUNT(具体字段)效率</strong></h3><p><strong>环节1：</strong><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p><p><strong>环节2：</strong>如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p><p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p><p><strong>环节3：</strong>在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h3 id="9-3-关于SELECT"><a href="#9-3-关于SELECT" class="headerlink" title="9.3 关于SELECT(*)"></a><strong>9.3</strong> <strong>关于SELECT(*)</strong></h3><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p><p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将”*”按序转换成所有列名，这会大大的耗费资源和时间。</p><p>② 无法使用<code>覆盖索引</code></p><h3 id="9-4-LIMIT-1-对优化的影响"><a href="#9-4-LIMIT-1-对优化的影响" class="headerlink" title="9.4 LIMIT 1 对优化的影响"></a><strong>9.4 LIMIT 1</strong> <strong>对优化的影响</strong></h3><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p><h3 id="9-5-多使用COMMIT"><a href="#9-5-多使用COMMIT" class="headerlink" title="9.5 多使用COMMIT"></a><strong>9.5</strong> <strong>多使用COMMIT</strong></h3><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li><p>回滚段上用于恢复数据的信息</p></li><li><p>被程序语句获得的锁</p></li><li><p>redo / undo log buffer 中的空间</p></li><li><p>管理上述 3 种资源中的内部花费</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ exists、in</span><br><span class="line">    + 看表的大小</span><br><span class="line">+ COUNT(*)和COUNT(xxx)</span><br><span class="line">+ 自增id问题</span><br><span class="line">    + 回溯问题</span><br><span class="line">    + 安全性</span><br><span class="line">    + 性能差，需要数据库生成</span><br><span class="line">    + 交互多，自增值需要查询</span><br><span class="line">    + 局部唯一，并非全局唯一</span><br><span class="line">+ 推荐设计</span><br><span class="line">    + UUID - 非单调递增</span><br><span class="line">    + 改造UUID</span><br><span class="line">    + 性能测试</span><br><span class="line">+ 雪花算法等</span><br><span class="line">+ 面试</span><br><span class="line">    + 面试者的思考</span><br><span class="line">    + 问题的看待，交互</span><br></pre></td></tr></table></figure><h1 id="数据库的设计规范"><a href="#数据库的设计规范" class="headerlink" title="数据库的设计规范"></a>数据库的设计规范</h1><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a><strong>范式</strong></h2><h3 id="1-1-范式简介"><a href="#1-1-范式简介" class="headerlink" title="1.1 范式简介"></a><strong>1.1</strong> <strong>范式简介</strong></h3><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</strong>可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h3 id="1-2-范式都包括哪些"><a href="#1-2-范式都包括哪些" class="headerlink" title="1.2 范式都包括哪些"></a><strong>1.2</strong> <strong>范式都包括哪些</strong></h3><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png" alt="image-20220403092826169"></p><h3 id="1-3-键和相关属性的概念"><a href="#1-3-键和相关属性的概念" class="headerlink" title="1.3 键和相关属性的概念"></a><strong>1.3</strong> <strong>键和相关属性的概念</strong></h3><p>这里有两个表：</p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul><h3 id="1-4-第一范式-1st-NF"><a href="#1-4-第一范式-1st-NF" class="headerlink" title="1.4 第一范式(1st NF)"></a><strong>1.4</strong> <strong>第一范式(1st NF)</strong></h3><p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p><h3 id="1-5-第二范式-2nd-NF"><a href="#1-5-第二范式-2nd-NF" class="headerlink" title="1.5 第二范式(2nd NF)"></a><strong>1.5</strong> <strong>第二范式(2nd NF)</strong></h3><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong>如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p><h3 id="1-6-第三范式-3rd-NF"><a href="#1-6-第三范式-3rd-NF" class="headerlink" title="1.6 第三范式(3rd NF)"></a><strong>1.6</strong> <strong>第三范式(3rd NF)</strong></h3><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</strong>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在”A–&gt;B–&gt;C”的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有依赖关系，必须<code>相互独立</code>。</p><h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a><strong>1.7 小结</strong></h3><p>关于数据表的设计，有三个范式要遵循。</p><p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p><p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p><p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p><p><strong>范式的优点：</strong>数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p><p><strong>范式的缺点：</strong>范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+ 不积跬步无以至千里</span><br><span class="line">+ 为什么要数据库设计？</span><br><span class="line">    + 存储空间</span><br><span class="line">    + 数据的完整性</span><br><span class="line">    + 方便数据库应用系统开发</span><br><span class="line">+ 范式</span><br><span class="line">    + 数据表设计的基本原则、规则</span><br><span class="line">    + 1-5范式</span><br><span class="line">        + 越高阶冗余度越低</span><br><span class="line">        + 高阶满足低阶，向下兼容</span><br><span class="line">        + 一般就到3NF、BCNF</span><br><span class="line">+ 键</span><br><span class="line">    + 超键</span><br><span class="line">        + 唯一标识的属性集</span><br><span class="line">    + 候选键</span><br><span class="line">        + 最小超键 </span><br><span class="line">    + 主键</span><br><span class="line">        + 候选键中选择一个</span><br><span class="line">    + 外键</span><br><span class="line">    + 主属性</span><br><span class="line">        + 候选键属性</span><br><span class="line">    + 非主属性</span><br><span class="line">+ 第一范式</span><br><span class="line">    + 每个字段的值原子性</span><br><span class="line">+ 第二范式</span><br><span class="line">    + 每一条记录可唯一标识</span><br><span class="line">        + 有主键</span><br><span class="line">    + 所有非主键字段完全依赖于主键</span><br><span class="line">        + 部分依赖抽出一张表</span><br><span class="line">            + 减少了数据冗余</span><br><span class="line">            + 避免插入异常</span><br><span class="line">            + 避免删除异常</span><br><span class="line">            + 避免更新异常</span><br><span class="line">    + 小结</span><br><span class="line">        + 实体的属性完全依赖于主关键字</span><br><span class="line">        + 如果不完全依赖，分离实体</span><br><span class="line">            + 新实体与原实体一对多的关系</span><br><span class="line">+ 第三范式</span><br><span class="line">    + 不能传递依赖</span><br><span class="line">        + 非主键字段必须和主键字段直接相关</span><br><span class="line">        + 不能相关其他非主键字段</span><br><span class="line">    + 非主键属性只依赖于整个主键，不依赖于其他</span><br><span class="line">+ 小结</span><br><span class="line">    + 原子性</span><br><span class="line">    + 完全依赖</span><br><span class="line">    + 直接相关</span><br><span class="line">    + 优点</span><br><span class="line">        + 减少数据冗余</span><br><span class="line">    + 缺点</span><br><span class="line">        + 降低查询效率</span><br><span class="line">        + 关联多张表</span><br><span class="line">    + 增加冗余，空间换时间</span><br></pre></td></tr></table></figure><h2 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a><strong>反范式化</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1</strong> <strong>概述</strong></h3><p><strong>规范化</strong> <strong>vs</strong> <strong>性能</strong></p><ol><li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p></li><li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p></li><li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p></li><li><p>通过在给定的表中插入计算列，以方便查询</p></li></ol><h3 id="2-2-反范式的新问题"><a href="#2-2-反范式的新问题" class="headerlink" title="2.2 反范式的新问题"></a><strong>2.2</strong> <strong>反范式的新问题</strong></h3><ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h3 id="2-3-反范式的适用场景"><a href="#2-3-反范式的适用场景" class="headerlink" title="2.3 反范式的适用场景"></a><strong>2.3</strong> <strong>反范式的适用场景</strong></h3><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p><p><strong>1.</strong> <strong>增加冗余字段的建议</strong> </p><p>1）这个冗余字段<code>不需要经常进行修改</code></p><p>2）这个冗余字段<code>查询的时候不可或缺</code></p><p><strong>2.</strong> <strong>历史快照、历史数据的需要</strong></p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 反范式化</span><br><span class="line">    + 既要规范化，又要性能</span><br><span class="line">+ 违反第三范式</span><br><span class="line">    + 增加冗余，减少表连接，直接查询</span><br><span class="line">+ 问题</span><br><span class="line">    + 空间换时间</span><br><span class="line">    + 数据不一致问题</span><br><span class="line">        + 修改多表</span><br><span class="line">    + 存储过程，更新、删除等操作消耗资源</span><br><span class="line">    + 数据量小，体现不出性能优势</span><br><span class="line">+ 场景</span><br><span class="line">    + 冗余字段建议</span><br><span class="line">        + 查询用</span><br><span class="line">        + 不经常改</span><br><span class="line">    + 历史快照数据</span><br><span class="line">        + 无需修改，经常查看</span><br><span class="line">    + 数据仓库</span><br></pre></td></tr></table></figure><h2 id="BCNF-巴斯范式"><a href="#BCNF-巴斯范式" class="headerlink" title="BCNF(巴斯范式)"></a>BCNF(巴斯范式)</h2><p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，<strong>它在</strong> <strong>3NF</strong> <strong>的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p><p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于BCNF。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ BC范式：修改的第三范式</span><br><span class="line">    + 只有一个候选键，且只有一个单属性</span><br><span class="line">+ 第四范式</span><br><span class="line">+ 第五范式</span><br><span class="line">    + 完美范式</span><br></pre></td></tr></table></figure><h2 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h2><p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p><h3 id="4-1-ER-模型包括那些要素？"><a href="#4-1-ER-模型包括那些要素？" class="headerlink" title="4.1 ER 模型包括那些要素？"></a>4.1 ER 模型包括那些要素？</h3><p><strong>ER</strong> <strong>模型中有三个要素，分别是实体、属性和关系</strong>。 </p><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p><p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。</p><p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h3 id="4-2-关系的类型"><a href="#4-2-关系的类型" class="headerlink" title="4.2 关系的类型"></a><strong>4.2</strong> <strong>关系的类型</strong></h3><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p><p><code>一对一</code>：指实体之间的关系是一一对应的</p><p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p><p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ 案例</span><br><span class="line">    + 1NF</span><br><span class="line">        + 原子列</span><br><span class="line">    + 2NF</span><br><span class="line">        + 主键</span><br><span class="line">    + 3NF</span><br><span class="line">        + 非主键不依赖</span><br><span class="line">    + 反范式</span><br><span class="line">        + 业务优先原则</span><br><span class="line">+ ER模型</span><br><span class="line">    + 实体</span><br><span class="line">    + 属性</span><br><span class="line">    + 关系</span><br><span class="line">+ 关系的类型</span><br><span class="line">    + 一对一</span><br><span class="line">    + 一对多</span><br><span class="line">    + 多对多</span><br><span class="line">+ 实例分析</span><br><span class="line">+ ER模型转换为数据表</span><br><span class="line">    + 一个多对多的关系转为第三张表</span><br><span class="line">    + 1对1，1对多，可用外键</span><br><span class="line">        + 逻辑外键</span><br><span class="line">+ 转换</span><br><span class="line">    + 多对多</span><br><span class="line">+ 外键等</span><br><span class="line">        + 应用层会进行一致性检查的</span><br></pre></td></tr></table></figure><h2 id="数据表的设计原则"><a href="#数据表的设计原则" class="headerlink" title="数据表的设计原则"></a><strong>数据表的设计原则</strong></h2><p>数据表设计的一般原则：”三少一多” </p><p><strong>1.</strong> <strong>数据表的个数越少越好</strong> </p><p><strong>2.</strong> <strong>数据表中的字段个数越少越好</strong></p><p><strong>3.</strong> <strong>数据表中联合主键的字段个数越少越好</strong></p><p><strong>4.</strong> <strong>使用主键和外键越多越好</strong></p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h2 id="数据库对象编写建议"><a href="#数据库对象编写建议" class="headerlink" title="数据库对象编写建议"></a><strong>数据库对象编写建议</strong></h2><h3 id="6-1-关于库"><a href="#6-1-关于库" class="headerlink" title="6.1 关于库"></a><strong>6.1</strong> <strong>关于库</strong></h3><ol><li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p></li><li><p>【强制】库的名称格式：业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET &#39;utf8&#39;</code>; </p></li><li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。 </p></li><li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p></li></ol><h3 id="6-2-关于表、列"><a href="#6-2-关于表、列" class="headerlink" title="6.2 关于表、列"></a><strong>6.2</strong> <strong>关于表、列</strong></h3><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。 </p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item </p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。 </p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。 </p></li><li><p>【强制】建表必须有comment。 </p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。 </p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_info ( </span><br><span class="line">    `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;, </span><br><span class="line">    `user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;, </span><br><span class="line">    `username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;, </span><br><span class="line">    `email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;, </span><br><span class="line">    `nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;, </span><br><span class="line">    `birthday` date NOT NULL COMMENT &#x27;生日&#x27;, </span><br><span class="line">    `sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;, </span><br><span class="line">    `short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;, </span><br><span class="line">    `user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;, </span><br><span class="line">    `user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;, </span><br><span class="line">    `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, </span><br><span class="line">    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;, </span><br><span class="line">    `user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`), </span><br><span class="line">    UNIQUE KEY `uniq_user_id` (`user_id`), </span><br><span class="line">    KEY `idx_username`(`username`), </span><br><span class="line">    KEY `idx_create_time_status`(`create_time`,`user_review_status`) </span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息&#x27;</span><br></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h3 id="6-3-关于索引"><a href="#6-3-关于索引" class="headerlink" title="6.3 关于索引"></a><strong>6.3</strong> <strong>关于索引</strong></h3><ol><li><p>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值<code>禁止被更新</code>。 </p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。 </p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。 </p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。 </p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h3 id="6-4-SQL编写"><a href="#6-4-SQL编写" class="headerlink" title="6.4 SQL编写"></a><strong>6.4 SQL编写</strong></h3><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。 </p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。 </p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。 </p></li><li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol><h1 id="数据库其它调优策略"><a href="#数据库其它调优策略" class="headerlink" title="数据库其它调优策略"></a>数据库其它调优策略</h1><h2 id="数据库调优的措施"><a href="#数据库调优的措施" class="headerlink" title="数据库调优的措施"></a><strong>数据库调优的措施</strong></h2><h3 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a><strong>1.1</strong> <strong>调优的目标</strong></h3><ul><li>尽可能<code>节省系统资源</code>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操<code> 响应的速度</code>。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h3 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a><strong>1.2</strong> <strong>如何定位调优问题</strong></h3><ul><li><strong>用户的反馈（主要）</strong></li><li><strong>日志分析（主要）</strong></li><li><strong>服务器资源使用监控</strong></li><li><strong>数据库内部状况监控</strong></li><li><strong>其它</strong></li></ul><h3 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a><strong>1.3</strong> <strong>调优的维度和步骤</strong></h3><p><strong>第1步：选择适合的</strong> <strong>DBMS</strong> </p><p><strong>第2步：优化表设计</strong> </p><p><strong>第3步：优化逻辑查询</strong></p><p><strong>第4步：优化物理查询</strong></p><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。</p><p><strong>第5步：使用</strong> <strong>Redis</strong> <strong>或</strong> <strong>Memcached</strong> <strong>作为缓存</strong></p><p><strong>第6步：库级优化</strong> </p><p><strong>1、读写分离</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031025279.png" alt="image-20220403102536170"></p><p><strong>2、数据分片</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031026743.png" alt="image-20220403102618627"></p><h2 id="优化MySQL服务器"><a href="#优化MySQL服务器" class="headerlink" title="优化MySQL服务器"></a><strong>优化MySQL服务器</strong></h2><h3 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a><strong>2.1</strong> <strong>优化服务器硬件</strong></h3><p><strong>服务器的硬件性能直接决定着MySQL数据库的性能。</strong>硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。 </p><p>（1）<code>配置较大的内存</code></p><p>（2）<code>配置高速磁盘系统</code></p><p>（3）<code>合理分布磁盘I/O</code></p><p>（4）<code>配置多处理器</code></p><h3 id="2-2-优化MySQL的参数"><a href="#2-2-优化MySQL的参数" class="headerlink" title="2.2 优化MySQL的参数"></a><strong>2.2</strong> <strong>优化MySQL的参数</strong></h3><ul><li><code>innodb_buffer_pool_size</code>：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的<code>表和索引的最大缓存</code>。它不仅仅缓存<code>索引数据</code>，还会缓存<code>表的数据</code>。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li><li><code>key_buffer_size</code>：表示<code>索引缓冲区的大小</code>。索引缓冲区是所有的<code>线程共享</code>。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在<code>4GB</code>左右的服务器该参数可设置为<code>256M</code>或<code>384M</code>。</li><li><code>table_cache</code>：表示<code>同时打开的表的个数</code>。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</li><li><code>query_cache_size</code>：表示<code>查询缓冲区的大小</code>。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</li><li><code>query_cache_type</code>的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓存区内存。<ul><li>当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定<code>SQL_NO_CACHE</code>，如SELECT SQL_NO_CACHE * FROM tbl_name。 </li><li>当query_cache_type=2时，只有在查询语句中使用<code>SQL_CACHE</code>关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul></li><li><code>sort_buffer_size</code>：表示每个<code>需要进行排序的线程分配的缓冲区的大小</code>。增加这个参数的值可以提高<code>ORDER BY</code>或<code>GROUP BY</code>操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。 </li><li><code>join_buffer_size = 8M</code>：表示<code>联合查询操作所能使用的缓冲区大小</code>，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li><li><code>read_buffer_size</code>：表示<code>每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</code>。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参数的值。默认为64K，可以设置为4M。 </li><li><code>innodb_flush_log_at_trx_commit</code>：表示<code>何时将缓冲区的数据写入日志文件</code>，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。<ul><li>值为<code>0</code>时，表示<code>每秒1次</code>的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li><li>值为<code>1</code>时，表示<code>每次提交事务时</code>将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li><li>值为<code>2</code>时，表示<code>每次提交事务时</code>将数据写入日志文件，<code>每隔1秒</code>将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li></ul></li><li><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的<code>事务日志所使用的缓冲区</code>。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li><li><code>max_connections</code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li><li><code>back_log</code>：用于<code>控制MySQL监听TCP端口时设置的积压请求栈大小</code>。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li><li><code>thread_cache_size</code>：<code>线程池缓存线程数量的大小</code>，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li><li><code>wait_timeout</code>：指定<code>一个请求的最大连接时间</code>，对于4GB左右内存的服务器可以设置为5-10。 </li><li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">+ 吞吐量更大</span><br><span class="line">+ 响应更快</span><br><span class="line">+ 提高性能</span><br><span class="line">+ 定位问题</span><br><span class="line">    + 用户反馈</span><br><span class="line">    + 日志</span><br><span class="line">    + 服务器监控</span><br><span class="line">    + 数据库监控</span><br><span class="line">    + 其他监控</span><br><span class="line">+ 调优维度和步骤</span><br><span class="line">    + 选择合适DBMS</span><br><span class="line">        + 事务、安全</span><br><span class="line">        + NOSQL等</span><br><span class="line">    + 优化表设计</span><br><span class="line">        + 3NF、BCNF</span><br><span class="line">        + 反范式化</span><br><span class="line">        + 数据类型选择</span><br><span class="line">    + 优化逻辑查询</span><br><span class="line">        + 算法优化</span><br><span class="line">        + 小表驱动大表等</span><br><span class="line">    + 优化物理查询</span><br><span class="line">        + 正确使用索引</span><br><span class="line">    + 使用redis或memcached作为缓存</span><br><span class="line">    + 库级优化</span><br><span class="line">        + 主从架构</span><br><span class="line">        + 读写分离</span><br><span class="line">        + 数据分片</span><br><span class="line">+ 优化mysql服务器</span><br><span class="line">    + 硬件优化</span><br><span class="line">        + 内存</span><br><span class="line">        + 磁盘</span><br><span class="line">        + 合理分布磁盘IO</span><br><span class="line">        + cpu</span><br><span class="line">    + 参数优化</span><br><span class="line">        + 缓冲区大小</span><br><span class="line">        + 索引缓冲区大小</span><br><span class="line">        + 同时打开表个数</span><br><span class="line">        + 查询缓冲区大小</span><br><span class="line">        + 查询缓存</span><br><span class="line">        + 排序缓冲区大小</span><br><span class="line">        + 联合查询缓冲区大小</span><br><span class="line">        + 连续扫描</span><br><span class="line">        + 每个线程连续扫描时每个表分配缓冲区大小</span><br><span class="line">        + 事务日志写入时机</span><br><span class="line">        + 事务日志缓冲区大小</span><br><span class="line">        + 最大连接数</span><br><span class="line">        + 控制mysql监听tcp端口时设置的积压请求栈大小</span><br><span class="line">        + 线程池缓存线程数量大小</span><br><span class="line">        + 请求最大连接时间</span><br><span class="line">        + 服务器关闭连接前等待行动的秒数</span><br></pre></td></tr></table></figure><h2 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a><strong>优化数据库结构</strong></h2><h3 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a><strong>3.1</strong> <strong>拆分表：冷热数据分离</strong></h3><h3 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a><strong>3.2</strong> <strong>增加中间表</strong></h3><h3 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a><strong>3.3</strong> <strong>增加冗余字段</strong></h3><h3 id="3-4-优化数据类型"><a href="#3-4-优化数据类型" class="headerlink" title="3.4 优化数据类型"></a><strong>3.4</strong> <strong>优化数据类型</strong></h3><p><strong>情况1：对整数类型数据进行优化。</strong></p><p>遇到整数类型的字段可以用<code>INT 型</code>。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于<code>非负型</code>的数据（如自增ID、整型IP）来说，要优先使用无符号整型<code>UNSIGNED</code>来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多出一倍的存储空间。</p><p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</strong>。</p><p>跟文本类型数据相比，大整数往往占用<code>更少的存储空间</code>，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地址转换成整型数据。</p><p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p><p><strong>情况4：避免使用ENUM类型</strong></p><p><strong>情况5：使用TIMESTAMP存储时间</strong></p><p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p><p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优</strong>。</p><h3 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a><strong>3.5</strong> <strong>优化插入记录的速度</strong></h3><p><strong>1. MyISAM引擎的表：</strong></p><p><strong>① 禁用索引</strong></p><p><strong>② 禁用唯一性检查</strong></p><p><strong>③ 使用批量插入</strong></p><p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p><p><strong>2. InnoDB引擎的表：</strong></p><p> <strong>① 禁用唯一性检查</strong></p><p><strong>② 禁用外键检查</strong></p><p><strong>③ 禁止自动提交</strong></p><h3 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a><strong>3.6</strong> <strong>使用非空约束</strong></h3><p><strong>在设计字段的时候，如果业务允许，建议尽量使用非空约束</strong></p><h3 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a><strong>3.7</strong> <strong>分析表、检查表与优化表</strong></h3><p><strong>1.</strong> <strong>分析表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]…</span><br></pre></td></tr></table></figure><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</strong></p><p><strong>2.</strong> <strong>检查表</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure><p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p><p><strong>3.</strong> <strong>优化表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。 </p><p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p><h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>1、<strong>限定查询的范围</strong></p><p><strong>禁止不带任何限制数据范围条件的查询语句。</strong>比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p><p><strong>2、读写分离</strong></p><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205061535769.png" alt="image-20220506153557761"></p><p><strong>3、垂直拆分</strong></p><p>当数据量级达到 千万级 以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205061536607.png" alt="image-20220506153619860"></p><p><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p><p><strong>4、水平拆分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205061536527.png" alt="image-20220506153649882"></p><p>下面补充一下数据库分片的两种常见方案：</p><p><strong>客户端代理</strong>： <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现</strong>。当当网的Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</p><p><strong>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong>我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</p><h2 id="其它调优策略"><a href="#其它调优策略" class="headerlink" title="其它调优策略"></a><strong>其它调优策略</strong></h2><p>1、<strong>服务器语句超时处理</strong></p><p>在MySQL 8.0中可以设置 服务器语句超时的限制 ，单位可以达到 毫秒级别 。当中断的执行语句超过设置的 毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报给客户端。 </p><p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。</p><p>2、<strong>创建全局通用表空间</strong> </p><p>3、<strong>MySQL 8.0</strong>新特性：隐藏索引对调优的帮助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ 拆分表</span><br><span class="line">    + 冷热数据分离</span><br><span class="line">    + 多个字段进行拆分表</span><br><span class="line">+ 增加中间表</span><br><span class="line">    + 保证数据一致性</span><br><span class="line">+ 增加冗余字段</span><br><span class="line">    + 反范式化</span><br><span class="line">+ 优化数据类型</span><br><span class="line">+ 优化插入记录的速度</span><br><span class="line">+ 使用非空约束</span><br><span class="line">    + 减少存储空间</span><br><span class="line">    + 索引方便</span><br><span class="line">    + 聚合函数等问题</span><br><span class="line">+ 分析表、检查表与优化表</span><br><span class="line">    + 分析表</span><br><span class="line">        + 区分度，帮助创建索引</span><br><span class="line">    + 检查表</span><br><span class="line">    + 优化表</span><br><span class="line">        + 整理碎片</span><br><span class="line">        + TEXT等字段</span><br><span class="line">+ 小结</span><br><span class="line">    + 有利有弊</span><br><span class="line">    + 选择最佳方案即可</span><br><span class="line">+ 大表优化</span><br><span class="line">    + 限制查询的范围</span><br><span class="line">    + 读写分离</span><br><span class="line">    + 垂直拆分</span><br><span class="line">        + 垂直分库</span><br><span class="line">        + 垂直分表</span><br><span class="line">    + 水平拆分</span><br><span class="line">        + 分片策略</span><br><span class="line">        + 方案</span><br><span class="line">            + 客户端代理</span><br><span class="line">            + 中间件代理</span><br><span class="line">+ 其他优化策略</span><br><span class="line">    + 隐藏索引对调优的帮助</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——逻辑架构&amp;存储引擎&amp;InnoDB数据页结构</title>
      <link href="/2022/05/02/MySQL-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84&amp;%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&amp;InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/2022/05/02/MySQL-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84&amp;%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&amp;InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><h2 id="MySQL高级路线"><a href="#MySQL高级路线" class="headerlink" title="MySQL高级路线"></a>MySQL高级路线</h2><ul><li><p>MySQL架构篇</p><ul><li>Linux下MySQL的安装与使用 </li><li>MySQL的数据目录 </li><li>用户与权限管理 </li><li>逻辑架构 </li><li>存储引擎 </li><li>InnoDB数据页结构 </li></ul></li><li><p>索引及调优篇 </p><ul><li>索引 </li><li>性能分析工具的使用 </li><li>索引优化与SQL优化 </li><li>数据库的设计规范 </li><li>数据库其他调优策略 </li></ul></li><li><p>事务篇 </p><ul><li>事务基础知识 </li><li>MySQL事务日志 </li><li>锁 </li><li>多版本并发控制(MVCC) </li></ul></li><li><p>日志与备份篇 </p><ul><li>其它数据库日志 </li><li>主从复制 </li><li>数据库备份与恢复 </li></ul></li></ul><h2 id="Linux下MySQL使用"><a href="#Linux下MySQL使用" class="headerlink" title="Linux下MySQL使用"></a>Linux下MySQL使用</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205021510133.png" alt="image-20220502103127931"></p><h3 id="1-安装前说明"><a href="#1-安装前说明" class="headerlink" title="1. 安装前说明"></a><strong>1.</strong> <strong>安装前说明</strong></h3><p>1、查看是否安装过MySQL</p><ul><li>如果你是用rpm安装, 检查一下RPM PACKAGE：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql # -i 忽略大小写</span><br></pre></td></tr></table></figure><ul><li>检查mysql service：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure><p>2、MySQL的卸载</p><p>关闭 mysql 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure><p>查看当前 mysql 安装状况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure><p>3、卸载上述命令查询出的已安装程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx</span><br></pre></td></tr></table></figure><p>务必卸载干净，反复执行<code>rpm -qa | grep -i mysql</code>确认是否有卸载残留</p><p>4、删除 mysql 相关文件</p><ul><li>查找相关文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure><ul><li>删除上述命令查找出的相关文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf xxx</span><br></pre></td></tr></table></figure><p>5、删除 my.cnf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/my.cnf</span><br></pre></td></tr></table></figure><h3 id="2-MySQL的Linux版安装"><a href="#2-MySQL的Linux版安装" class="headerlink" title="2. MySQL的Linux版安装"></a><strong>2. MySQL的Linux版安装</strong></h3><p><strong>2.1 CentOS7下检查MySQL依赖</strong> </p><p><strong>1.</strong> <strong>检查/tmp临时目录权限（必不可少）</strong></p><p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限。执行 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /tmp</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>安装前，检查依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep libaio</span><br><span class="line">rpm -qa|grep net-tools</span><br></pre></td></tr></table></figure><p><strong>2.2 CentOS7下MySQL安装过程</strong> </p><p><strong>1.</strong> <strong>将安装程序拷贝到/opt目录下</strong></p><p>在mysql的安装文件目录下执行：（必须按照顺序执行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-8.0.25-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-server-8.0.25-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><ul><li><code>rpm</code>是Redhat Package Manage缩写，通过RPM的管理，用户可以把源代码包装成以rpm为扩展名的文件形式，易于安装。</li><li><code>-i</code>, –install 安装软件包</li><li><code>-v</code>, –verbose 提供更多的详细信息输出</li><li><code>-h</code>, –hash 软件包安装的时候列出哈希标记 (和 -v 一起使用效果更好)，展示进度条</li></ul><blockquote><p>若存在mariadb-libs问题，则执行<strong>yum remove mysql-libs</strong>即可</p></blockquote><p><strong>2.3</strong> <strong>查看MySQL版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql --version </span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line">mysqladmin --version</span><br></pre></td></tr></table></figure><p><strong>2.4</strong> <strong>服务的初始化</strong></p><p>为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以 root 身份运行 mysql 服务，需要执行下面的命令初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --user=mysql</span><br></pre></td></tr></table></figure><p>说明： –initialize 选项默认以“安全”模式来初始化，则会为 root 用户生成一个密码并将<code>该密码标记为过期</code>，登录后你需要设置一个新的密码。生成的<code>临时密码</code>会往日志中记录一份。</p><p>查看密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>root@localhost: 后面就是初始化的密码</p><p><strong>2.5</strong> <strong>启动MySQL，查看状态</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">加不加.service后缀都可以</span> </span><br><span class="line">启动：systemctl start mysqld.service </span><br><span class="line">关闭：systemctl stop mysqld.service </span><br><span class="line">重启：systemctl restart mysqld.service </span><br><span class="line">查看状态：systemctl status mysqld.service</span><br></pre></td></tr></table></figure><p><strong>2.6</strong> <strong>查看MySQL服务是否自启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files|grep mysqld.service</span><br></pre></td></tr></table></figure><ul><li>如不是enabled可以运行如下命令设置自启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld.service</span><br></pre></td></tr></table></figure><ul><li>如果希望不进行自启动，运行如下命令设置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable mysqld.service</span><br></pre></td></tr></table></figure><h3 id="3-MySQL登录"><a href="#3-MySQL登录" class="headerlink" title="3. MySQL登录"></a><strong>3. MySQL登录</strong></h3><p><strong>3.1</strong> <strong>首次登录</strong></p><p>通过<code>mysql -hlocalhost -P3306 -uroot -p</code>进行登录，在Enter password：录入初始化密码</p><p><strong>3.2</strong> <strong>修改密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><p><strong>3.3</strong> <strong>设置远程登录</strong></p><p><strong>1.</strong> <strong>确认网络</strong> </p><p>1.在远程机器上使用ping ip地址<code>保证网络畅通</code></p><p>2.在远程机器上使用telnet命令<code>保证端口号开放</code>访问</p><p><strong>2.</strong> <strong>关闭防火墙或开放端口</strong></p><p><strong>方式一：关闭防火墙</strong></p><ul><li>CentOS6 ：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><ul><li>CentOS7：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启防火墙</span></span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机启用防火墙</span> </span><br><span class="line">systemctl enable firewalld.service </span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机禁用防火墙</span> </span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><p><strong>方式二：开放端口</strong></p><ul><li>查看开放的端口号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><ul><li>设置开放的端口号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-service=http --permanent</span><br><span class="line">firewall-cmd --add-port=3306/tcp --permanent</span><br></pre></td></tr></table></figure><ul><li>重启防火墙</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="4-Linux下修改配置"><a href="#4-Linux下修改配置" class="headerlink" title="4. Linux下修改配置"></a><strong>4. Linux下修改配置</strong></h3><ul><li>修改允许远程登陆</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select Host,User from user;</span><br><span class="line">update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><blockquote><p><code>%</code>是个 通配符 ，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果<code>Host=%</code>，表示所有IP都有连接权限。</p><p>注意：在生产环境下不能为了省事将host设置为%，这样做会存在安全问题，具体的设置可以根据生产环境的IP进行设置。</p></blockquote><p>配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了。</p><p><strong>解决方法一：</strong>升级远程连接工具版本</p><p><strong>解决方法二：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure><h3 id="5-字符集的相关操作"><a href="#5-字符集的相关操作" class="headerlink" title="5. 字符集的相关操作"></a><strong>5.</strong> <strong>字符集的相关操作</strong></h3><p><strong>5.1</strong> <strong>各级别的字符集</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;character%&#x27;;</span><br></pre></td></tr></table></figure><ul><li>character_set_server：服务器级别的字符集</li><li>character_set_database：当前数据库的字符集</li><li>character_set_client：服务器解码请求时使用的字符集</li><li>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection </li><li>character_set_results：服务器向客户端返回数据时使用的字符集</li></ul><p><strong>小结</strong></p><ul><li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li><li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li><li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li></ul><p><strong>5.2</strong> <strong>请求到响应过程中字符集的变化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(客户端) --&gt; |&quot;使用操作系统的字符集编码请求字符串&quot;| B(从character_set_client转换为character_set_connection)</span><br><span class="line">B --&gt; C(从character_set_connection转换为具体的列使用的字符集)</span><br><span class="line">C --&gt; D(将查询结果从具体的列上使用的字符集转换为character_set_results)</span><br><span class="line">D --&gt; |&quot;使用操作系统的字符集解码响应的字符串&quot;| A</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">防火墙关闭/端口允许访问</span><br><span class="line">修改配置 - 允许root用户远程连接</span><br><span class="line">密码安全强度</span><br><span class="line">各个级别的字符集</span><br><span class="line">+ utf8和utf8mb4</span><br><span class="line">+ 使用字节数1~4</span><br><span class="line">+ 比较规则</span><br><span class="line">+ 查看字符集和比较规则</span><br><span class="line">+ 修改后只会影响之后创建的</span><br><span class="line">+ 请求到响应过程中的字符集变化</span><br><span class="line">    + 三个系统属性：client、connection、results</span><br><span class="line">    + 过程</span><br><span class="line">    + 统一使用utf-8即可</span><br><span class="line">    + windows下大小写不敏感</span><br><span class="line">+ linux下大小写敏感</span><br><span class="line">+ 大小写设置参数</span><br><span class="line">+ linux下</span><br><span class="line">    + 数据库、表、变量名取分大小写</span><br><span class="line">    + 关键字、函数名不敏感</span><br><span class="line">    + 列名忽略大小写</span><br><span class="line">+ linux可设置大小写规则</span><br><span class="line">+ sql编写建议</span><br><span class="line">+ 关键字、函数名大写</span><br><span class="line">+ sql_mode</span><br><span class="line">    + 数据验证检查</span><br><span class="line">+ 宽松模式</span><br><span class="line">    + 部分错误数据也会接受</span><br><span class="line">+ 严格模式</span><br><span class="line">+ 建议在应用层做校验</span><br><span class="line">+ 查看和设置</span><br><span class="line">    + 临时设置 + 永久设置方式</span><br></pre></td></tr></table></figure><h1 id="MySQL数据目录"><a href="#MySQL数据目录" class="headerlink" title="MySQL数据目录"></a>MySQL数据目录</h1><h2 id="主要目录结构"><a href="#主要目录结构" class="headerlink" title="主要目录结构"></a>主要目录结构</h2><p>1、查看目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure><p>2、数据库文件的存放路径 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;datadir&#x27;; # /var/lib/mysql/</span><br></pre></td></tr></table></figure><p>3、相关命令目录：/usr/bin 和/usr/sbin。</p><p>4、配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</p><h2 id="数据库和文件系统的关系"><a href="#数据库和文件系统的关系" class="headerlink" title="数据库和文件系统的关系"></a>数据库和文件系统的关系</h2><h3 id="1、默认数据库"><a href="#1、默认数据库" class="headerlink" title="1、默认数据库"></a>1、默认数据库</h3><ul><li>mysql<ul><li>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息</li></ul></li><li>information_schema<ul><li>MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为 元数据 。在系统数据库 information_schema 中提供了一些以innodb_sys 开头的表，用于表示内部系统表。 </li></ul></li><li>performance_schema <ul><li>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。</li></ul></li><li>sys <ul><li>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</li></ul></li></ul><h3 id="2、数据库在文件系统中的表示"><a href="#2、数据库在文件系统中的表示" class="headerlink" title="2、数据库在文件系统中的表示"></a>2、数据库在文件系统中的表示</h3><p>这个数据目录下的文件和子目录比较多，除了 information_schema 这个系统数据库外，其他的数据库在数据目录 下都有对应的子目录。</p><h3 id="3、表在文件系统中的表示"><a href="#3、表在文件系统中的表示" class="headerlink" title="3、表在文件系统中的表示"></a>3、表在文件系统中的表示</h3><h4 id="innodb存储引擎模式"><a href="#innodb存储引擎模式" class="headerlink" title="innodb存储引擎模式"></a>innodb存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p><p>为了保存表结构，<code>InnoDB</code>在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于<code>描述表结构的文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p><strong>① 系统表空间（system tablespace）</strong></p><p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>、大小为<code>12M</code>的<code>自拓展</code>文件，这个文件就是对应的<code>系统表空间</code>在文件系统上的表示。</p><p><strong>② 独立表空间(file-per-table tablespace)</strong> </p><p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为<code>每一个表建立一个独立表空间</code>，也就是说我们创建了多少个表，就有多少个独立表空间。使用<code>独立表空间</code>来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure><blockquote><p>MySQL8.0中不再单独提供<code>表名.frm</code>，而是合并在<code>表名.ibd</code>文件中。</p></blockquote><p><strong>③ 系统表空间与独立表空间的设置</strong></p><p>我们可以自己指定使用<code>系统表空间</code>还是<code>独立表空间</code>来存储数据，这个功能由启动参数<code>innodb_file_per_table</code>控制</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span> </span><br><span class="line"><span class="attr">innodb_file_per_table</span>=<span class="number">0</span> <span class="comment"># 0：代表使用系统表空间； 1：代表使用独立表空间</span></span><br></pre></td></tr></table></figure><p><strong>④ 其他类型的表空间</strong></p><p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p><h4 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a>MyISAM存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p><p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在<code>数据目录</code>下对应的数据库子目录下创建了一个专门用于描述表结构的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure><p><strong>2.</strong> <strong>表中数据和索引</strong></p><p>在MyISAM中的索引全部都是<code>二级索引</code>，该存储引擎的<code>数据和索引是分开存放</code>的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构 #MySQL8.0 改为了 b.xxx.sdi</span><br><span class="line">test.MYD 存储数据 (MYData) </span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>举例： 数据库a ， 表b 。 </p><p>1、如果表b采用 InnoDB ，data\a中会产生1个或者2个文件：</p><ul><li>b.frm ：描述表结构文件，字段长度等</li><li>如果采用系统表空间 模式的，数据信息和索引信息都存储在 ibdata1 中</li><li>如果采用 独立表空间 存储模式，data\a中还会产生 b.ibd 文件（存储数据信息和索引信息）</li></ul><p>此外：</p><p>① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较</p><p>规则。而MySQL8.0不再提供db.opt文件。</p><p>② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。</p><p>2、如果表b采用 MyISAM ，data\a中会产生3个文件：</p><ul><li>MySQL5.7 中： b.frm ：描述表结构文件，字段长度等。MySQL8.0 中 b.xxx.sdi ：描述表结构文件，字段长度等</li><li>b.MYD (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式) </li><li>b.MYI (MYIndex)：存放索引信息文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ 数据目录</span><br><span class="line">+ 相关命令目录</span><br><span class="line">+ 配置文件目录</span><br><span class="line">+ 数据库和文件系统的关系</span><br><span class="line">+ 查看默认数据库</span><br><span class="line">    + 4个默认数据库</span><br><span class="line">+ 8.0</span><br><span class="line">    + 表数据、表格式：全都放到idb文件中</span><br><span class="line">+ MyISAM引擎</span><br><span class="line">    + 表分开三个文件</span><br><span class="line">    + 数据、索引、表结构分开存储</span><br><span class="line">+ 不同存储引擎对应存储文件</span><br><span class="line">+ 视图</span><br><span class="line">    + .frm文件</span><br><span class="line">    + 印证了：只存结构不存数据</span><br><span class="line">+ 其他文件</span><br></pre></td></tr></table></figure><h1 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>1、用户的创建修改删除</p><p><strong>登录MySQL服务器</strong></p><p>启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure><ul><li><code>-h参数</code>后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 </li><li><code>-P参数</code>后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。</li><li><code>-u参数</code>后面接用户名，username为用户名。</li><li><code>-p参数</code>会提示输入密码。</li><li><code>DatabaseName参数</code>指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。</li><li><code>-e参数</code>后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;</span><br></pre></td></tr></table></figure><p><strong>创建用户</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER 用户名 [IDENTIFIED BY &#x27;密码&#x27;][,用户名 [IDENTIFIED BY &#x27;密码&#x27;]];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER zhang3 IDENTIFIED BY &#x27;123123&#x27;; # 默认host是 %</span><br><span class="line">CREATE USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p> <strong>修改用户</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user SET USER=&#x27;li4&#x27; WHERE USER=&#x27;wang5&#x27;; </span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>删除用户</strong></p><ul><li><strong>使用DROP方式删除（推荐）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER user[,user]…;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP USER li4 ; # 默认删除host为%的用户</span><br><span class="line">DROP USER &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><ul><li><strong>使用DELETE方式删除（不推荐，有残留信息）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 用户</span><br><span class="line">    + 分类</span><br><span class="line">        + 普通用户</span><br><span class="line">        + root用户</span><br><span class="line">    + 权限管理</span><br><span class="line">    + 访问控制</span><br><span class="line">    + 角色管理</span><br><span class="line">    + 配置文件、系统变量</span><br><span class="line">+ 登录完整语句</span><br><span class="line">+ 创建用户</span><br><span class="line">    + CREATE USER xxx@`xx`</span><br><span class="line">+ 修改用户</span><br><span class="line">    + 直接修改user表</span><br><span class="line">    + 改名字</span><br><span class="line">+ 删除用户</span><br><span class="line">    + DROP √</span><br><span class="line">    + DELECT（删除user表）</span><br><span class="line">        + 系统有残留</span><br></pre></td></tr></table></figure><p>2、用户的密码设置和管理</p><p><strong>设置当前用户密码</strong></p><ul><li><strong>使用ALTER USER命令来修改当前用户密码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER USER() IDENTIFIED BY &#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><ul><li><strong>使用SET语句来修改当前用户密码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><p><strong>修改其它用户密码</strong> </p><ul><li><strong>使用ALTER语句来修改普通用户的密码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER user [IDENTIFIED BY &#x27;新密码&#x27;] </span><br><span class="line">[,user[IDENTIFIED BY &#x27;新密码&#x27;]]…;</span><br></pre></td></tr></table></figure><ul><li><strong>使用SET命令来修改普通用户的密码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;username&#x27;@&#x27;hostname&#x27;=&#x27;new_password&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 修改密码</span><br><span class="line">    + 修改自己的密码</span><br><span class="line">        + alter user</span><br><span class="line">        + set password</span><br><span class="line">    + 修改其他用户的密码</span><br><span class="line">        + alter user</span><br><span class="line">        + set password for</span><br><span class="line">+ 密码管理</span><br><span class="line">    + 过期策略</span><br><span class="line">        + 过期时间</span><br><span class="line">    + 重用策略</span><br><span class="line">        + 基于密码更改数量</span><br><span class="line">        + 基于时间</span><br><span class="line">    + 密码强度</span><br></pre></td></tr></table></figure><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a><strong>权限列表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show privileges;</span><br></pre></td></tr></table></figure><ul><li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li><li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li><li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li><li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li><li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li><li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li><li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li><li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li></ul><p><strong>2.2</strong> <strong>授予权限的原则</strong></p><p>权限控制主要是出于安全因素，因此需要遵循以下几个<code>经验原则</code>：</p><p>1、只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</p><p>2、创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</p><p>3、为每个用户<code>设置满足密码复杂度的密码</code>。 </p><p>4、<code>定期清理不需要的用户</code>，回收权限或者删除用户。</p><p><strong>2.3</strong> <strong>授予权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];</span><br></pre></td></tr></table></figure><ul><li>该权限如果发现没有该用户，则会直接新建一个用户。</li><li>给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;</span><br></pre></td></tr></table></figure><ul><li>授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO joe@&#x27;%&#x27; IDENTIFIED BY &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p><strong>2.4</strong> <strong>查看权限</strong></p><ul><li>查看当前用户权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS; </span><br><span class="line"># 或 </span><br><span class="line">SHOW GRANTS FOR CURRENT_USER; </span><br><span class="line"># 或 </span><br><span class="line">SHOW GRANTS FOR CURRENT_USER();</span><br></pre></td></tr></table></figure><ul><li>查看某用户的全局权限</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;主机地址&#x27;;</span><br></pre></td></tr></table></figure><p><strong>2.5</strong> <strong>收回权限</strong></p><p><strong>注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。</strong></p><ul><li>收回权限命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;</span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#收回全库全表的所有权限 </span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM joe@&#x27;%&#x27;; </span><br><span class="line">#收回mysql库下的所有表的插删改查权限 </span><br><span class="line">REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;</span><br></pre></td></tr></table></figure><ul><li>注意：<code>须用户重新登录后才能生效</code> </li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205021511837.png" alt="image-20220502110615064"></p><h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a><strong>角色管理</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205021511767.png" alt="image-20220502110555394"></p><p><strong>3.1</strong> <strong>创建角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]...</span><br></pre></td></tr></table></figure><p>角色名称的命名规则和用户名类似。如果<code>host_name省略，默认为%</code>，<code>role_name不可省略</code>，不可为空。</p><p><strong>3.2</strong> <strong>给角色赋予权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;];</span><br></pre></td></tr></table></figure><p>上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PRIVILEGES\G</span><br></pre></td></tr></table></figure><p><strong>3.3</strong> <strong>查看角色的权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;role_name&#x27;;</span><br></pre></td></tr></table></figure><p>只要你创建了一个角色，系统就会自动给你一个“<code>USAGE</code>”权限，意思是<code>连接登录数据库的权限</code>。</p><p><strong>3.4</strong> <strong>回收角色的权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE privileges ON tablename FROM &#x27;rolename&#x27;;</span><br></pre></td></tr></table></figure><p><strong>3.5</strong> <strong>删除角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP ROLE role [,role2]...</span><br></pre></td></tr></table></figure><p>注意，<code>如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限</code>。</p><p><strong>3.6</strong> <strong>给用户赋予角色</strong></p><p>角色创建并授权后，要赋给用户并处于<code>激活状态</code>才能发挥作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT role [,role2,...] TO user [,user2,...];</span><br></pre></td></tr></table></figure><p>查询当前已激活的角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURRENT_ROLE();</span><br></pre></td></tr></table></figure><p><strong>3.7</strong> <strong>激活角色</strong></p><p><strong>方式1：使用set default role 命令激活角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT ROLE ALL TO &#x27;kangshifu&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p><strong>方式2：将activate_all_roles_on_login设置为ON</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL activate_all_roles_on_login=ON;</span><br></pre></td></tr></table></figure><p>这条 SQL 语句的意思是，对<code>所有角色永久激活</code>。</p><p><strong>3.8</strong> <strong>撤销用户的角色</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE role FROM user;</span><br></pre></td></tr></table></figure><p><strong>3.9</strong> <strong>设置强制角色(mandatory role)</strong></p><p>方式1：服务启动前设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span> </span><br><span class="line"><span class="attr">mandatory_roles</span>=<span class="string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span></span><br></pre></td></tr></table></figure><p>方式2：运行时设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PERSIST mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后仍然有效</span><br><span class="line">SET GLOBAL mandatory_roles = &#x27;role1,role2@localhost,r3@%.example.com&#x27;; #系统重启后失效</span><br></pre></td></tr></table></figure><h1 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h1><h2 id="逻辑架构剖析"><a href="#逻辑架构剖析" class="headerlink" title="逻辑架构剖析"></a>逻辑架构剖析</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202205021511292.png" alt="image-20220502144716694"></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291130782.png" alt="MySQL服务器端的逻辑架构说明"></p><p><strong>1.1</strong> <strong>第1层：连接层</strong></p><p>系统（客户端）访问<code>MySQL</code>服务器前，做的第一件事就是建立<code>TCP</code>连接。</p><p>经过三次握手建立连接成功后，<code>MySQL</code>服务器对<code>TCP</code>传输过来的账号密码做身份认证、权限获取。</p><ul><li><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></li><li><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></li></ul><p><code>TCP</code>连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p><strong>1.2</strong> <strong>第2层：服务层</strong></p><ul><li><p><strong>SQL Interface: SQL接口</strong></p><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul></li><li><p><strong>Parser:</strong> <strong>解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建<code>语法树</code>，并根据数据字典丰富查询语法树，会<code>验证该客户端是否具有执行该查询的权限</code>。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个<code>执行计划</code>。</li><li>这个执行计划表明应该<code>使用哪些索引</code>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li><li>它使用“<code>选取-投影-连接</code>”策略进行查询。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行<code>选取</code>，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性<code>投影</code>，而不是将属性全部取出以后再进行过滤，将这两个查询条件<code>连接</code>起来生成最终查询结果。</p></li><li><p><strong>Caches &amp; Buffers： 查询缓存组件</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在<code>不同客户端之间共享</code>。 </li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在<code>MySQL 8.0中删除</code>。</li></ul></li></ul><p><strong>1.3</strong> <strong>第3层：引擎层</strong></p><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务层通过API与存储引擎进行通信。</p><p><strong>1.4</strong> <strong>小结</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291131321.png" alt="image-20220329113126234"></p><p>简化为三层结构：</p><ol><li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p></li><li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p></li><li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 处理请求</span><br><span class="line">    + 连接管理</span><br><span class="line">    + 解析与优化</span><br><span class="line">    + 存储引擎</span><br><span class="line">+ 逻辑架构说明</span><br><span class="line">+ 连接层</span><br><span class="line">    + TCP连接</span><br><span class="line">    + 验证用户、权限</span><br><span class="line">    + 连接池、线程池</span><br><span class="line">+ 服务层</span><br><span class="line">    + 解析器</span><br><span class="line">    + 查询优化器</span><br><span class="line">    + 缓存</span><br><span class="line">+ 引擎层</span><br></pre></td></tr></table></figure><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a><strong>SQL执行流程</strong></h2><p><strong>2.1 MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291133116.png" alt="image-20220329113337008"></p><p><strong>MySQL的查询流程：</strong></p><p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的<code>鲁棒性大大降低</code>，只有<code>相同的查询操作才会命中查询缓存</code>。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。</p><p>此外，既然是缓存，那就有它<code>缓存失效的时候</code>。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTER TABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于<code>更新压力大的数据库</code>来说，查询缓存的命中率会非常低。</p><p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p><p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。如果SQL语句正确，则会生成一个语法树。</p><p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p><p><strong>4.</strong> <strong>执行器</strong>：在执行之前需要判断该用户是否<code>具备权限</code>。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291145074.png" alt="image-20220329114541991"></p><p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ 流程</span><br><span class="line">    + 查询缓存</span><br><span class="line">    + 解析器</span><br><span class="line">        + 解析树</span><br><span class="line">    + 查询优化器</span><br><span class="line">    + 查询执行引擎</span><br><span class="line">        + 引擎的api接口查询</span><br><span class="line">    + 返回结果，放到缓存</span><br><span class="line">+ 查询缓存</span><br><span class="line">    + 8.0后舍弃</span><br><span class="line">    + 命中率低</span><br><span class="line">        + 查询语句必须完全一样，key才一样</span><br><span class="line">        + 函数的调用结果不同，无法缓存</span><br><span class="line">        + 缓存失效时候</span><br><span class="line">            + 数据修改</span><br><span class="line">+ 解析器</span><br><span class="line">    + 词法分析</span><br><span class="line">    + 语法分析</span><br><span class="line">    + 生成语法树</span><br><span class="line">+ 优化器</span><br><span class="line">    + 确定sql语句执行路径，全表检索/选择索引</span><br><span class="line">    + 逻辑查询优化、物理查询优化</span><br><span class="line">+ 执行器</span><br><span class="line">    + 调用存储引擎api</span><br><span class="line">+ 总结</span><br><span class="line">    + 分析器</span><br><span class="line">        + 语法分析树</span><br><span class="line">    + 优化器</span><br><span class="line">        + 查询树</span><br><span class="line">    + 执行器</span><br></pre></td></tr></table></figure><h2 id="数据库缓冲池-buffer-pool"><a href="#数据库缓冲池-buffer-pool" class="headerlink" title="数据库缓冲池(buffer pool)"></a><strong>数据库缓冲池(buffer pool)</strong></h2><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请<code>占用内存来作为数据缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><p><strong>3.1</strong> <strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></p><p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291155004.png" alt="image-20220329115517901"></p><p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><p><strong>缓存原则：</strong></p><p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I/O 访问效率进行优化。</p><p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p><p><strong>2.</strong> <strong>查询缓存</strong></p><p>查询缓存是提前把<code>查询结果缓存</code>起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><p><strong>3.2</strong> <strong>缓冲池如何读取数据</strong></p><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203291159111.png" alt="image-20220329115958009"></p><p><strong>3.3</strong> <strong>查看/设置缓冲池的大小</strong></p><p>查看缓冲池的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure><p>设置缓冲池的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_buffer_pool_size = 268435456;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span> </span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">268435456</span></span><br></pre></td></tr></table></figure><p><strong>3.4</strong> <strong>多个Buffer Pool实例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[server]</span> </span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>何查看缓冲池的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_instances&#x27;;</span><br></pre></td></tr></table></figure><p>每个<code>Buffer Pool</code>实例实际占内存空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ 共享池检查</span><br><span class="line">    + 类似查询缓存</span><br><span class="line">    + 绑定变量</span><br><span class="line">        + 提高命中率</span><br><span class="line">+ 数据库缓冲池</span><br><span class="line">    + 磁盘数据加载到内存，缓存</span><br><span class="line">    + 减少与磁盘直接io时间</span><br><span class="line">+ 优先缓存频次高的热数据</span><br><span class="line">+ 预读特性</span><br><span class="line">    + 预先缓存周围数据</span><br><span class="line">+ 查询缓存</span><br><span class="line">    + 结果</span><br><span class="line">+ 缓冲池</span><br><span class="line">    + 表数据</span><br><span class="line">+ 缓冲池读取数据</span><br><span class="line">    + 数据一致性</span><br><span class="line">        + 先改缓冲池，以一定频率刷新到磁盘（刷盘）</span><br><span class="line"></span><br><span class="line">    + 设置缓冲池大小</span><br><span class="line">        + 默认128M</span><br><span class="line">+ 缓冲池实例</span><br><span class="line">    + 拆解多个缓冲池</span><br><span class="line">        + 提高并发</span><br><span class="line">    + 默认为1</span><br><span class="line">+ 问题</span><br><span class="line">    + 刷盘前mysql宕机</span><br><span class="line">    + 多个缓冲池实例刷盘</span><br><span class="line">    + 回滚</span><br></pre></td></tr></table></figure><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="存储引擎设置"><a href="#存储引擎设置" class="headerlink" title="存储引擎设置"></a><strong>存储引擎设置</strong></h2><p>1、查看存储引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br><span class="line"># 或</span><br><span class="line">show engines\G</span><br></pre></td></tr></table></figure><p>2、设置系统默认的存储引擎</p><ul><li>查看默认的存储引擎：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;; </span><br><span class="line">#或</span><br><span class="line">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure><ul><li>修改默认的存储引擎</li></ul><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用<code>InnoDB</code>作为表的存储引擎。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>或者修改<code>my.cnf</code>文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default-storage-engine</span>=MyISAM </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span> </span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure><p>3、设置表的存储引擎：</p><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为<code>不同的表设置不同的存储引擎</code>，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><p>3.1 创建表时指定存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    建表语句; </span><br><span class="line">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><p>3.2 修改表的存储引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure><h2 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a><strong>引擎介绍</strong></h2><p><strong>4.1 InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></p><ul><li>MySQL从3.23.34a开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。 </li><li>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</li><li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li><li>数据文件结构：<ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB是<code>为处理巨大数据量的最大性能设计</code>。<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如：<code>.frm</code>，<code>.par</code>，<code>.trn</code>，<code>.isl</code>，<code>.db.opt</code>等都在MySQL8.0中不存在了。</li></ul></li><li>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</li></ul><p><strong>4.2 MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></p><ul><li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。 </li><li><code>5.5之前默认的存储引擎</code></li><li>优势是访问的<code>速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</li><li>数据文件结构：<ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务</li></ul><p><strong>4.3 Archive</strong> <strong>引擎：用于数据存档</strong></p><p><strong>4.4 Blackhole</strong> <strong>引擎：丢弃写操作，读操作会返回空内容</strong> </p><p><strong>4.5 CSV</strong> <strong>引擎：存储数据时，以逗号分隔各个数据项</strong></p><p><strong>4.6 Memory</strong> <strong>引擎：置于内存的表</strong></p><p><strong>4.7 Federated</strong> <strong>引擎：访问远程表</strong> </p><p><strong>4.8 Merge引擎：管理多个MyISAM表构成的表集合</strong> </p><p><strong>4.9 NDB引擎：MySQL集群专用存储引擎</strong></p><p><strong>5. MyISAM和InnoDB</strong></p><table><thead><tr><th>对比项</th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ 引擎介绍</span><br><span class="line">    + InnoDB</span><br><span class="line">        + 支持事务</span><br><span class="line">        + 外键</span><br><span class="line">        + 行锁</span><br><span class="line">        + 写的处理效率差一些、内存要求高</span><br><span class="line">    + MyISAM</span><br><span class="line">        + 不支持事务</span><br><span class="line">            + 崩溃后无法安全恢复</span><br><span class="line">        + 表锁</span><br><span class="line">        + 访问速度快</span><br><span class="line">        + 数据、索引分开存储</span><br><span class="line">    + InnoDB和MyISAM对比</span><br><span class="line">        + 缓存</span><br><span class="line">            + 索引 + 数据</span><br><span class="line">        + 使用场景</span><br><span class="line">            + 事务、并发、更大资源</span><br><span class="line">    + 基于自己业务场景，自己的存储引擎~~</span><br><span class="line">    + Archive：归档</span><br><span class="line">        + 只支持插入、查询</span><br><span class="line">        + 很好的压缩</span><br><span class="line">        + 行级锁</span><br><span class="line">        + 适合日志、数据采集</span><br><span class="line">    + CSV</span><br><span class="line">    + 方便csv文件数据传输</span><br><span class="line">    + memory</span><br><span class="line">        + 底层只存结构，数据在内存</span><br><span class="line">        + 响应速度快</span><br><span class="line">        + 数据会丢失</span><br><span class="line">    + 其他</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>1、InnoDB表的优势</p><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p><p>InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p><p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 InnoDB不仅支持当前读写，也会缓冲改变的数据到数据流磁盘 。</p><p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用InnoDB可以压缩表和相关的索引，可以 在不影响性能和可用性的情况下创建或删除索引 。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 当处理大数据量时，InnoDB兼顾CPU，以达到最大性能。</p><p>2、InnoDB和ACID模型</p><p>ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只依赖部分ACID特性，以达到更高的性能。下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面。</p><ol><li>原子方面 ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括：自动提交设置。COMMIT语句。ROLLBACK语句。操作INFORMATION_SCHEMA库中的表数据。</li><li>一致性方面 ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性主要包括：InnoDB双写缓存。InnoDB崩溃恢复。</li><li> 隔离方面 隔离是应用于事务的级别，与MySQL相关的特性主要包括：自动提交设置。SET ISOLATION LEVEL语句。InnoDB锁的低级别信息。</li><li>耐久性方面 ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。与MySQL相关的特性有：InnoDB双写缓存，通过innodb_doublewrite配置项配置。配置项innodb_flush_log_at_trx_commit。配置项sync_binlog。配置项innodb_file_per_table。存储设备的写入缓存。存储设备的备用电池缓存。运行MySQL的操作系统。持续的电力供应。备份策略。对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</li></ol><p> 3、InnoDB架构 </p><ol><li>缓冲池 缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</li><li> 更改缓存 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管理。</li><li>自适应哈希索引 自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过–skip-innodb_adaptive_hash_index命令行在服务启动时关闭。</li><li>重做日志缓存 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。</li><li>系统表空间 系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。</li><li>双写缓存 双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。</li><li> 撤销日志 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</li><li>每个表一个文件的表空间 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。</li><li>通用表空间 使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。</li><li>撤销表空间 撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由innodb_undo_tablespaces配置项配置。</li><li>临时表空间 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。</li><li>重做日志 重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</li></ol><h1 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h1><h2 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a><strong>索引及其优缺点</strong></h2><p><strong>1.1</strong> <strong>索引概述</strong></p><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p><p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p><p><strong>1.2</strong> <strong>优点</strong></p><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。</p><p>（2）通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</p><p>（3）在实现数据的参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</p><p>（4）在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</p><p><strong>1.3</strong> <strong>缺点</strong></p><p>（1）创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</p><p>（2）索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间<code>存储在磁盘上</code>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p><p>（3）虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p><h2 id="InnoDB中索引的推演"><a href="#InnoDB中索引的推演" class="headerlink" title="InnoDB中索引的推演"></a>InnoDB中索引的推演</h2><p><strong>2.1</strong> <strong>索引之前的查找</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure><p><strong>1.在一个页中的查找</strong></p><p>假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件<ul><li>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>以其他列作为搜索条件<ul><li>因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</li></ul></li></ul><p><strong>2.在很多页中查找</strong></p><p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能<code>从第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是<code>超级耗时</code>的。</p><p><strong>2.2</strong> <strong>设计索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">    -&gt; c1 INT,</span><br><span class="line">    -&gt; c2 INT,</span><br><span class="line">    -&gt; c3 CHAR(1),</span><br><span class="line">    -&gt; PRIMARY KEY(c1)</span><br><span class="line">    -&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure><p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203300956080.png" alt="image-20220330095642965"></p><ul><li><code>record_type</code>：记录头信息的一项属性，表示记录的类型，<code>0</code>表示普通记录、<code>1</code>表示目录项记录、<code>2</code>表示最小记录、<code>3</code>表示最大记录。</li><li><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</li><li><code>各个列的值</code>：这里只记录在<code>index_demo</code>表中的三个列，分别是<code>c1</code>、<code>c2</code>和<code>c3</code>。 </li><li><code>其他信息</code>：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301000365.png" alt="image-20220330100053271"></p><p>把一些记录放到页里的示意图就是：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301001377.png" alt="image-20220330100150297"></p><p><strong>1.</strong> <strong>一个简单的索引设计方案</strong></p><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而<code>建立一个目录</code>，建这个目录必须完成下边这些事：</p><ul><li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></li><li><strong>给所有的页建立一个目录项。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301004386.png" alt="image-20220330100409306"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li><p>先从目录项中根据<code>二分法</code>快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 12 &lt; 20 &lt; 209 ），它对应的页是<code>页9</code>。 </p></li><li><p>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</p></li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p><p><strong>2. InnoDB中的索引方案</strong> </p><p><strong>① 迭代1次：目录项纪录的页</strong></p><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301028743.png" alt="image-20220330102834658"></p><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<strong>不同点</strong>：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而<code>普通用户记录</code>的<code>record_type</code>值是0。</li><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li><p>先到存储<code>目录项记录</code>的页，也就是页30中通过<code>二分法</code>快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 </p></li><li><p>再到存储用户记录的页9中根据<code>二分法</code>快速定位到主键值为<code>20</code>的用户记录。</p></li></ol><p><strong>② 迭代2次：多个目录项纪录的页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301034997.png" alt="image-20220330103442914"></p><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储目录项记录的<code>页30的容量已满</code>（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li><p>确定<code>目录项记录页</code>我们现在的存储目录项记录的页有两个，即<code>页30</code>和<code>页32</code>，又因为页30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></li><li><p>通过目录项记录页<code>确定用户记录真实所在的页</code>。在一个存储<code>目录项记录</code>的页中通过主键值定位一条目录项记录的方式说过了。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p></li></ol><p><strong>③ 迭代3次：目录项记录页的目录页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301038376.png" alt="image-20220330103847284"></p><p>如图，我们生成了一个存储更高级目录项的<code>页33</code>，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在<code>[1, 320)</code>之间，则到页30中查找更详细的目录项记录，如果主键值<code>不小于320</code>的话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301040190.png" alt="image-20220330104012108"></p><p>这个数据结构，它的名称是<code>B+树</code>。 </p><p><strong>④</strong> <strong>B+Tree</strong></p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页<code>最多存放3条记录</code>，存放目录项记录的页<code>最多存放4条记录</code>。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放<code>100条用户记录</code>，所有存放目录项记录的内节点代表的数据页可以存放<code>1000条目录项记录</code>，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果B+树有2层，最多能存放<code>1000×100=10,0000</code>条记录。</li><li>如果B+树有3层，最多能存放<code>1000×1000×100=1,0000,0000</code>条记录。</li><li>如果B+树有4层，最多能存放<code>1000×1000×1000×100=1000,0000,0000</code>条记录。相当多的记录！！！</li></ul><p>你的表里能存放<code>100000000000</code>条记录吗？所以一般情况下，我们<code>用到的B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速定位记录。</p><p><strong>2.3</strong> <strong>常见索引概念</strong></p><p><strong>1.</strong> <strong>聚簇索引</strong></p><p><strong>特点：</strong></p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li><p><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p></li><li><p>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</p></li><li><p>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。 </p></li></ul></li><li><p>B+树的<code>叶子节点</code>存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ol><p><strong>优点：</strong></p><ul><li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul><p><strong>缺点：</strong></p><ul><li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增ID列为主键</strong></li><li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></li><li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li></ul><p><strong>2.</strong> <strong>二级索引（辅助索引、非聚簇索引）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301050055.png" alt="image-20220330105018965"></p><p><strong>概念：回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到<code>2</code>棵B+树！</p><p><strong>3.</strong> <strong>联合索引</strong></p><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c2和c3列</code>的大小进行排序，这个包含两层含义：</p><ul><li><p>先把各个记录和页按照c2列进行排序。</p></li><li><p>在记录的c2列相同的情况下，采用c3列进行排序</p></li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li><p>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</p></li><li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p></li></ul><p><strong>2.4 InnoDB的B+树索引的注意事项</strong> </p><p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p><p>我们前边介绍B+索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p><p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p><p>我们知道B+树索引的内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿<code>index_demo</code>表为例，假设这个表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项的内容只是<code>索引号+页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的B+树应该长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301110222.png" alt="image-20220330111029120"></p><p>如果我们想要新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>c</code>，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列+页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的c2列的值都是<code>1</code>，那么我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中啊？答案是：对不起，懵了。</p><p>为了让新插入记录能找到自己在哪个页里，我们需要<strong>保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。</strong>所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2列建立二级索引后的示意图实际上应该是这样子的：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301120304.png" alt="image-20220330112018199"></p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列+主键+页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列+主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><p><strong>3.</strong> <strong>一个页面最少可以存储2条记录</strong></p><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问的存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中存放一条记录。费了半天劲只能存放一条真实的用户记录？所以<code>InnoDB的一个数据页至少可以存放两条记录</code></p><h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p><strong>B树索引适用存储引擎如表所示：</strong></p><table><thead><tr><th>索引/存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><p><strong>3.1 MyISAM索引的原理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301133907.png" alt="image-20220330113307813"></p><p><strong>3.2 MyISAM</strong> <strong>与</strong> <strong>InnoDB对比</strong></p><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</strong></p><p><strong>小结两种引擎中索引的区别：</strong></p><p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。 </p><p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数据记录的地址。</p><p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表<code>必须有主键</code>（<code>MyISAM可以没有</code>）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a><strong>索引的代价</strong></h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用<code>16KB</code>的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p>每次对表中的数据进行<code>增、删、改</code>操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值<code>从小到大的顺序排序</code>而组成了<code>双向链表</code>。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些<code>记录移位</code>，<code>页面分裂</code>、<code>页面回收</code>等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><h2 id="MySQL数据结构选择的合理性"><a href="#MySQL数据结构选择的合理性" class="headerlink" title="MySQL数据结构选择的合理性"></a><strong>MySQL数据结构选择的合理性</strong></h2><p><strong>5.1</strong> <strong>二叉搜索树</strong></p><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301636830.png" alt="image-20220330163602743"></p><p>为了提高查询效率，就需要<code>减少磁盘IO数</code>。为了减少磁盘IO的次数，就需要尽量<code>降低树的高度</code>，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><p><strong>5.2 AVL树</strong></p><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301635653.png" alt="image-20220330163506536"></p><p>针对同样的数据，如果我们把二叉树改成<code>M 叉树</code>（M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301637104.png" alt="image-20220330163709022"></p><p><strong>5.3 B-Tree</strong> </p><p>B 树的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301638995.png" alt="image-20220330163803905"></p><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li><p>根节点的儿子数的范围是 [2,M]。 </p></li><li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。 </p></li><li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 </p></li><li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p></li><li><p>所有叶子节点位于同一层。</p></li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要<code>查找的关键字是 9</code>，那么步骤可以分为以下几步：</p><ol><li><p>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </p></li><li><p>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </p></li><li><p>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</p></li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。<code>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</code>，在数据查询中比平衡二叉树效率要高。所以<code>只要树的高度足够低，IO次数足够少，就可以提高查询性能</code>。</p><p><strong>再举例1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301644761.png" alt="image-20220330164411665"></p><p><strong>5.4 B+Tree</strong> </p><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p><ol><li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</p></li><li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p></li><li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， <code>非叶子节点既保存索引，也保存数据记录</code>。 </p></li><li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p></li></ol><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p></blockquote><p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p><blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。</p><p>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p></blockquote><p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p><blockquote><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT(占用4个字节)或BIGINT(占用8个字节)，指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，因为是估算，为了方便计算，这里的K取值为10^3。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree的高度一般都在2~4层</code>。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作</p></blockquote><p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><blockquote><p>1.B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对于B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2、B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所有任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><p><strong>思考题：Hash索引与B+树索引的区别</strong></p><blockquote><p>1、Hash索引<code>不能进行范围查询</code>，而B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。</p><p>2、Hash索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引键合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash索引<code>不支持 ORDER BY 排序</code>，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段ORDER BY 排序优化的作用。同理，我们也无法用Hash索引进行<code>模糊查询</code>，而B+树使用LIKE进行模糊查询的时候，LIKE后面后模糊查询（比如%结尾）的话就可以起到优化作用。</p><p>4、<code>InnoDB不支持哈希索引</code></p></blockquote><h1 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h1><h2 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h2><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。不同存储引擎中<code>存放的格式</code>一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p><p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InooDB存储引擎的数据存储结构。</p><p>1.1 磁盘与内存交互基本单位：页</p><p>InnoDB将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p><p>以<code>页</code>作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。</strong>一个页中可以存储多个行记录。</p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。</p></blockquote><p>1.2 页结构概述</p><p>页a、页b、页c…页n这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个<code>页目录</code>，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。</p><p>1.3 页的上层结构</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301838071.png" alt="image-20220330183814954"></p><p>区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配<code>64个连续的页</code>。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。</p><p>段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。</code>当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p><h2 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h2><p>2.1 第1部分：文件头部和文件尾部</p><p>2.1.1 File Header（文件头部）（38字节）</p><p><strong>作用</strong>：<br>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p><p><strong>大小</strong>：38字节</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td><td><code>4</code>字节</td><td>页的校验和（checksum值）</td></tr><tr><td><code>FIL_PAGE_OFFSET</code></td><td><code>4</code>字节</td><td>页号</td></tr><tr><td><code>FIL_PAGE_PREV</code></td><td><code>4</code>字节</td><td>上一个页的页号</td></tr><tr><td><code>FIL_PAGE_NEXT</code></td><td><code>4</code>字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td><code>8</code>字节</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td><code>FIL_PAGE_TYPE</code></td><td><code>2</code>字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td><code>8</code>字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td><code>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</code></td><td><code>4</code>字节</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><code>FIL_PAGE_OFFSET（4字节）</code>：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。</li><li><code>FIL_PAGE_TYPE（2字节）</code>：这个代表当前页的类型。</li></ul><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没有使用</td></tr><tr><td><code>FIL_PAGE_UNDO_LOG</code></td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td><code>FIL_PAGE_TYPE_SYS</code></td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td><code>FIL_PAGE_INDEX</code></td><td>0x45BF</td><td>索引页，也就是我们所说的<code>数据页</code></td></tr></tbody></table><ul><li><code>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</code>：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间<strong>不需要是物理上的连续，而是逻辑上的连续。</strong></li><li><code>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</code>：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</li></ul><p><strong>作用：</strong></p><p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么<code>在修改后的某个时间需要把数据同步到磁盘中。</code>但是在同步了一半的时候断电了，造成了该页传输的不完整。</p><p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p><ul><li><code>FIL_PAGE_LSN（8字节）</code>：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</li></ul><p>2.1.2 File Trailer（文件尾部）（8字节）</p><ul><li>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。</li><li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</li></ul><p>2.2 第2部分：空闲空间、用户记录和最小最大记录</p><p>2.2.1 Free Space (空闲空间)</p><p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<code>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</code>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去<code>申请新的页</code>了。</p><p>2.2.2 User Records (用户记录)</p><p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p><p>2.2.3 Infimum + Supremum（最小最大记录）</p><p><strong>记录可以比较大小吗</strong>？<br>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是<code>比较主键</code>的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301913664.png" alt="image-20220330191335574"></p><p>这两条记录<code>不是我们自己定义的记录</code>，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301914167.png" alt="image-20220330191446070"></p><p>2.3 第3部分：页目录和页面头部</p><p>2.3.1 Page Directory（页目录）</p><p><strong>为什么需要页目录</strong>？<br>在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是<code>检索效率不高</code>，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<code>专门给记录做一个目录</code>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p><p><strong>页目录，二分法查找</strong></p><ol><li>将所有的记录<code>分成几个组</code>，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li><li>第 1 组，也就是最小记录所在的分组只有 1 个记录；<br>最后一组，就是最大记录所在的分组，会有 1-8 条记录；<br>其余的组记录数量在 4-8 条之间。<br>这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会<code>尽量平分</code>。</li><li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li><li><code>页目录用来存储每组最后一条记录的地址偏移量</code>，这些地址偏移量会按照<code>先后顺序存储</code>起来，每组的地址偏移量也被称之为<code>槽（slot）</code>，每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p><strong>举例：</strong></p><p>现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301921631.png" alt="image-20220330192130497"></p><p>从这个图中我们需要注意这么几点：</p><ul><li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</li><li>注意最小和最大记录的头信息中的n_owned属性<ul><li>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</li><li>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</li></ul></li></ul><p>用箭头指向的方式替代数字，这样更易于我们理解，修改后如下</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301924874.png" alt="image-20220330192413776"></p><p><strong>为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？</strong></p><p>InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1<del>8条之间，剩下的分组中记录的条数范围只能在是 4</del>8 条之间。</p><p>分组是按照下边的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li><li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p>2.3.2 Page Header（页面头部）</p><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录的记录地址（各个已删除的记录通过<code>next_record</code>也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h2 id="InnoDB行格式（或记录格式）"><a href="#InnoDB行格式（或记录格式）" class="headerlink" title="InnoDB行格式（或记录格式）"></a>InnoDB行格式（或记录格式）</h2><p>3.1 指定行格式的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><p>3.2 COMPACT行格式</p><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301939611.png" alt="image-20220330193949517"></p><p>3.2.1 变长字段长度列表</p><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为<code>变长字段</code>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<code>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</code></p><blockquote><p> 注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p></blockquote><p>3.2.2 NULL值列表</p><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。<br><strong>为什么定义NULL值列表？</strong><br>之所以要存储NULL是因为数据都是需要对齐的，如果<code>没有标注出来NULL值的位置</code>，就有可能在查询数据的时候<code>出现混乱</code>。如果使用<code>一个特定的符号</code>放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p><ol><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。</li></ol><blockquote><p>注意：同样顺序也是反过来存放的</p></blockquote><p>3.2.3 记录头信息（5字节）</p><p><img src="https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202203301945235.png" alt="image-20220330194534127"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td><code>预留位1</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>预留位2</code></td><td>1</td><td>没有使用</td></tr><tr><td><code>delete_mask</code></td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td><code>mini_rec_mask</code></td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><code>n_owned</code></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><code>heap_no</code></td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td><code>record_type</code></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示普通记录，<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录</td></tr><tr><td><code>next_record</code></td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><ul><li><code>delete_mask</code>：这个属性标记着当前记录是否被删除，占用1个二进制位。<ul><li>值为0：代表记录并没有被删除</li><li>值为1：代表记录被删除掉了</li></ul></li></ul><p><strong>被删除的记录为什么还在页中存储呢？</strong><br>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要<code>重新排列，导致性能消耗</code>。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><ul><li><code>min_rec_mask</code>：B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</li><li><code>record_type</code>：这个属性表示当前记录的类型，一共有4种类型的记录：<ul><li>0：表示普通记录</li><li>1：表示B+树非叶节点记录</li><li>2：表示最小记录</li><li>3：表示最大记录</li></ul></li><li><code>heap_no</code>：这个属性表示当前记录在本页中的位置。</li></ul><p><strong>怎么不见heap_no值为0和1的记录呢</strong>？<br>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为<code>伪记录</code>或者<code>虚拟记录</code>。这两个伪记录一个代表<code>最小记录</code>，一个代表<code>最大记录</code>。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前</p><ul><li><code>n_owned</code>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li><code>next_record</code>：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<code>地址偏移量</code>。</li></ul><p>3.2.4 记录的真实数据</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p><p>3.3 Dynamic和Compressed行格式</p><p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<code>行溢出</code></p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<code>分页存储</code>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为<code>页的扩展</code>。</p><p>在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧</p><ul><li>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</li><li>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。</li></ul><h2 id="区、段和碎片区"><a href="#区、段和碎片区" class="headerlink" title="区、段和碎片区"></a>区、段和碎片区</h2><p>4.1 为什么要有区？</p><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页为单位</code>来分配存储空间的话，双向链表相邻的两个页之间的<code>物理位置可能离得非常远</code>。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p><p>引入<code>区</code>的概念，一个区就是物理位置上连续的<code>64个页</code>。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=<code>1MB</code>。在表中<code>数据量大</code>的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照<code>区为单位分配</code>，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成<code>一点点空间的浪费</code>（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，<code>功大于过</code>！</p><p>4.2 为什么要有段？</p><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的<code>叶子节点</code>和<code>非叶子节点</code>进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p><p>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><p>4.3 为什么要有碎片区？</p><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以<strong>默认情况下一个只存在几条记录的小表也需要2M的存储空间么？</strong>以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<code>碎片区直属于表空间</code>，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了<code>32个碎片区</code>页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>已经<code>一些完整的区</code>的集合。</p><p>4.4 区的分类</p><p>区大体上可以分为4种类型：</p><ul><li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li><li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面。</li><li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li></ul><p>处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区都是独立的，直属于表空间。而处于<code>FSEG</code>状态的区是附属于某个段的。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——其他数据库对象&amp;8.0新特性</title>
      <link href="/2022/04/27/MySQL-%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1&amp;%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2022/04/27/MySQL-%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1&amp;%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="数据库对象与视图的理解"><a href="#数据库对象与视图的理解" class="headerlink" title="数据库对象与视图的理解"></a>数据库对象与视图的理解</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272241137.png" alt="image-20220427224153204"></p><p>1、视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。</p><p>2、视图</p><ul><li>视图是一种 虚拟表 ，本身是 不具有数据 的，占用很少的内存空间，它是 SQL 中的一个重要概念。</li><li>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。</li><li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li><li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272243698.png" alt="image-20220427224349462"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 常见的数据库对象</span><br><span class="line">    + 表</span><br><span class="line">    + 数据字典</span><br><span class="line">        + 系统表</span><br><span class="line">    + 约束</span><br><span class="line">        + 保证数据完整性</span><br><span class="line">    + 视图</span><br><span class="line">        + 一个或多个数据表里的数据的逻辑显示</span><br><span class="line">    + 索引</span><br><span class="line">        + 提高查询性能</span><br><span class="line">    + 存储过程</span><br><span class="line">    + 存储函数</span><br><span class="line">    + 触发器</span><br><span class="line">        + 事件监听器，完成事件处理</span><br><span class="line">+ 视图</span><br><span class="line">    + 就是原表，只是看到部分的</span><br><span class="line">+ 视图方式存储sql语句</span><br><span class="line">+ 对视图的DML操作等同原表的操作</span><br><span class="line">+ 视图就是简化查询、控制权限</span><br></pre></td></tr></table></figure><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>1、单表视图</p><p>说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。</p><p>说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p><p>2、多表联合视图</p><p>利用视图对数据进行格式化</p><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW 视图名称 [(字段列表)]</span><br><span class="line">AS 查询语句 </span><br><span class="line">[WITH [CASCADED|LOCAL] CHECK OPTION]</span><br><span class="line"></span><br><span class="line">CREATE VIEW 视图名称 </span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 创建视图</span><br><span class="line">+ 针对单表的视图</span><br><span class="line">    + 字段名</span><br><span class="line">    + 聚合函数</span><br><span class="line">+ 针对多表的视图</span><br><span class="line">    + 数据进行格式化</span><br><span class="line">+ 基于视图创建视图</span><br><span class="line">+ 查看视图</span><br><span class="line">    + SHOW TABLES</span><br><span class="line">    + DESC xxx</span><br><span class="line">    + SHOW TABLE STATUS LIEK ‘xxx’</span><br><span class="line">    + SHOW CREATE VIEW xxx</span><br></pre></td></tr></table></figure><h2 id="查看、删除、更新、修改视图"><a href="#查看、删除、更新、修改视图" class="headerlink" title="查看、删除、更新、修改视图"></a>查看、删除、更新、修改视图</h2><p>1、查看视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#语法1：查看数据库的表对象、视图对象</span><br><span class="line">SHOW TABLES;</span><br><span class="line">#语法2：查看视图的结构</span><br><span class="line">DESC / DESCRIBE 视图名称;</span><br><span class="line">#语法3：查看视图的属性信息</span><br><span class="line">#查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等） </span><br><span class="line">SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G </span><br><span class="line">#执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</span><br><span class="line">#语法4：查看视图的详细定义信息</span><br><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure><p>2、更新视图</p><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><p>3、不可更新的视图</p><p>虽然可以更新视图数据，但总的来说，视图作为 虚拟表 ，主要用于 方便查询 ，不建议更新视图的数据。<strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272250426.png" alt="image-20220427225001786"></p><p>4、修改视图</p><p>方式1：使用CREATE <strong>OR REPLACE</strong> VIEW 子句<strong>修改视图</strong></p><p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW empvu80 (id_number, name, sal, department_id) ASSELECT employee_id, first_name || &#x27; &#x27; || last_name, salary, department_id FROM employees WHERE department_id = 80;</span><br></pre></td></tr></table></figure><p>方式2：ALTER VIEW</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER VIEW 视图名称 </span><br><span class="line">AS</span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure><p>5、删除视图只是删除视图的定义，并不会删除基表的数据。</p><p>DROP VIEW IF EXISTS 视图名称;</p><p>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 视图数据和表数据为同一数据</span><br><span class="line">+ 不能更新视图中的数据</span><br><span class="line">    + 视图字段在表中不存在（聚合函数）</span><br><span class="line">+ 视图的行和表的行之间必须存在一对一关系</span><br><span class="line">+ 不能更新</span><br><span class="line">    + JOIN</span><br><span class="line">    + 子查询</span><br><span class="line">    + 聚合函数等</span><br><span class="line">+ 主要为了方便查询！！</span><br><span class="line">+ 优点</span><br><span class="line">    + 操作简单</span><br><span class="line">        + 基于视图简化查询</span><br><span class="line">    + 减少数据冗余</span><br><span class="line">    + 数据安全</span><br><span class="line">        + 控制访问权限</span><br><span class="line">    + 适应需求</span><br><span class="line">        + 可以修改视图而非修改表</span><br><span class="line">    + 分解复杂查询逻辑</span><br><span class="line">        + 多个视图结合完成复杂查询</span><br><span class="line">+ 缺点</span><br><span class="line">    + 维护成本高</span><br><span class="line">    + 表结构改变必须修改视图</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1.</strong> <strong>操作简单</strong></p><p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p><p><strong>2.</strong> <strong>减少数据冗余</strong></p><p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p><p><strong>3.</strong> <strong>数据安全</strong></p><p>MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，<strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。</p><p><strong>4.</strong> <strong>适应灵活多变的需求</strong> 当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p><p><strong>5.</strong> <strong>能够分解复杂的查询逻辑</strong> 数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272252632.png" alt="image-20220427225255586"></p><p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p><h1 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h1><p>MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>1、存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过预先编译的 SQL 语句的封装。</p><p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p><p>2、特点</p><ul><li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力</li><li>减少操作过程中的失误，提高效率</li><li>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）</li><li>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</li></ul><p>3、和视图、函数对比</p><p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 虚拟表 ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p><p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是 没有返回值 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 视图是虚拟表</span><br><span class="line">+ 存储过程是存储SQL</span><br><span class="line">+ 存储过程没有返回值</span><br><span class="line">+ 分类（携带的参数）</span><br><span class="line">    1、没有参数（无参数无返回） </span><br><span class="line">    2、仅仅带 IN 类型（有参数无返回） </span><br><span class="line">    3、仅仅带 OUT 类型（无参数有返回） </span><br><span class="line">    4、既带 IN 又带 OUT（有参数有返回） </span><br><span class="line">    5、带 INOUT（有参数有返回）</span><br></pre></td></tr></table></figure><h2 id="存储过程的创建与调用"><a href="#存储过程的创建与调用" class="headerlink" title="存储过程的创建与调用"></a>存储过程的创建与调用</h2><p>1、参数前面的符号的意思</p><ul><li>IN ：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 IN ，表示输入参数。</li><li>OUT ：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li><li>INOUT ：当前参数既可以为输入参数，也可以为输出参数。</li></ul><p>2、形参类型可以是 MySQL数据库中的任意类型。</p><p>3、 characteristics 表示创建存储过程时指定的对存储过程的约束条件</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272301235.png" alt="image-20220427230133319"></p><p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p><p>5、需要设置新的结束标记</p><p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p><p>比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。</p><p>当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p><p>6、存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) [characteristics ...] </span><br><span class="line">BEGIN</span><br><span class="line">    存储过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 无参数、无返回值</span><br><span class="line">+ 存储过程的调用</span><br><span class="line">    + CALL</span><br><span class="line">+ 带OUT</span><br><span class="line">+ INTO</span><br><span class="line">+ IN参数</span><br><span class="line">+ IN和OUT</span><br><span class="line">    + 返回值不是真正意义上的返回</span><br><span class="line">+ INOUT</span><br><span class="line">idea公司的datagrip可以报错</span><br><span class="line">+ 缺点</span><br></pre></td></tr></table></figure><h2 id="存储函数的创建与调用"><a href="#存储函数的创建与调用" class="headerlink" title="存储函数的创建与调用"></a>存储函数的创建与调用</h2><p>学过的函数：LENGTH、SUBSTR、CONCAT等</p><p>1、说明</p><ul><li>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数</li><li>RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是 强制 的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。</li><li>characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</li><li>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。 </li></ul><p>2、调用存储函数 </p><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是 用户自己定义 的，而内部函数是MySQL 的 开发者定义 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回值类型 [characteristics ...] BEGIN函数体 #函数体中肯定有 RETURN 语句 END</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 存储函数</span><br><span class="line">    + 只有IN参数</span><br><span class="line">    + 一定有return</span><br><span class="line">+ 创建函数</span><br><span class="line">    + 必须指明特性</span><br><span class="line">+ 主要是函数体</span><br><span class="line">    + DML——SELECT查询</span><br><span class="line">+ 对比</span><br><span class="line">    + 存储函数一定有返回值</span><br><span class="line">        + 查询操作使用</span><br><span class="line">    + 存储过程返回值相当于赋给传入的变量、改变引用</span><br><span class="line">        + 更新操作使用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272305923.png" alt="image-20220427230503246"></p><h2 id="存储过程和函数的查看、修改、删除"><a href="#存储过程和函数的查看、修改、删除" class="headerlink" title="存储过程和函数的查看、修改、删除"></a>存储过程和函数的查看、修改、删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名</span><br><span class="line">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]</span><br><span class="line">SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];</span><br><span class="line"></span><br><span class="line">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...]</span><br><span class="line">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125; | COMMENT &#x27;string</span><br><span class="line"></span><br><span class="line">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ 查看</span><br><span class="line">    + 1：SHOW CREATE</span><br><span class="line">    + 2：SHOW STATUS</span><br><span class="line">    + 3：information_schema.Routines</span><br><span class="line">+ 修改</span><br><span class="line">    + 特性、名字</span><br><span class="line">+ 删除</span><br><span class="line">+ 使用建议</span><br><span class="line">    + 优点</span><br><span class="line">        + 一次编译多次使用</span><br><span class="line">        + 减少开发工作量</span><br><span class="line">        + 封装性</span><br><span class="line">        + 安全</span><br><span class="line">            + 使用权限</span><br><span class="line">        + 减少网络传输</span><br><span class="line">    + 缺点</span><br><span class="line">        + 可移植性差</span><br><span class="line">        + 调试难</span><br><span class="line">        + 版本管理不好</span><br><span class="line">        + 不适合高并发</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>优点</p><ul><li>存储过程可以一次编译多次使用。存储过程只在创建时进行编译，之后的使用都不需要重新编译， 这就提升了 SQL 的执行效率。</li><li>可以减少开发工作量。将代码 封装 成模块，实际上是编程的核心思想之一，这样可以把复杂的问题 拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清 晰。</li><li>存储过程的安全性强。我们在设定存储过程的时候可以 设置对用户的使用权限 ，这样就和视图一样具有较强的安全性。 </li><li>可以减少网络传输量。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。 </li><li>良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要 连接一次即可 。 </li></ul><p>缺点</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272308721.png" alt="image-20220427230830120"></p><ul><li>可移植性差。存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li><li>调试困难。只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</li><li>存储过程的版本管理很困难。比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li><li>它不适合高并发的场景。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就不适用了。</li></ul><p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p><h1 id="变量、流程控制与游标"><a href="#变量、流程控制与游标" class="headerlink" title="变量、流程控制与游标"></a>变量、流程控制与游标</h1><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p><p>在 MySQL 数据库中，变量分为系统变量 以及 用户自定义变量 。 </p><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>1、变量由系统定义，不是用户定义，属于 服务器 层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是 编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数值。</p><p>系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。<strong>如果不写，默认会话级别。</strong>静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p><p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272311187.png" alt="image-20220427231148342"></p><p>2、特点</p><ul><li><p>全局系统变量针对于所有会话（连接）有效，但 不能跨重启</p></li><li><p>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</p></li></ul><p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。 </p><p>3、查看系统变量</p><ul><li><p>查看所有或部分系统变量</p></li><li><p>作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p></li><li><p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：</p><p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p><p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 变量</span><br><span class="line">+ 系统变量</span><br><span class="line">    + 全局系统变量</span><br><span class="line">    + 会话系统变量</span><br><span class="line">+ 全局系统变量不能跨重启</span><br><span class="line">+ 会话系统变量，当前会话有效（建立连接）</span><br><span class="line">+ 查看系统变量</span><br><span class="line">+ 查看指定系统变量</span><br><span class="line">    + @@开头表示系统变量</span><br><span class="line">+ 修改系统变量</span><br><span class="line">    + 配置文件</span><br><span class="line">    + set</span><br><span class="line">        + 重启数据库、重启会话连接失效</span><br></pre></td></tr></table></figure><h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><p>1、分类</p><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为 会话用户变量 和 局部变量 。</p><ul><li>会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。</li><li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数 中使用。</li></ul><p>2、会话用户变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#方式1：“=”或“:=” </span><br><span class="line">SET @用户变量 = 值; SET @用户变量 := 值; </span><br><span class="line">#方式2：“:=” 或 INTO关键字 </span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句]; SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br></pre></td></tr></table></figure><p>3、局部变量</p><p>定义：可以使用 DECLARE 语句定义一个局部变量</p><p>作用域：仅仅在定义它的 BEGIN … END 中有效</p><p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    #声明局部变量</span><br><span class="line">    DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值]; </span><br><span class="line">    DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值]; </span><br><span class="line">    #为局部变量赋值 </span><br><span class="line">    SET 变量名1 = 值; </span><br><span class="line">    SELECT 值 INTO 变量名2 [FROM 子句]; </span><br><span class="line">    #查看局部变量的值 </span><br><span class="line">    SELECT 变量1,变量2,变量3; </span><br><span class="line">END</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272317622.png" alt="image-20220427231621416"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 用户变量</span><br><span class="line">    + 会话用户变量@</span><br><span class="line">    + 局部变量</span><br><span class="line">        + BEGIN和END中有效</span><br><span class="line">+ 会话用户变量</span><br><span class="line">    + 创建</span><br><span class="line">        + SET</span><br><span class="line">        + SELECT</span><br><span class="line">    + 使用</span><br><span class="line">        + SELECT</span><br><span class="line">+ 局部变量</span><br><span class="line">    + 创建在过程、函数中</span><br><span class="line">    + 创建在第一句</span><br><span class="line">        + DECLARE</span><br><span class="line">    + 指明类型</span><br></pre></td></tr></table></figure><h2 id="定义条件与处理程序"><a href="#定义条件与处理程序" class="headerlink" title="定义条件与处理程序"></a>定义条件与处理程序</h2><p>1、定义条件 是事先定义程序执行过程中可能遇到的问题， 处理程序 定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p><p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><p>2、定义条件</p><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的 错误条件 关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272319417.png" alt="image-20220427231916497"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#方法1：捕获sqlstate_value </span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;; </span><br><span class="line">#方法2：捕获mysql_error_value </span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;; </span><br><span class="line">#方法3：先定义条件，再调用 </span><br><span class="line">DECLARE no_such_table CONDITION FOR 1146; DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;; </span><br><span class="line">#方法4：使用SQLWARNING </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;; </span><br><span class="line">#方法5：使用NOT FOUND </span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;; </span><br><span class="line">#方法6：使用SQLEXCEPTION </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 定义条件和处理程序</span><br><span class="line">    + 可能遇到的问题</span><br><span class="line">    + 处理方式</span><br><span class="line">+ 定义条件</span><br><span class="line">+ 定义处理程序</span><br><span class="line">    + 处理方式</span><br><span class="line">        + CONTINUE</span><br><span class="line">        + EXIT</span><br><span class="line">        + UNDO</span><br><span class="line">    + 错误类型</span><br><span class="line">        + 错误码、错误字符</span><br><span class="line">        + 错误条件</span><br><span class="line">        + 匹配代码</span><br><span class="line">    + 处理语句</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272321450.png" alt="image-20220427232105832"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ IF</span><br><span class="line">    + 这些是dba用的存储过程，大厂对开发也有要求的</span><br><span class="line">    + 举例1</span><br><span class="line">        + IF XXX</span><br><span class="line">            THEN SELECT XXX</span><br><span class="line">        + ELSEIF XXX</span><br><span class="line">            + THEN SELECT</span><br><span class="line">        + END IF</span><br><span class="line">    + 举例2</span><br><span class="line">        + 输入员工id</span><br><span class="line">            + 根据xx情况判断涨薪资等UPDATE</span><br><span class="line">+ CASE语句</span><br><span class="line">    + CASE XX</span><br><span class="line">        + WHEN XX THEN SELECT</span><br><span class="line">        + WHEN XX THEN SELECT</span><br><span class="line">        + ELSE SELECT XXX</span><br><span class="line">    + END CASE</span><br><span class="line">    + 输入员工id</span><br><span class="line">        + 根据xx情况进行不同的操作</span><br><span class="line">        + case：离散型</span><br><span class="line">+ 三种循环</span><br><span class="line">    + loop</span><br><span class="line">    + while</span><br><span class="line">    + repeat</span><br><span class="line">    + （标签）: LOOP</span><br><span class="line">        + XXX</span><br><span class="line">        + IF XX THEN LEAVE （标签）</span><br><span class="line">    + END LOOP（标签）</span><br><span class="line">    + while</span><br><span class="line">        + 循环条件</span><br><span class="line">        + 循环体</span><br><span class="line">        + 迭代条件</span><br><span class="line">    + repeat</span><br><span class="line">        + 上来必先执行一次</span><br><span class="line">    + WHILE √</span><br><span class="line">+ leave</span><br><span class="line">    + break</span><br><span class="line">+ iterate</span><br><span class="line">    + continue</span><br></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>1、什么是游标（或光标）</p><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一 条记录 ，并对记录的数据进行处理。</p><p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让</strong> <strong>SQL</strong> <strong>这种面集合的语言有了面向过程开发的能力。</strong></p><p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。</p><p>MySQL中游标可以在存储过程和函数中使用。</p><p>我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272325819.png" alt="image-20220427232523168"></p><p>2、<strong>第一步，声明游标</strong></p><p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p><p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集。</p><p>3、<strong>第二步，打开游标</strong></p><p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。</p><p>4、<strong>第三步，使用游标（从游标中取得数据）</strong></p><p>注意：<strong>游标的查询结果集中的字段数，必须跟</strong> <strong>INTO</strong> <strong>后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误</p><p>5、<strong>第四步，关闭游标</strong></p><p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。</p><p>6、游标是 MySQL 的一个重要的功能，为 <strong>逐条读取</strong> 结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p><p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行 <strong>加锁</strong> ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会 <strong>消耗系统资源</strong> ，造成内存不足，这是因为游标是在内存中进行的处理。</p><p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p><p>7、MySQL8全局变量持久化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272328980.png" alt="image-20220427232835869"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR FOR select_statement;</span><br><span class="line">OPEN cursor_name</span><br><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 游标</span><br><span class="line">    + 对每一条记录进行处理</span><br><span class="line">+ 使用步骤</span><br><span class="line">    + 声明游标</span><br><span class="line">        + DECLAER XXX CURSOR FOR XXX</span><br><span class="line">    + 打开游标</span><br><span class="line">        + OPEN</span><br><span class="line">    + 使用游标（从游标中获取数据）</span><br><span class="line">        + FETCH</span><br><span class="line">    + 关闭游标</span><br><span class="line">        + CLOSE</span><br><span class="line">+ 举例cursor</span><br><span class="line">    + 声明局部变量</span><br><span class="line">    + 声明游标</span><br><span class="line">    + 打开游标</span><br><span class="line">    + 循环</span><br><span class="line">        + 使用游标</span><br><span class="line">        + 循环体</span><br><span class="line">    + 关闭游标</span><br><span class="line">+ 小结</span><br><span class="line">    + 优点</span><br><span class="line">        + 逐条读取数据</span><br><span class="line">    + 缺点</span><br><span class="line">        + 使用游标，会对数据加锁</span><br><span class="line">        + 影响系统效率和内存</span><br><span class="line">+ MYSQL8.0</span><br><span class="line">    + 全局变量的持久化</span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如 商品信息 和 库存信息 分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。</p><p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用 事务 包裹起来，确保这两个操作成为一个 原子操作 ，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很 容易忘记其中的一步 ，导致数据缺失。</p><p>这个时候，咱们可以使用触发器。<strong>你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。</strong>这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL从 5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。</p><p>触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作。</p><p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>1、CREATE TRIGGER</p><p>2、参数</p><ul><li>表名 ：表示触发器监控的对象。</li><li>BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</li><li>INSERT|UPDATE|DELETE ：表示触发的事件。<ul><li>INSERT 表示插入记录时触发；</li><li>UPDATE 表示更新记录时触发；</li><li>DELETE 表示删除记录时触发</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名称 </span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名 </span><br><span class="line">FOR EACH ROW</span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 触发器</span><br><span class="line">    + 事件操作，触发监听器，执行任务</span><br><span class="line">+ 触发器的创建</span><br><span class="line">    + 作用在某个表上</span><br><span class="line">    + INSERT、UPDATE、DELETE时</span><br><span class="line">    + BEFORE、AFTER进行操作</span><br><span class="line">    + 执行语句</span><br><span class="line">+ 不忘初心！！</span><br><span class="line">+ 创建触发器</span><br><span class="line">    + 插入触发器</span><br><span class="line">+ 示例</span><br><span class="line">    + NEW</span><br><span class="line">        + 获取插入...的那条记录</span><br><span class="line">    + 手动抛出错误</span><br><span class="line">        + SIGNAL xxx</span><br></pre></td></tr></table></figure><h2 id="查看、删除触发器"><a href="#查看、删除触发器" class="headerlink" title="查看、删除触发器"></a>查看、删除触发器</h2><p>1、看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等</p><p>方式1：查看当前数据库的所有触发器的定义</p><p>方式2：查看当前数据库中某个触发器的定义</p><p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息</p><p>2、触发器也是数据库对象，删除触发器也用DROP语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS\G </span><br><span class="line">SHOW CREATE TRIGGER 触发器名 </span><br><span class="line">SELECT * FROM information_schema.TRIGGERS;</span><br><span class="line"></span><br><span class="line">DROP TRIGGER IF EXISTS 触发器名称;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1、优点</p><ul><li><strong>触发器可以确保数据的完整性</strong>。</li><li><strong>触发器可以帮助我们记录操作日志。</strong><ul><li>利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。</li></ul></li><li><strong>触发器还可以用在操作数据前，对数据进行合法性检查。</strong></li></ul><p>2、缺点</p><ul><li><strong>触发器最大的一个问题就是可读性差。</strong><ul><li>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能 不受应用层的控制 。这对系统维护是非常有挑战的。</li></ul></li><li><strong>相关数据的变更，可能会导致触发器出错。</strong><ul><li>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率</li></ul></li></ul><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 查看、删除触发器</span><br><span class="line">    + SHOW TRIGGERS</span><br><span class="line">    + DROP TRIGGER</span><br><span class="line">+ 优点</span><br><span class="line">        + 保证数据的完整性</span><br><span class="line">            + 更新其他表的数据</span><br><span class="line">        + 记录操作日志</span><br><span class="line">            + 每次操作记录日志</span><br><span class="line">        + 对数据进行合法性检验</span><br><span class="line">            + 防止录入错误数据</span><br><span class="line">    + 缺点</span><br><span class="line">        + 可读性差</span><br><span class="line">            + 不受应用层控制</span><br><span class="line">        + 数据的更新，可能造成触发器出错</span><br><span class="line">+ 注意点</span><br><span class="line">    + 外键约束引起表的改动，触发器不会激活</span><br><span class="line">+ 复制表结构</span><br><span class="line">+ 触发器</span><br><span class="line">    + 备份存储删除的记录：回收站</span><br></pre></td></tr></table></figure><h1 id="MySQL8-0新特性"><a href="#MySQL8-0新特性" class="headerlink" title="MySQL8.0新特性"></a>MySQL8.0新特性</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><p>新特性</p><p>1.更简便的NoSQL</p><p>2.更好的索引</p><p>3.更完善的JSON支持</p><p>4.安全和账户管理</p><p>5.InnoDB的变化</p><p>6.数据字典</p><p>7.原子数据 </p><p>8.资源管理 </p><p>9.字符集支持</p><p>10.优化器增强</p><p>11.公用表表达式</p><p>12.窗口函数 </p><p>13.正则表达式支持</p><p>14.内部临时表</p><p>15.日志记录</p><p>16.备份锁</p><p>17.增强的MySQL复制</p><p>移除特性</p><p>1.查询缓存</p><p>2.加密相关</p><p>3.空间函数相关</p><p>4.N和NULL</p><p>5.mysql_install_db </p><p>6.通用分区处理程序 </p><p>7.系统和状态变量信息 </p><p>8.mysql_plugin工具</p><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>1、使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显然，<strong>在需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好</strong>。 </p><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数可以分为 静态窗口函数 和 动态窗口函数 。</p><ul><li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li><li>动态窗口函数的窗口大小会随着记录的不同而变化。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272342356.png" alt="image-20220427234258613"></p><p>2、语法结构</p><p>函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]） </p><p>函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</p><ul><li>OVER 关键字指定函数窗口的范围。<ul><li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li><li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li>窗口名：为窗口设置一个别名，用来标识窗口。</li><li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li><li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li><li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li></ul><p>3、序号函数、分布函数、前后函数、首尾函数、其他函数</p><p>4、窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ 新特性</span><br><span class="line">    + nosql支持</span><br><span class="line">    + 更好的索引</span><br><span class="line">    + JSON支持</span><br><span class="line">    + 安全和账户管理</span><br><span class="line">    + InnoDB的优化</span><br><span class="line">    + 数据字典</span><br><span class="line">    + 原子DDL</span><br><span class="line">    + 资源管理</span><br><span class="line">    + 默认字符集</span><br><span class="line">    + 优化器增强</span><br><span class="line">    + 公用表表达式</span><br><span class="line">        + 替换子查询</span><br><span class="line">    + 窗口函数</span><br><span class="line">    + 正则表达式</span><br><span class="line">    + 内部临时表</span><br><span class="line">    + 日志</span><br><span class="line">    + 备份锁</span><br><span class="line">    + mysql复制</span><br><span class="line">+ 新特性1：窗口函数</span><br><span class="line">    + 方式一</span><br><span class="line">        + 使用临时表</span><br><span class="line">    + 方式二：窗口函数</span><br><span class="line">+ 窗口函数</span><br><span class="line">    + 介绍窗口函数</span><br><span class="line">+ 语法结构</span><br><span class="line">    + partition by xxx</span><br><span class="line">        + 分区</span><br><span class="line">    + 函数</span><br><span class="line">+ 分布函数</span><br><span class="line">+ LAG函数、LEAD函数</span><br><span class="line">    + 查询差值</span><br><span class="line">+ 首尾函数</span><br><span class="line">    + FIRST</span><br><span class="line">    + LAST</span><br><span class="line">+ NTILE：分组</span><br></pre></td></tr></table></figure><h2 id="公用表表达式"><a href="#公用表表达式" class="headerlink" title="公用表表达式"></a>公用表表达式</h2><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。依据语法结构和执行方式的不同，公用表表达式分为 </p><p>普通公用表表达式 和 递归公用表表达式 2 种。</p><p>1、<strong>普通公用表表达式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WITH CTE名称 </span><br><span class="line">AS （子查询）</span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure><p>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。</p><p>2、<strong>递归公用表表达式</strong></p><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是<strong>可以调用自己</strong>。</p><p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。这里的<strong>种子查询，意思就是获得递归的初始值</strong>。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE CTE名称 </span><br><span class="line">AS （子查询）</span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure><p>3、总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。</p><p>4、公用表表达式的作用是可以代替子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——DDL&amp;DML&amp;DCL使用篇</title>
      <link href="/2022/04/26/MySQL-DDL&amp;DML&amp;DCL%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
      <url>/2022/04/26/MySQL-DDL&amp;DML&amp;DCL%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="创建和管理表"><a href="#创建和管理表" class="headerlink" title="创建和管理表"></a>创建和管理表</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p><p>因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是 数据库服务器 </p><p>、 数据库 、 数据表 、数据表的行与列 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 数据存储的过程</span><br><span class="line">    + 创建数据库</span><br><span class="line">    + 确认字段</span><br><span class="line">    + 创建数据表</span><br><span class="line">    + 插入数据</span><br><span class="line">+ 标识符命名规则</span><br><span class="line">    + 数据库名、表名、字段名</span><br><span class="line">        + 长度、字符限制</span><br><span class="line">        + 不能同名、没有保留字限制</span><br><span class="line">        + 保证字段名、类型一致性</span><br><span class="line">+ 创建和管理数据库</span><br><span class="line">    + 创建</span><br><span class="line">        + CREATE DATABASE (IF NOT EXISTS)  xxx </span><br><span class="line">        + 字符集</span><br><span class="line">        + 判断存在</span><br><span class="line">    + 管理</span><br><span class="line">        + 查看当前连接中的数据库</span><br><span class="line">            + SHOW DATABASES</span><br><span class="line">        + 使用数据库</span><br><span class="line">            + USE xxx</span><br><span class="line">        + 查看当前数据库表</span><br><span class="line">            + SHOW TABLES</span><br><span class="line">    + 修改（一般不会，需求文档提前都有规则）</span><br><span class="line">        + 修改字符集</span><br><span class="line">            + ALTER DATABASE</span><br><span class="line">    + 删除</span><br><span class="line">        + DROP DATABASE</span><br></pre></td></tr></table></figure><h2 id="创建和管理数据库"><a href="#创建和管理数据库" class="headerlink" title="创建和管理数据库"></a>创建和管理数据库</h2><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] 表名( </span><br><span class="line">    字段1, 数据类型 [约束条件] [默认值], </span><br><span class="line">    字段2, 数据类型 [约束条件] [默认值], </span><br><span class="line">    字段3, 数据类型 [约束条件] [默认值],</span><br><span class="line">    ……[表约束条件] </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p><p>方式二：</p><p>使用 AS subquery 选项，将创建表和插入数据结合起来。</p><p>指定的列和子查询中的列要一一对应。</p><p>通过列名和默认值定义列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE emp1 AS SELECT * FROM employees; </span><br><span class="line">CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; </span><br><span class="line">-- 创建的emp2是空表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 创建表</span><br><span class="line">    + 方式一</span><br><span class="line">        + CREATE TABLE (IF NOT EXISTS) xxx ()</span><br><span class="line">        + 字段，数据类型，约束条件，默认值</span><br><span class="line">        + 默认使用数据库字符集——数据库：默认配置文件字符集</span><br><span class="line">    + 方式二：基于现有的表</span><br><span class="line">        + 基于查询语句创建表，别名作为字段名</span><br><span class="line">            + 可以实现表的复制</span><br><span class="line">            + 默认有数据：查询到的数据</span><br><span class="line">                + 不要表数据：全部过滤掉</span><br><span class="line">        + CREATE TABLE xxx AS</span><br><span class="line">    + 查看表的信息</span><br><span class="line">        + DESC xxx</span><br></pre></td></tr></table></figure><h2 id="修改表、删除、清空表"><a href="#修改表、删除、清空表" class="headerlink" title="修改表、删除、清空表"></a>修改表、删除、清空表</h2><p>使用 ALTER TABLE 语句可以实现：</p><p>向已有的表中添加列、修改现有表中的列</p><p>删除现有表中的列、重命名现有表中的列</p><p>删除表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];</span><br><span class="line">#IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</span><br></pre></td></tr></table></figure><p>TRUNCATE TABLE语句：</p><p>删除表中所有的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE detail_dept;</span><br><span class="line"># TRUNCATE语句不能回滚，而使用 DELETE 语句删除数据，可以回滚</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 修改表ALTER TABLE</span><br><span class="line">+ 添加一个字段</span><br><span class="line">        + ADD</span><br><span class="line">        + 指定字段位置</span><br><span class="line">    + 修改字段</span><br><span class="line">        + MODIFY</span><br><span class="line">        + 数据类型、长度、默认值</span><br><span class="line">    + 重命名字段</span><br><span class="line">        + CHANGE</span><br><span class="line">    + 删除字段</span><br><span class="line">        + DROP</span><br><span class="line">+ 重命名表</span><br><span class="line">    + RENAME TABLE</span><br><span class="line">    + ALTER TABLE RENAME TO</span><br><span class="line">+ 删除表</span><br><span class="line">    + DELETE TABLE</span><br><span class="line">+ 清空表数据</span><br><span class="line">    + TRUNCATE TABLE</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ DCL中COMMIT与ROLLBACK的使用</span><br><span class="line">    + COMMIT</span><br><span class="line">    +ROLLBACK</span><br><span class="line"></span><br><span class="line">    + TRUNCATE TBALE</span><br><span class="line">        + DDL</span><br><span class="line">    + DELETE TABLE</span><br><span class="line">    + DDL和DML</span><br><span class="line">        + DDL操作一旦执行，不可回滚</span><br><span class="line">        + DML操作默认情况，一旦执行不可回滚</span><br><span class="line">            + 但是执行DML之前，执行SET autocommit = FALSE</span><br><span class="line">            + 执行的DML操作可以回滚</span><br><span class="line">    + DDL操作无法回滚</span><br></pre></td></tr></table></figure><p>1、阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p><p>2、MySQL8新特性—DDL的原子化</p><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即 DDL操作要么成功要么回滚 。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ TRUNCATE速度快，占用资源少</span><br><span class="line">    + 有可能造成事故，不建议使用</span><br><span class="line">+ 必备字段</span><br><span class="line">    + id、数据创建时间、修改时间</span><br><span class="line">+ 业务的名称_表的作用</span><br><span class="line">+ 库名和应用名称保持一致</span><br><span class="line">+ 删除表备份</span><br><span class="line">+ ALTER TABLE注意</span><br><span class="line">+ DDL支持原子化</span><br><span class="line">    + 要么成功要么回滚</span><br><span class="line">    + 不会一半执行成功</span><br></pre></td></tr></table></figure><h1 id="处理之增删改"><a href="#处理之增删改" class="headerlink" title="处理之增删改"></a>处理之增删改</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>1、VALUES的方式添加</p><ul><li>   为表的所有字段按默认顺序插入数据</li><li>   为表的指定字段插入数据</li><li>   同时插入多条记录</li></ul><p>2、将查询结果插入到表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 目标表名 (tar_column1 [, tar_column2, …, tar_columnn]) </span><br><span class="line">SELECT (src_column1 [, src_column2, …, src_columnn]) </span><br><span class="line">FROM 源表名 [WHERE condition]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ INSERT</span><br><span class="line">    + VALUE</span><br><span class="line">        + 不指明字段</span><br><span class="line">        + 指明字段</span><br><span class="line">    + SELECT</span><br><span class="line">+ VALUE</span><br><span class="line">+ SELECT</span><br><span class="line">    + 字段范围问题，确保添加成功</span><br></pre></td></tr></table></figure><h2 id="更新、删除数据"><a href="#更新、删除数据" class="headerlink" title="更新、删除数据"></a>更新、删除数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">SET column1=value1, column2=value2, … , column=valuen [WHERE condition]</span><br></pre></td></tr></table></figure><p>如果需要回滚数据：</p><p>需要保证在DML前，进行设置：SET AUTOCOMMIT = FALSE;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ UPDATE SET WHERE</span><br><span class="line">+ 批量修改数据</span><br><span class="line">+ 可能失败（约束造成）</span><br><span class="line">+ DELETE FROM WHERE</span><br><span class="line">+ 可以取消自动提交</span><br><span class="line">+ 计算列</span><br><span class="line">    + GENERATED ALWAYS AS (xxx) VIRTUAL</span><br><span class="line">+ 自动计算</span><br></pre></td></tr></table></figure><h2 id="MySQL8新特性：计算列"><a href="#MySQL8新特性：计算列" class="headerlink" title="MySQL8新特性：计算列"></a>MySQL8新特性：计算列</h2><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tb1( </span><br><span class="line">    id INT, </span><br><span class="line">    a INT,</span><br><span class="line">    b INT,</span><br><span class="line">    c INT GENERATED ALWAYS AS (a + b) VIRTUAL </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h1><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p><img src="C:\Users\16374\AppData\Roaming\Typora\typora-user-images\image-20220426144246127.png" alt="image-20220426144246127"></p><p>1、可选属性：</p><ul><li>M宽度（不推荐）</li><li>UNSIGNED（无符号、非负）</li><li>ZEROFILL（填充0）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 可选属性</span><br><span class="line">    + ZEROFILL 显示宽度</span><br><span class="line">        + 不足五位用0填充</span><br><span class="line">        + 默认UNSIGNED</span><br><span class="line">        + 8.0后不推荐使用</span><br><span class="line">    + UNSIGNED</span><br><span class="line">        + 无符号范围、全为正数</span><br></pre></td></tr></table></figure><p>2、选择</p><ul><li>可靠性</li><li>系统故障产生的成本远大于几个字段空间成本</li></ul><p><img src="C:\Users\16374\AppData\Roaming\Typora\typora-user-images\image-20220426144537254.png" alt="image-20220426144537254"></p><h2 id="浮点数、定点数、位类型"><a href="#浮点数、定点数、位类型" class="headerlink" title="浮点数、定点数、位类型"></a>浮点数、定点数、位类型</h2><p>1、浮点数和定点数类型的特点是可以 处理小数 ，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。 </p><ul><li><p>FLOAT 表示单精度浮点数；</p></li><li><p>DOUBLE 表示双精度浮点数</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271425809.png" alt="image-20220427142539862"></p><p>2、<strong>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong>，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。 因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。</p><p> 3、MySQL中的定点数类型只有 DECIMAL 一种类型。</p><p>DECIMAL(M,D),DEC,NUMERIC</p><ul><li>M+2字节 </li><li>有效范围由M和D决定</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271427039.png" alt="image-20220427142754369"></p><p>4、BIT类型中存储的是二进制值，类似010110。</p><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271428302.png" alt="image-20220427142855647"></p><h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271430302.png" alt="image-20220427143018410"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 日期数据类型</span><br><span class="line">+ year类型</span><br><span class="line">    + 1901——2155</span><br><span class="line">+ date类型</span><br><span class="line">    + YYYY-MM-DD</span><br><span class="line">+ time类型</span><br><span class="line">    + 时分秒</span><br><span class="line">+ datetime类型</span><br><span class="line">    + YYYY-MM-DD HH:MM:SS</span><br><span class="line">    + 函数</span><br><span class="line">+ timestamp类型</span><br><span class="line">    + YYYY-MM-DD HH:MM:SS</span><br><span class="line">+ 区别</span><br><span class="line">    + 时区问题</span><br><span class="line">    + timestamp考虑时区</span><br><span class="line">        + 底层：毫秒数</span><br><span class="line">+ 尽量用datatime</span><br><span class="line">+ 计算相关用尽量时间戳存储</span><br></pre></td></tr></table></figure><h2 id="文本字符串类型"><a href="#文本字符串类型" class="headerlink" title="文本字符串类型"></a>文本字符串类型</h2><p>MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、 LONGTEXT 、 ENUM 、 SET 等类型。</p><p>1、CHAR和VARCHAR类型都可以存储比较短的字符串。</p><p><strong>CHAR(M) 类型</strong>一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充 空格以达到指定的长 度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。 </p><p>检索<strong>VARCHAR类型</strong>的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</p><p><strong>InnoDB 存储引擎，建议使用VARCHAR类型。</strong>因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的， 其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。 </p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271430045.png" alt="image-20220427143048288"></p><p>2、在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272157468.png" alt="image-20220427215740347"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 文本字符串类型</span><br><span class="line">    + char和varchar</span><br><span class="line">        + char固定长度</span><br><span class="line">            + 自动填充空格</span><br><span class="line">            + 检索时自动去除空格</span><br><span class="line">                + 若数据本身末尾带空格，则长度变短</span><br><span class="line">    + varchar可变长度</span><br><span class="line">        + 必须指明长度（字节）</span><br><span class="line">    + char效率高、固定字长</span><br><span class="line">    + innodb推荐varchar</span><br><span class="line">        + 内部主要影响性能因素是存储总量</span><br><span class="line">    + text类型</span><br><span class="line">    + 频繁操作text的字段，最好单独一个表</span><br></pre></td></tr></table></figure><h2 id="ENUM类型、SET类型"><a href="#ENUM类型、SET类型" class="headerlink" title="ENUM类型、SET类型"></a>ENUM类型、SET类型</h2><p>1、ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。<br><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272159958.png" alt="image-20220427215926966"></p><p>2、当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272159604.png" alt="image-20220427215952742"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ ENUM类型</span><br><span class="line">    + 只能选择一个</span><br><span class="line">    + 可以用索引选择元素</span><br><span class="line">    + 可以NULL</span><br><span class="line">+ SET类型</span><br><span class="line">    + 相比枚举：可以选择多个</span><br><span class="line">    + 自动去重</span><br></pre></td></tr></table></figure><h2 id="二进制字符串类型、JSON类型、空间类型"><a href="#二进制字符串类型、JSON类型、空间类型" class="headerlink" title="二进制字符串类型、JSON类型、空间类型"></a>二进制字符串类型、JSON类型、空间类型</h2><p>1、MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272200901.png" alt="image-20220427220022101"></p><p>2、BLOB是一个<code>二进制大对象</code> ，可以容纳可变数量的数据。</p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><ul><li>BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值 会在数据表中留下很大的” 空洞 “，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期 使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 。 </li><li>如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检 索大型的BLOB或TEXT值。例如SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的 WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li><li>把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272200030.png" alt="image-20220427220036986"></p><p>3、JSON（JavaScript Object Notation）是一种轻量级的数据交换格式 。简洁和清晰的层次结构使得 JSON 成 为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效 率。</p><p>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻 松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。 </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO test_json (js) VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>4、空间类型</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272203872.png" alt="image-20220427220320056"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ BINARY</span><br><span class="line">    + 固定长度</span><br><span class="line">+ VARBINARY</span><br><span class="line">    + 可变长度</span><br><span class="line">+ 类似char和varchar</span><br><span class="line">+ 存储二进制字符串</span><br><span class="line">+ BLOB</span><br><span class="line">    + 存储大的二进制数据</span><br><span class="line">    + 通常不用，只存储访问路径</span><br><span class="line">+ text和blob</span><br><span class="line">    + 尽量少检索大字段</span><br><span class="line">    + 分离到单独表中</span><br><span class="line">    + 多次操作产生空洞</span><br><span class="line">+ JSON类型</span><br><span class="line">    + 提取字段的值</span><br><span class="line">+ 空间类型</span><br></pre></td></tr></table></figure><h2 id="小结及选择建议"><a href="#小结及选择建议" class="headerlink" title="小结及选择建议"></a>小结及选择建议</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272203101.png" alt="image-20220427220337246"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 整数，INT</span><br><span class="line">+ 小数，DECIAML，指定精度</span><br><span class="line">+ 日期，DATATIME</span><br><span class="line">+ 阿里</span><br><span class="line">    + 非负：unsigned</span><br><span class="line">    + 小数：decimal，进制float和double</span><br><span class="line">        + 超出范围，分开存储整数和小数部分</span><br></pre></td></tr></table></figure><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="数据完整性与约束的分类"><a href="#数据完整性与约束的分类" class="headerlink" title="数据完整性与约束的分类"></a>数据完整性与约束的分类</h2><p>1、数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p><p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p><ul><li>实体完整性（Entity Integrity） ：例如，同一个表中，不能存在两条完全相同无法区分的记录 。</li><li>域完整性（Domain Integrity） ：例如：年龄范围0-120，性别范围“男/女” 。</li><li>引用完整性（Referential Integrity） ：例如：员工所在部门，在部门表中要能找到这个部门。</li><li>用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li></ul><p>2、约束是表级的强制规定。 </p><p>可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定约束。 </p><p>3、约束的分类</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272209438.png" alt="image-20220427220918358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 为什么要约束</span><br><span class="line">    + 保证数据完整性</span><br><span class="line">        + 实体完整性</span><br><span class="line">        + 域完整性</span><br><span class="line">        + 引用完整性</span><br><span class="line">        + 用户自定义完整性 </span><br><span class="line">+ 约束</span><br><span class="line">+ 约束的分类</span><br><span class="line">    + 约束的字段的个数</span><br><span class="line">        + 单列约束、多列约束</span><br><span class="line">    + 约束的作用范围</span><br><span class="line">        + 列级约束、表级约束</span><br><span class="line">    + 约束的作用</span><br><span class="line">        + not null（非空约束）</span><br><span class="line">        + unique（唯一性约束）</span><br><span class="line">        + primary key（主键约束）</span><br><span class="line">        + foreign key（外键）</span><br><span class="line">        + check（检查约束）</span><br><span class="line">        + default（默认值约束）</span><br><span class="line">+ 添加约束</span><br><span class="line">    + create table</span><br><span class="line">    + alter table</span><br></pre></td></tr></table></figure><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>关键字： NOT NULL </p><p>1、特点</p><ul><li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</li><li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li><li>一个表可以有很多列都分别限定了非空</li><li>空字符串’’不等于NULL，0也不等于NULL </li></ul><p>2、添加、删除等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名称(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型 NOT NULL,</span><br><span class="line">    字段名 数据类型 NOT NULL </span><br><span class="line">);</span><br><span class="line">alter table 表名称 modify 字段名 数据类型 not null;</span><br><span class="line">ALTER TABLE emp MODIFY sex VARCHAR(30) NULL;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 查看约束</span><br><span class="line">    + 存在information_schma中</span><br><span class="line">+ 非空约束</span><br><span class="line">    + 必须有值</span><br><span class="line">+ 创建表</span><br><span class="line">+ 修改表</span><br><span class="line">    + 数据不能有NULL，否则无法修改</span><br></pre></td></tr></table></figure><h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><p>用来限制某个字段/某列的值不能重复：UNIQUE </p><p>1、特点</p><ul><li>同一个表可以有多个唯一约束。 </li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 </li><li>唯一性约束允许列值为空。 </li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 </li><li>MySQL会给唯一约束的列上默认创建一个唯一索引。 \</li></ul><p>2、添加约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 添加</span><br><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型 unique,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 </span><br><span class="line">);</span><br><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    [constraint 约束名] unique key(字段名) </span><br><span class="line">)</span><br><span class="line"># 修改</span><br><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯 一的</span><br><span class="line">alter table 表名称 add unique key(字段列表);</span><br><span class="line">alter table 表名称 modify 字段名 字段类型 unique;</span><br></pre></td></tr></table></figure><p>3、关于复合唯一约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    unique key(字段列表)</span><br><span class="line">    #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多 个字段的组合是唯一的 </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4、删除唯一约束</p><ul><li>添加唯一性约束的列上也会自动创建唯一索引。</li><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()</li><li>中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; </span><br><span class="line">#查看都有哪 些约束 </span><br><span class="line">ALTER TABLE USER DROP INDEX uk_name_pwd;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ 查看约束</span><br><span class="line">    + 存在information_schma中</span><br><span class="line">+ 非空约束</span><br><span class="line">    + 必须有值</span><br><span class="line">+ 修改表</span><br><span class="line">    + 数据不能有NULL，否则无法修改</span><br><span class="line">唯一性约束的使用</span><br><span class="line">+ 某个字段不能重复 UNIQUE</span><br><span class="line">    + id等</span><br><span class="line">    + 可以是某个列的值唯一</span><br><span class="line">    + 也可以是多个列组合的值唯一</span><br><span class="line">    + mysql默认给唯一约束的列上创建一个唯一索引</span><br><span class="line">+ 列级约束</span><br><span class="line">+ 表级约束</span><br><span class="line">    + 可以不起名</span><br><span class="line">+ 修改表形式添加unique</span><br><span class="line">    + 表中数据不能重复，才能添加</span><br><span class="line">    + add（表约束形式）、modify（列约束形式）</span><br><span class="line">+ 复合的唯一性约束（表级约束）</span><br><span class="line">+ 删除唯一约束</span><br><span class="line">    + 添加唯一约束自动创建唯一索引</span><br><span class="line">    + 删除唯一约束只能通过删除唯一索引</span><br><span class="line">    + 唯一索引名和唯一约束名相同</span><br><span class="line">    + DROP INDEX</span><br></pre></td></tr></table></figure><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>用来唯一标识表中的一行记录：primary key</p><p>1、特点</p><ul><li>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。 </li><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。 </li><li>主键约束对应着表中的一列或者多列（复合主键） </li><li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 </li><li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。 </li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。 </li><li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。 </li></ul><p>2、添加、删除</p><p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#列级约束</span><br><span class="line">CREATE TABLE emp4( </span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">    NAME VARCHAR(20) </span><br><span class="line">);</span><br><span class="line">#表级约束</span><br><span class="line">CREATE TABLE emp5( </span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(20),</span><br><span class="line">    pwd VARCHAR(15),</span><br><span class="line">    CONSTRAINT emp5_id_pk PRIMARY KEY(id) </span><br><span class="line">);</span><br><span class="line">alter table 表名称 drop primary key;</span><br></pre></td></tr></table></figure><p>3、关于复合主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">    primary key(字段名1,字段名2) </span><br><span class="line">    #表示字段1和字段2的组合是唯一的，也可以有更多个字段 </span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 主键约束</span><br><span class="line">    + 相当于unique + not null</span><br><span class="line">+ 一个表只能有一个主键</span><br><span class="line">    + 主键索引</span><br><span class="line">+ 对应表中一列或者多列（复合主键）</span><br><span class="line">+ 不要修改主键字段的值</span><br><span class="line">+ 主键名固定</span><br><span class="line">+ 复合主键</span><br><span class="line">    + 与复合unique和全部not null相同</span><br><span class="line">+ 删除主键</span><br><span class="line">    + 在实际开发根本不会</span><br></pre></td></tr></table></figure><h2 id="自增列"><a href="#自增列" class="headerlink" title="自增列"></a>自增列</h2><p>某个字段的值自增：AUTO_INCREMENT </p><p> 1、特点</p><ul><li>一个表最多只能有一个自增长列 </li><li>当需要产生唯一标识符或顺序值时，可设置自增长 </li><li>自增长列约束的列必须是键列（主键列，唯一键列） </li><li>自增约束的列的数据类型必须是整数类型 </li><li>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li></ul><p>2、创建、删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型 primary key auto_increment, </span><br><span class="line">    字段名 数据类型 unique key not null,</span><br><span class="line">    字段名 数据类型 unique key,</span><br><span class="line">    字段名 数据类型 not null default 默认值 </span><br><span class="line">);</span><br><span class="line">create table 表名称( </span><br><span class="line">    字段名 数据类型 default 默认值 ,</span><br><span class="line">    字段名 数据类型 unique key auto_increment,</span><br><span class="line">    字段名 数据类型 not null default 默认值,</span><br><span class="line">    primary key(字段名) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">alter table 表名称 modify 字段名 数据类型 auto_increment;</span><br><span class="line"></span><br><span class="line">#alter table 表名称 modify 字段名 数据类型 auto_increment;</span><br><span class="line">#给这个字段增加自增约束 </span><br><span class="line">alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 </span><br><span class="line">alter table employee modify eid int;</span><br></pre></td></tr></table></figure><p>3、MySQL 8.0新特性—自增变量的持久化 </p><p> 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 </p><ul><li><p>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p></li><li><p>MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 一个表最多一个自增列</span><br><span class="line">+ 必须是unique、主键的列</span><br><span class="line">+ 必须是整数类型</span><br><span class="line">+ 无需手动添加列值</span><br><span class="line">    + 自动增长（最大的开始）</span><br><span class="line">+ 可以指定数值</span><br><span class="line">+ 修改、删除</span><br><span class="line">+ 8.0新特性</span><br><span class="line">    + 在磁盘日志中维护了增长值，删除不改变</span><br><span class="line">+ 5.7</span><br><span class="line">    + 在内存中维护了增长值，删除不改变</span><br><span class="line">    + 重启后，会找最大值</span><br></pre></td></tr></table></figure><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>限定某个表的某个字段的引用完整性：FOREIGN KEY </p><p>1、特点</p><ul><li>从表的外键列，必须引用/参考主表的主键或唯一约束的列。为什么？因为被依赖/被参考的值必须是唯一的 </li><li>在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如student_ibfk_1;），也可以指定外键约束名。 </li><li>创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表 </li><li>删表时，先删从表（或先删除外键约束），再删除主表 </li><li>当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据 </li><li>在“从表”中指定外键约束，并且一个表可以建立多个外键约束 </li><li>从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”</li><li>删除外键约束后，必须手动 删除对应的索引</li></ul><p>2、添加、删除</p><p>一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。</p><p>总结：约束关系是针对双方的</p><ul><li>添加了外键约束后，主表的修改和删除数据受约束</li><li>添加了外键约束后，从表的添加和修改数据受约束</li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">create table 主表名称( </span><br><span class="line">    字段1 数据类型 primary key,</span><br><span class="line">    字段2 数据类型 </span><br><span class="line">);</span><br><span class="line">create table 从表名称( </span><br><span class="line">    字段1 数据类型 primary key,</span><br><span class="line">    字段2 数据类型,</span><br><span class="line">    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) </span><br><span class="line">);</span><br><span class="line">#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样 </span><br><span class="line">#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span><br><span class="line">-- FOREIGN KEY: 在表级指定子表中的列</span><br><span class="line">-- REFERENCES: 标示在父表中的列</span><br><span class="line"></span><br><span class="line">#删除外键约束、</span><br><span class="line">#(1)第一步先查看约束名和删除外键约束 </span><br><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;</span><br><span class="line">#查看某个 表的约束名 </span><br><span class="line">ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; </span><br><span class="line">#（2）第二步查看索引名和删除索引。（注意，只能手动删除） </span><br><span class="line">SHOW INDEX FROM 表名称; </span><br><span class="line">#查看某个表的索引名 </span><br><span class="line">ALTER TABLE 从表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure><p>3、约束等级</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272228466.png" alt="image-20220427222822789"></p><p>4、规范：不得使用外键。</p><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会 <code>因为外键约束的系统开销而变得非常慢</code>。所以， MySQL 允许你不使用系统自带的外键约束，在 <code>应用层面</code> 完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204272230703.png" alt="image-20220427223036010"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 外键</span><br><span class="line">    + 关联必须引用主键、unique的列</span><br><span class="line">    + 先创建主表</span><br><span class="line">    + 先添加主表，先删除从表</span><br><span class="line">    + 自动创建普通索引</span><br><span class="line">+ 约束等级</span><br><span class="line">    + cascade</span><br><span class="line">        + 主表更新、删除，自动操作子表数据</span><br><span class="line">    + set null</span><br><span class="line">        + 主表更新、删除，子表为null</span><br><span class="line">    + no action</span><br><span class="line">    + restrict</span><br><span class="line">    + set default</span><br><span class="line">+ 约束等级测试</span><br><span class="line">    + 修改——cascade</span><br><span class="line">    + 删除——set null</span><br><span class="line">+ 最好</span><br><span class="line">    + 自动修改</span><br><span class="line">    + 严格删除</span><br><span class="line">+ 删除外键、索引</span><br><span class="line">+ 从来不用外键</span><br></pre></td></tr></table></figure><h2 id="检查约束与默认值约束"><a href="#检查约束与默认值约束" class="headerlink" title="检查约束与默认值约束"></a>检查约束与默认值约束</h2><p>1、检查某个字段的值是否符号xx要求，一般指的是值的范围：CHECK </p><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告。但是MySQL 8.0中可以使用check约束了。 </p><p> 2、给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值：DEFAULT </p><p>说明：默认值约束一般不在唯一键和主键列上加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ check：检查值</span><br><span class="line">    + 8.0可用</span><br><span class="line">+ default约束</span><br><span class="line">+ 通常设置非空且默认值</span><br><span class="line">    + 清除NULL</span><br></pre></td></tr></table></figure><h2 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h2><p><strong>为什么建表时，加 not null default ‘’ 或 default 0</strong> </p><ul><li>不想让表中出现null值。 </li></ul><p><strong>为什么不想要 null 的值</strong> </p><ul><li>不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。 </li><li>效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0 </li></ul><p><strong>带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong> </p><ul><li>在MySQL中，默认AUTO_INCREMENT的初始 值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第 一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一 条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要 设置字段自动增加属性。 </li></ul><p><strong>并不是每个表都可以任意选择存储引擎？</strong></p><ul><li>外键约束（FOREIGN KEY）不能跨引擎使用。 </li><li>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——多表查询&amp;聚合函数&amp;子查询</title>
      <link href="/2022/04/20/MySQL-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2&amp;%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0&amp;%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/04/20/MySQL-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2&amp;%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0&amp;%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面-MySQL学习"><a href="#写在前面-MySQL学习" class="headerlink" title="写在前面 - MySQL学习"></a>写在前面 - MySQL学习</h1><p>1、针对开发工程师、DBA、运维</p><ul><li>mysql服务器的安装配置</li><li>SQL编程(自定义函数、存储过程、触发器、定时任务)</li><li>数据库索引建立</li><li>SQL语句优化</li><li>数据库内部结构和原理</li><li>数据库的性能监控分析与系统优化</li><li>各种参数常量设定</li><li>数据库建模优化</li><li>主从复制</li><li>分布式架构搭建、垂直切割和水平切割</li><li>MyCat</li><li>数据迁移</li><li>容灾备份和恢复</li><li>对开源数据库进行二次开发</li></ul><p>2、<strong>技术骨干、架构师</strong>则往往需要对底层原理吃透，数据库事务 ACID 是如何实现的？何时命中索引、何时不能，为什么？分布式场景下数据库怎么优化才能保持高性能</p><p>3、<strong>精通数据库。精通意味着：</strong></p><p>第一形成知识网，更灵活地应对突发问题；</p><p>第二底层原理要懂，懂了才能更自由地应对复杂多变的业务场景。</p><p>4、对于知识，是需要 <code>认真</code> 和 <code>讲究逻辑</code> 的。希望这份认真、严谨在每个细节都能体会到。希望能感受到这种思维方式的美。具备优秀的思维能力 才是在未来可以迁移的能力，如果只是学习一些命令，则很快会过时， 思维能力 和 学习能力 的提升才是不会变的东西。</p><h1 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h1><h2 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a>为什么要使用数据库</h2><p>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多 通过各种关系数据库来完成。 </p><ul><li>持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220419121935522.png" alt="image-20220419121935522"></p><h2 id="DB-amp-DBMS-amp-SQL"><a href="#DB-amp-DBMS-amp-SQL" class="headerlink" title="DB &amp; DBMS &amp; SQL"></a>DB &amp; DBMS &amp; SQL</h2><p>DB：数据库（Database）即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。 </p><p>DBMS：数据库管理系统（Database Management System）是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。 </p><p>SQL：结构化查询语言（Structured Query Language）专门用来与数据库通信的语言。</p><p>数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p><h2 id="DBMS-rank"><a href="#DBMS-rank" class="headerlink" title="DBMS - rank"></a>DBMS - rank</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220419122104302.png" alt="image-20220419122104302"></p><h2 id="RDBMS-amp-非RDBMS"><a href="#RDBMS-amp-非RDBMS" class="headerlink" title="RDBMS &amp; 非RDBMS"></a>RDBMS &amp; 非RDBMS</h2><p>NOSQL：</p><p>键值型数据库</p><p>文档型数据库</p><p>搜索引擎数据库</p><p>列式数据库</p><p>图形数据库</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ RDBMS</span><br><span class="line">+ 关系模型上建立的数据库</span><br><span class="line">        + 关系型数据库</span><br><span class="line">    + 优势</span><br><span class="line">        + 复杂查询</span><br><span class="line">        + 事务支持</span><br><span class="line">+ NOSQL</span><br><span class="line">    + 更高的性能</span><br><span class="line">    + 分类</span><br><span class="line">        + kv</span><br><span class="line">        + 文档型</span><br><span class="line">        + 搜索引擎型</span><br><span class="line">            + 倒排索引</span><br><span class="line">        + 列式</span><br><span class="line">            + 降低io次数</span><br><span class="line">        + 图形</span><br><span class="line">    + nosql</span><br></pre></td></tr></table></figure><h2 id="关系型数据库设计规则"><a href="#关系型数据库设计规则" class="headerlink" title="关系型数据库设计规则"></a>关系型数据库设计规则</h2><p>1、表、记录、字段</p><p>E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表 中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列 （column），也称为一个字段（field）。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ ORM（对象关系映射）思想</span><br><span class="line">    + 数据库中的一个表 —— java一个类</span><br><span class="line">    + 数据 —— 对象</span><br><span class="line">    + 列 —— 字段、属性</span><br><span class="line">+ E-R模型</span><br><span class="line">    + 实体-联系</span><br></pre></td></tr></table></figure><p>2、表的关联关系</p><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</p><p>四种：一对一关联、一对多关联、多对多关联、自我引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 表的关联关系</span><br><span class="line">    + 一对一关联</span><br><span class="line">        + 可合为一张表</span><br><span class="line">    + 一对多关联</span><br><span class="line">        + 主表的主键作为从表的字段</span><br><span class="line">        + 属性可重复</span><br><span class="line">    + 多对多关联</span><br><span class="line">        + 必须创建第三个表</span><br><span class="line">            + 字段：包含两个表的主键</span><br><span class="line">    + 自我引用</span><br><span class="line">        + 字段引用其他字段</span><br><span class="line">            + 体现层级关系</span><br></pre></td></tr></table></figure><h1 id="基本的SELECT语句"><a href="#基本的SELECT语句" class="headerlink" title="基本的SELECT语句"></a>基本的SELECT语句</h1><h2 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h2><p>SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。</p><p>SQL语言在功能上主要分为如下3大类： </p><ul><li><p>DDL（Data Definition Languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等。 </p></li><li><p>DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。 SELECT是SQL语言的基础，最为重要。 </p></li><li><p>DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。</p></li></ul><p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。 </p><p>还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语言）。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ sql分类</span><br><span class="line">    + DDL数据定义语言</span><br><span class="line">        + 创建、删除、修改等</span><br><span class="line">    + DML数据操作语言</span><br><span class="line">        + 增、删、改、查</span><br><span class="line">    + DCL数据控制语言</span><br><span class="line">        + 访问、安全</span><br><span class="line">+ SELECT重中之重</span><br><span class="line">+ 大处着眼，小处着手</span><br><span class="line">+ 眼界很重要，也不能眼高手低</span><br></pre></td></tr></table></figure><h2 id="SQL语言的规则与规范"><a href="#SQL语言的规则与规范" class="headerlink" title="SQL语言的规则与规范"></a>SQL语言的规则与规范</h2><p>MySQL 在 Windows 环境下是大小写不敏感的</p><p>MySQL 在 Linux 环境下是大小写敏感的</p><ul><li><p>数据库名、表名、表的别名、变量名是严格区分大小写的</p></li><li><p>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</p></li></ul><p>推荐采用统一的书写规范：</p><ul><li><p>数据库名、表名、表别名、字段名、字段别名等都小写</p></li><li><p>SQL 关键字、函数名、绑定变量等都大写</p></li></ul><h2 id="基本的SELECT语句-1"><a href="#基本的SELECT语句-1" class="headerlink" title="基本的SELECT语句"></a>基本的SELECT语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ 列的别名</span><br><span class="line">+ 去除重复行</span><br><span class="line">    + distinct</span><br><span class="line">+ 空值</span><br><span class="line">    + NULL</span><br><span class="line">    + 不参与运算</span><br><span class="line">        + IFNULL解决</span><br><span class="line">+ 着重号</span><br><span class="line">    + ``飘</span><br><span class="line">    + 解决name（字段、表名）和函数冲突问题</span><br><span class="line">+ 查询常数</span><br><span class="line">    + 加入常数列</span><br><span class="line">+ 显示表结构</span><br><span class="line">    + describe、desc</span><br><span class="line">    + 表字段信息</span><br><span class="line">+ WHERE</span><br></pre></td></tr></table></figure><h2 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h2><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> employees; </span><br><span class="line">#或</span><br><span class="line"><span class="keyword">DESC</span> employees;</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。</p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。</p><p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ 符号类型运算符</span><br><span class="line">    + 安全等于</span><br><span class="line">        + 解决跟null比较的问题</span><br><span class="line">        + 两个null为1</span><br><span class="line">    + 不等于：&lt;&gt;、!=</span><br><span class="line">    + 是否为NULL</span><br><span class="line">        + IS NULL、ISNULL</span><br><span class="line">    + 最小的、最大的</span><br><span class="line">        + LEAST()、GREATEST</span><br><span class="line">    + 区间</span><br><span class="line">        + BETWEEN...AND...</span><br><span class="line">    + 在离散集合中</span><br><span class="line">        + IN</span><br><span class="line">    + 模糊查询</span><br><span class="line">        + LIKE</span><br><span class="line">            + % 不确定个数字符</span><br><span class="line">            + _代表一个不确定的字符</span><br><span class="line">                + 有几个下划线代表几个字符</span><br><span class="line">                + 查询带_的字符：加上\转义字符</span><br><span class="line">                    + 自定义转移字符：ESCAPE</span><br><span class="line">    + 正则表达式</span><br><span class="line">        + REGEXP</span><br><span class="line">        + RLIKE</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。 </p><p>逻辑非、逻辑与、逻辑或、逻辑异或。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ NOT</span><br><span class="line">+ AND</span><br><span class="line">+ OR</span><br><span class="line">+ XOR</span><br><span class="line">    + 异或：两边不一样为真</span><br><span class="line">+ and优先级比or高</span><br><span class="line">    + 先算and</span><br><span class="line">+ 运算符的优先级</span><br><span class="line">    + 遇事不决，小括号</span><br><span class="line">+ 位运算符</span><br></pre></td></tr></table></figure><h1 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>1、使用 ORDER BY 子句排序 </p><p>ASC（ascend）: 升序 </p><p>DESC（descend）:降序</p><p>2、可以使用不在SELECT列表中的列排序。</p><p>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 排序</span><br><span class="line">    + 默认为数据库先后添加顺序</span><br><span class="line">+ ORDER BY</span><br><span class="line">    + 可以使用别名</span><br><span class="line">+ 二级排序</span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>1、LIMIT [位置偏移量,] 行数</p><p>第一个<code>位置偏移量</code>参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定<code>位置偏移量</code>，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；</p><p>第二个参数“行数”指示返回的记录条数。</p><p>2、约束返回结果的数量可以<code>减少数据表的网络传输量</code>，也可以<code>提升查询效率</code>。</p><p>如果我们知道返回结果只有1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 偏移量，分页数</span><br><span class="line">+ 声明顺序</span><br><span class="line">    + WHERE</span><br><span class="line">    + ORDER BY</span><br><span class="line">    + LIMIT</span><br><span class="line">+ 8.0新特性</span><br><span class="line">    + LIMIT ... OFFSET ...</span><br><span class="line">    + LIMIT 条目 OFFSET 偏移量</span><br><span class="line">+ LIMIT 1</span><br><span class="line">    + 取第一条数据</span><br><span class="line">+ 其他数据库异同</span><br></pre></td></tr></table></figure><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 为什么需要多表查询？</span><br><span class="line">    + 分开查询太麻烦</span><br><span class="line">    + 合成一张表</span><br><span class="line">    + 数据冗余</span><br><span class="line">    + IO次数变多</span><br><span class="line">    + 事务问题</span><br><span class="line">+ 笛卡尔积的的错误</span><br><span class="line">    + 没有进行连接</span><br><span class="line">+ 多表查询</span><br><span class="line">    + 加入连接条件</span><br><span class="line">    + 指明表的字段</span><br><span class="line">+ 设置表的别名</span><br><span class="line">+ n个表至少n-1个连接条件</span><br></pre></td></tr></table></figure><h2 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h2><p>等值连接 vs 非等值连接、自连接 vs 非自连接 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 多表查询的分类</span><br><span class="line">    + 等值连接</span><br><span class="line">    + 自连接</span><br><span class="line">    + 内连接</span><br><span class="line">+ 等值连接和非等值连接</span><br><span class="line">    + 判断工资等级</span><br><span class="line">+ 判断字段处于另一个表的区间</span><br><span class="line">    + 自连接和非自连接</span><br><span class="line">    + 树形结构查询</span><br></pre></td></tr></table></figure><p>内连接 vs 外连接</p><ul><li><p>内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 </p></li><li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。 </p></li></ul><p>如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。 </p><p>如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 外连接</span><br><span class="line">    + 左外连接</span><br><span class="line">    + 右外连接</span><br><span class="line">    + 全外连接</span><br><span class="line">+ 常用sql标准</span><br><span class="line">+ SQL92外连接</span><br><span class="line">    + Mysql不支持</span><br><span class="line">+ SQL99语法：JOIN ... ON</span><br><span class="line">    + 内连接 INNER</span><br><span class="line">    + 外连接 LEFT、RIGHT OUTER</span><br><span class="line">        + 满外连接</span><br><span class="line">            + FULL OUTER Mysql不支持</span><br></pre></td></tr></table></figure><h2 id="7种SQL-JOINS的实现"><a href="#7种SQL-JOINS的实现" class="headerlink" title="7种SQL JOINS的实现"></a>7种SQL JOINS的实现</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271342403.png" alt="image-20220425143537469"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#中图：内连接 </span><br><span class="line">A∩B <span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`; </span><br><span class="line">#左上图：左外连接 </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`; </span><br><span class="line">#右上图：右外连接 </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`; </span><br><span class="line">#左中图：A <span class="operator">-</span> A∩B </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span> </span><br><span class="line">#右中图：B <span class="operator">-</span> A∩B </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">#左下图：满外连接 </span><br><span class="line">#左中图 <span class="operator">+</span> 右上图 A∪B </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> #没有去重操作，效率高 </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`; </span><br><span class="line">#右下图 </span><br><span class="line">#左中图 <span class="operator">+</span> 右中图 A∪B<span class="operator">-</span> A∩B 或者 (A <span class="operator">-</span> A∩B) ∪ （B <span class="operator">-</span> A∩B） </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ UNION的使用</span><br><span class="line">    + 能用UNION ALL就不用UNION</span><br><span class="line">+ 7种JOIN的实现</span><br><span class="line">    + 中图：内连接</span><br><span class="line">    + 左上：左外连接</span><br><span class="line">    + 右上：右外连接</span><br><span class="line">    + 左中：左外连接 + 右为NULL</span><br><span class="line">    + 右中：右外连接 + 左为NULL</span><br><span class="line">    + 左下（全外）</span><br><span class="line">    + 左上 UNION ALL 右中</span><br><span class="line">    + 右上 UNION ALL 左中</span><br><span class="line">    + 右下：左中 UNION ALL 右中</span><br></pre></td></tr></table></figure><h2 id="NATURAL-JOIN-与-USING-的使用"><a href="#NATURAL-JOIN-与-USING-的使用" class="headerlink" title="NATURAL JOIN 与 USING 的使用"></a>NATURAL JOIN 与 USING 的使用</h2><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <code>NATURAL JOIN</code> 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中所有相同的字段 ，然后进行 等值 连接 。 </p><p>当我们进行连接的时候，SQL99还支持使用 <code>USING</code> 指定数据表里的 同名字段进行等值连接。但是只能配合JOIN一起使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 自然连接</span><br><span class="line">    + 自动查找相同字段进行等值连接</span><br><span class="line">+ USING连接</span><br><span class="line">    + 字段名称一样时简写</span><br><span class="line">+ 小结</span><br><span class="line">    + WHERE</span><br><span class="line">    + ON 推荐</span><br><span class="line">    + USING</span><br></pre></td></tr></table></figure><h1 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>MySQL提供的内置函数从 实现的功能角度 可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，内置函数再分为两类： 单行函数 、 聚合函数。 </p><ul><li>单行函数：操作数据对象、接受参数返回一个结果、<strong>只对一行进行变换</strong>、<strong>每行返回一个结果</strong>、可以嵌套参数、可以是一列或一个值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 什么是函数</span><br><span class="line">    + 提高效率和维护性</span><br><span class="line">    + 内置函数和自定义函数</span><br><span class="line">+ 不同DBMS有差异</span><br><span class="line">+ MYSQL内置函数</span><br><span class="line">    + 单行函数、聚合函数</span><br></pre></td></tr></table></figure><h2 id="数值-amp-字符串函数"><a href="#数值-amp-字符串函数" class="headerlink" title="数值&amp;字符串函数"></a>数值&amp;字符串函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ 数值函数</span><br><span class="line">    + 基本函数</span><br><span class="line">    + 角度与弧度换算</span><br><span class="line">    + 三角函数</span><br><span class="line">    + 指数和对数</span><br><span class="line">    + 进制间的转换</span><br><span class="line">+ 字符串函数</span><br><span class="line">    + askii码</span><br><span class="line">    + 字符数CHAR_LENGTH、字节数</span><br><span class="line">    + 连接 CONCAT，连接 + 分隔</span><br><span class="line">    + 插入替换 INSERT，全部替换 REPLACE</span><br><span class="line">    + 索引从1开始</span><br><span class="line">    + 大写、小写 UPPER、LOWER</span><br><span class="line">    + 取左边、右边 LEFT RIGHT</span><br><span class="line">    + 左对齐，右对齐 LPAD、RPAD，以xx补齐特定长度</span><br><span class="line">    + 去除首、尾的空格、字符 TRIM</span><br><span class="line">    + 重复 REPEAT</span><br><span class="line">    + 比较 STRCMP</span><br><span class="line">    + 截取 SUBSTR</span><br><span class="line">    + 位置 LOCATE</span><br><span class="line">    + 取后面数组的字符 ELT、FIELD，首次位置 FIND_IN_SET</span><br><span class="line">    + 翻转 REVERSE</span><br><span class="line">    + 判断相等 NULLIF</span><br></pre></td></tr></table></figure><h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 日期时间函数</span><br><span class="line">    + 获取当前时间</span><br><span class="line">    + 年份、季度、月份、星期、天</span><br><span class="line">    + 时、分、秒</span><br><span class="line">    + 日期与时间戳转换</span><br><span class="line">    + 获取时间戳</span><br><span class="line">    + 时间戳转换、还原</span><br><span class="line">    + 日期与秒数转换</span><br><span class="line">    + 计算日期和时间</span><br><span class="line">    + 时间加减</span><br><span class="line">    + 时间间隔</span><br><span class="line">    + 日期格式化与解析</span><br><span class="line">    + 格式化：日期——&gt;字符串</span><br><span class="line">    + 解析：字符串——&gt;日期</span><br></pre></td></tr></table></figure><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 流程控制函数</span><br><span class="line">    + IF(case,value,value)</span><br><span class="line">    + IFNULL</span><br><span class="line">    + CASE WHEN</span><br><span class="line">    + if else</span><br><span class="line">    + CASE xx WHEN</span><br><span class="line">    + switch</span><br><span class="line">    + 自带循环</span><br></pre></td></tr></table></figure><h2 id="加密解密-amp-信息-amp-其他函数"><a href="#加密解密-amp-信息-amp-其他函数" class="headerlink" title="加密解密&amp;信息&amp;其他函数"></a>加密解密&amp;信息&amp;其他函数</h2><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p><p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ 加密函数</span><br><span class="line">    + MD5</span><br><span class="line">    + SHA</span><br><span class="line">    + ENCODE</span><br><span class="line">    + DECODE</span><br><span class="line">+ mysql信息函数</span><br><span class="line">    + 版本号</span><br><span class="line">    + 连接数</span><br><span class="line">    + 用户</span><br><span class="line">    + 字符集</span><br><span class="line">+ 其他函数</span><br><span class="line">    + 四舍五入</span><br><span class="line">    + 进制转换</span><br><span class="line">    + IP转换</span><br><span class="line">    + 测试时间</span><br><span class="line">    + 修改字符编码</span><br></pre></td></tr></table></figure><h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><h2 id="写在前面-1"><a href="#写在前面-1" class="headerlink" title="写在前面"></a>写在前面</h2><p>聚合函数作用于一组数据，并对一组数据返回一个值。</p><p>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 聚合函数</span><br><span class="line">    + 输入一堆值，返回一个值</span><br><span class="line">+ 常用聚合函数</span><br><span class="line">    + AVG、SUM</span><br><span class="line">        + 平均数、和</span><br><span class="line">    + MAX、MIN</span><br><span class="line">        + 最大、最小值</span><br><span class="line">        + 字符串也可以比较</span><br><span class="line">    + COUNT</span><br><span class="line">        + 作用：计算指定字段在查询结构中出现的个数，不计算NULL</span><br><span class="line">        + 统计记录个数，建议使用COUNT(*)和COUNT(1)</span><br><span class="line">        + 注意NULL情况</span><br><span class="line">    + 其他</span><br><span class="line">        + 方差、标准差、中位数</span><br><span class="line">+ 认知能力</span><br><span class="line">    + 对下层降维打击</span><br><span class="line">    + 提升层次</span><br><span class="line">    + 看到更广阔的领域</span><br><span class="line">+ 人与人的差别太大：各个方面</span><br></pre></td></tr></table></figure><h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271343631.png" alt="image-20220427134341809"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 分组操作</span><br><span class="line">    + 根据某一字段分组</span><br><span class="line">+ 使用多个列分组</span><br><span class="line">    + 前后顺序不同，效果一样</span><br><span class="line">    + SELECT中非组函数的字段必须出现在GROUP中</span><br><span class="line">        + 有组函数必须有GROUP BY</span><br><span class="line">    + GROUP BY声明在FROM和WHERE后面、ORDER BY和LIMIT前面</span><br><span class="line">    + 新特性：WITH ROLLUP</span><br><span class="line">        + 又计算了整体的平均值</span><br><span class="line">        + 不能和ORDER BY同时使用</span><br></pre></td></tr></table></figure><h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>1、过滤分组：HAVING子句 </p><p>1、行已经被分组。 </p><p>2、使用了聚合函数。 </p><p>3、满足HAVING 子句中条件的分组将被显示。 </p><p>4、HAVING 不能单独使用，必须要跟 GROUP BY 一起使用</p><p>2、<strong>非法使用聚合函数 ： 不能在</strong> <strong>WHERE</strong> <strong>子句中使用聚合函数。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271344068.png" alt="image-20220427134404009"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">+ HAVING：过滤分组（分组后）</span><br><span class="line">    + 基本使用</span><br><span class="line">        + 一旦过滤条件出现组函数，过滤条件必须用HAVING替换</span><br><span class="line">        + HAVING必须声明在GROUP BY后面</span><br><span class="line">        + 开发中，使用HAVING的前提是有GROUP BY</span><br><span class="line">        + 普通过滤条件也可以写在HAVING</span><br><span class="line">            + 推荐WHERE，执行效率高</span><br><span class="line">            + 当过滤条件中有聚合函数，此过滤条件必须声明在HAVING中</span><br><span class="line">            + 当过滤条件中没有聚合函数，此过滤条件声明在WHERE中更好</span><br></pre></td></tr></table></figure><h2 id="WHERE与HAVING的对比"><a href="#WHERE与HAVING的对比" class="headerlink" title="WHERE与HAVING的对比"></a>WHERE与HAVING的对比</h2><p>1、区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； </p><p>HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。 </p><p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。 </p><p>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。 </p><p>这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。 </p><p><strong>开发中的选择：</strong></p><p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ HAVING和WHERE对比</span><br><span class="line">    + HAVING范围更广</span><br><span class="line">    + 如果过滤条件没有聚合函数，WHERE执行效率高</span><br></pre></td></tr></table></figure><h2 id="SQL底层执行-amp-原理"><a href="#SQL底层执行-amp-原理" class="headerlink" title="SQL底层执行&amp;原理"></a>SQL底层执行&amp;原理</h2><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤： </p><p>1、首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1。</p><p>2、通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2。</p><p>3、添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</p><p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。 </p><p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 <code>vt1</code> ，就可以在此基础上再进行 <code>WHERE 阶段</code> 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表<code> vt2</code> 。 </p><p>然后进入第三步和第四步，也就是 <code>GROUP 和 HAVING 阶段</code> 。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表<code> vt3</code> 和<code>vt4</code>。 </p><p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 <code>SELECT 和 DISTINCT阶段</code> 。 </p><p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5-1</code> 和 <code>vt5-2 </code>。 </p><p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 <code>ORDER BY 阶段</code> ，得到虚拟表<code>vt6</code> 。 </p><p>最后在 vt6 的基础上，取出指定行的记录，也就是<code> LIMIT 阶段</code> ，得到最终的结果，对应的是虚拟表<code>vt7</code> 。 </p><p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。 </p><p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，<strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ SQL底层执行原理</span><br><span class="line">    + SELECT语句的完整结构</span><br><span class="line">        + SQL92</span><br><span class="line">            + SELECT ...（存在聚合函数）</span><br><span class="line">            + FROM ...</span><br><span class="line">            + WHERE ...（不包含聚合函数的过滤条件）</span><br><span class="line">            + GROUP BY ...</span><br><span class="line">            + HAVING ...（包含聚合函数的过滤条件）</span><br><span class="line">            + ORDER BY ...</span><br><span class="line">            + LIMIT ...</span><br><span class="line">        + SQL99</span><br><span class="line">            + SELECT ...（存在聚合函数）</span><br><span class="line">            + FROM ...（LEFT/RIGHT）JOIN...ON...（多表的连接条件）</span><br><span class="line">            + WHERE ...（不包含聚合函数的过滤条件）</span><br><span class="line">            + GROUP BY ...</span><br><span class="line">            + HAVING ...（包含聚合函数的过滤条件）</span><br><span class="line">            + ORDER BY ...</span><br><span class="line">            + LIMIT ...</span><br><span class="line">        + SQL语句执行过程</span><br><span class="line">            + FROM ... -&gt; ON ... 连接条件 -&gt; LEFT/RIGTH JOIN -&gt; WHERE ... -&gt; GROUP BY -&gt; HAVING  -&gt; （行数限制）</span><br><span class="line">            + SELECT 选择字段 -&gt; DISTINCT -&gt; （列数限制）</span><br><span class="line">            + ORDER BY -&gt; LIMIT</span><br><span class="line">        + HAVING在WHERE 和 OROUP BY 后面，所以效率慢</span><br><span class="line">        + SELECT的别名只能在ORDER BY用</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h2 id="写在前面-2"><a href="#写在前面-2" class="headerlink" title="写在前面"></a>写在前面</h2><p>1、子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。</p><p>SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p><p>2、我们按内查询的结果返回一条还是多条记录，将子查询分为单行子查询 、 多行子查询 。</p><p>3、我们按内查询是否被执行多次，将子查询划分为 相关(或关联)子查询 和 不相关(或非关联)子查询 。</p><p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</p><p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 重点关注关联查询和子查询</span><br><span class="line">+ 子查询</span><br><span class="line">    + 子查询是指一个查询语句嵌套在另一个查询与内部的查询</span><br><span class="line">    + 需要从一个表中获取数据结果，再根据结果进行比较</span><br><span class="line">+ 方式1：多次查询</span><br><span class="line">+ 方式2：自连接</span><br><span class="line">+ 子查询</span><br><span class="line">+ 使用</span><br><span class="line">    + 先于主查询完成</span><br><span class="line">    + 包括在括号内</span><br><span class="line">    + 子查询放在比较条件的右侧</span><br><span class="line">+ 子查询分类</span><br><span class="line">    + 单行子查询 - 多行子查询</span><br><span class="line">        + 子查询结果为单行&amp;多行</span><br><span class="line">    + 相关子查询 - 不相关子查询</span><br><span class="line">        + 内查询是否被执行多次</span><br><span class="line">        + 相关子查询</span><br><span class="line">            + 内查询需要外查询条件</span><br></pre></td></tr></table></figure><h2 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h2><p><img src="https://gitee.com/namdev/picgo/raw/master/img/202204200858456.png" alt="image-20220419180546105"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 单行子查询</span><br><span class="line">    + 单行比较操作符</span><br><span class="line">        + 题目</span><br><span class="line">            + 方法一：不成对比较</span><br><span class="line">            + 方法二：成对查询（了解）</span><br><span class="line">+ 编写技巧</span><br><span class="line">    + 从里往外</span><br><span class="line">    + 从外往里</span><br><span class="line">+ HAVING中的子查询</span><br><span class="line">+ CASE中的子查询</span><br><span class="line">    + CASE xxx WHEN (SELECT)</span><br><span class="line">+ 不确定的地方的都可以使用子查询</span><br><span class="line">+ 非法使用子查询</span><br></pre></td></tr></table></figure><h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h2><p>也称为集合比较子查询</p><p>内查询返回多行</p><p>使用多行比较操作符</p><p><img src="https://gitee.com/namdev/picgo/raw/master/img/202204200859386.png" alt="image-20220419180613665"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 多行子查询</span><br><span class="line">    + 内查询返回多行数据</span><br><span class="line">+ 多行比较操作符</span><br><span class="line">    + IN ANY ALL SOME(ANY)</span><br><span class="line">+ IN</span><br><span class="line">+ ALL/ANY</span><br><span class="line">+ Mysql聚合函数不能嵌套</span><br><span class="line">    + 可以替换表</span><br><span class="line">    + 可以用ALL、ANY替换</span><br><span class="line">+ 多行查询结果作为表</span><br><span class="line">+ 空值问题</span><br></pre></td></tr></table></figure><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h2><p>1、<strong>相关子查询执行流程</strong></p><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询 。</p><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/202204271344588.png" alt="image-20220427134445704"></p><p>2、from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用。</p><p>3、EXISTS 与 NOT EXISTS关键字 </p><p>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。 </p><p>如果在子查询中不存在满足条件的行： </p><ul><li>条件返回 FALSE </li><li>继续在子查询中查找 </li></ul><p>如果在子查询中存在满足条件的行： </p><ul><li>   不在子查询中继续查找 </li><li>   条件返回 TRUE </li></ul><p>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。 </p><p>4、题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。</p><p>可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 相关子查询</span><br><span class="line">    + 内查询需要外查询的列</span><br><span class="line">+ 内部使用外部表数据</span><br><span class="line">+ 方式二：FROM使用子查询</span><br><span class="line">    + 作为表进行连接</span><br><span class="line">+ ORDER BY中的子查询</span><br><span class="line">+ EXISTS、NOT EXISTS</span><br><span class="line">    + 找到为TRUE的记录就停止查找</span><br><span class="line">+ NOT EXISTS</span><br><span class="line">    + 始终没有找到，返回TRUE</span><br><span class="line">+ 更新删除操作，运用子查询</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——谷歌、微软、亚马逊等面试题</title>
      <link href="/2022/04/05/%E7%AE%97%E6%B3%95-%E8%B0%B7%E6%AD%8C%E3%80%81%E5%BE%AE%E8%BD%AF%E3%80%81%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/05/%E7%AE%97%E6%B3%95-%E8%B0%B7%E6%AD%8C%E3%80%81%E5%BE%AE%E8%BD%AF%E3%80%81%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="333、最大BST子树"><a href="#333、最大BST子树" class="headerlink" title="333、最大BST子树"></a>333、最大BST子树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405183659863.png" alt="image-20220405183659863"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 找到最大二叉搜索树子树</span><br><span class="line">+ 自顶向下（递归实现）</span><br><span class="line">    + 如果根节点不是BST</span><br><span class="line">        + 方法：判断root树是否为BST</span><br><span class="line">        + 方法：节点计数</span><br><span class="line">    + 递归左子树、右子树，返回max</span><br><span class="line">+ 递归重要的是想清楚方法的功能</span><br><span class="line">+ 自底向上（后序遍历）</span><br><span class="line">    + 如果下面子树不是BST</span><br><span class="line">        + 则所有父节点都不是BST</span><br><span class="line">        + 父节点的另一子树不一定</span><br><span class="line">    + 结合info信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405183759918.png" alt="image-20220405183759918"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 自底向上：从底部开始向上，记录收集信息</span><br><span class="line">    + 原理（向上递推）</span><br><span class="line">        + 左子树是BST，右子树也是BST，root符合条件</span><br><span class="line">            + root也是BST</span><br><span class="line">        + 利用子树的信息，向上递推</span><br><span class="line">    + 准备</span><br><span class="line">        + info类</span><br><span class="line">            + 最大BST子树的：根节点、节点数量、node的最大最小值</span><br><span class="line">    + 实现</span><br><span class="line">        + 返回根节点的info信息（递归）</span><br><span class="line">            + 结束条件：root为null</span><br><span class="line">            + 递归查找左子树info</span><br><span class="line">            + 递归查找右子树info</span><br><span class="line">            + 左右子树的info，四种情况</span><br><span class="line">                + 1、左右最大BST为本身，root大于左最大，root小于右最小</span><br><span class="line">                    + 整棵树为BST</span><br><span class="line">                + 2、左子树为空，右子树最大BST为本身，root小于右最小</span><br><span class="line">                + 3、左子树最大BST为本身，右子树为空，root大于左最大</span><br><span class="line">                + 4、左右都为空，root为BST</span><br><span class="line">                + 5、左右不为空（有BST子树），取size最大值</span><br><span class="line">+ li判断、赋值</span><br><span class="line">+ ri判断、赋值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405183847831.png" alt="image-20220405183847831"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>94、98、230、101、108、102、104</p><p>105、106、297、449</p><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>深度优先搜索：</p><p>解决排列组合问题</p><h2 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、电话号码的字母组合</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184008333.png" alt="image-20220405184008333"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 扫描字符</span><br><span class="line">    + DFS：回溯、剪枝 </span><br><span class="line">+ 画树状图，从上到下</span><br><span class="line">+ 实现</span><br><span class="line">    + dfs（递归）</span><br><span class="line">        + 枚举这一层可以做的选择</span><br><span class="line">            + 根据参数，获取每一层</span><br><span class="line">        + 遍历所有选择</span><br><span class="line">            + 保存当前选择到字符数组char[]（记录结果）</span><br><span class="line">            + 选择当前值进入下一层</span><br><span class="line">        + 结束条件：层数达到最底层，char[]结果加入list</span><br><span class="line">    + 递归天然特性，自动回溯</span><br><span class="line">        + 栈</span><br><span class="line">    + 原理</span><br><span class="line">        + 遍历 + 递归 + 回溯</span><br><span class="line">+ 优化</span><br><span class="line">    + 成员变量改为参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184046209.png" alt="image-20220405184046209"></p><h2 id="46、全排列"><a href="#46、全排列" class="headerlink" title="46、全排列"></a>46、全排列</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184057161.png" alt="image-20220405184057161"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ dfs</span><br><span class="line">    + 结束条件：到达最后一层</span><br><span class="line">        + 放入数组到list中</span><br><span class="line">    + 遍历（枚举当前一层的选择：boolean数组标识是否被选择）</span><br><span class="line">        + 存储当前选择到数组中</span><br><span class="line">        + 标记为已选择</span><br><span class="line">        + 递归到下一层</span><br><span class="line">        + 回溯回来-还原</span><br><span class="line">            + 设置为未标记</span><br><span class="line">+ 原理</span><br><span class="line">    + 遍历选择</span><br><span class="line">        + 判断是否使用</span><br><span class="line">        + 记录结果</span><br><span class="line">        + 往下递归</span><br><span class="line">        + 设置未使用</span><br><span class="line">    + 结束：递归到最后一层，添加结果</span><br><span class="line">+ 优化</span><br><span class="line">    + 用list存储结果，省略boolean[]</span><br><span class="line">        + 判断是否能用的选择？</span><br><span class="line">            + 查找是否list中contains这个元素：O(n)</span><br><span class="line">        + 回溯时，删除最后一个结果</span><br><span class="line">            + 保证后面的选择继续遍历</span><br><span class="line">+ 最理想做法</span><br><span class="line">    + 一个num[]数组即可，不需要result[]，不需要boolean[]</span><br><span class="line">        + 0、1、2分别放123层的选择</span><br><span class="line">        + 循环</span><br><span class="line">            + 让0号位置与0、1、2进行交换</span><br><span class="line">            + 进入下一层，1号位置分别与1、2交换</span><br><span class="line">            + 进入下一层，2号位置与2交换</span><br><span class="line">            + 最后的num[]数组即为结果，装入list</span><br><span class="line">            + 回溯到上一层</span><br><span class="line">            + 天然解决，不重复问题</span><br><span class="line">            + 后面的不能交换前面的，只能跟后面的交换</span><br><span class="line">    + 实现</span><br><span class="line">        + 循环（起始：层数）</span><br><span class="line">            + 交换：当前层数与后面每一位i</span><br><span class="line">                + 基于原数组，非交换后的数组</span><br><span class="line">            + 递归到下一层</span><br><span class="line">            + 回溯，恢复现场</span><br><span class="line">                + 再交换回来，恢复原数组！！！（恢复上层，以便上层下次交换）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184224725.png" alt="image-20220405184224725"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184211315.png" alt="image-20220405184211315"></p><h2 id="46、全排列2"><a href="#46、全排列2" class="headerlink" title="46、全排列2"></a>46、全排列2</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184239345.png" alt="image-20220405184239345"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 序列可重复</span><br><span class="line">    + 全排列，结果不可重复</span><br><span class="line">+ 去重</span><br><span class="line">    + 1、加入结果时，list的contains判断是否存在</span><br><span class="line">        + O(n)</span><br><span class="line">    + 2、位置交换时进行判断（有的交换后多个选择相同）</span><br><span class="line">        + 什么情况下排除？</span><br><span class="line">            + 遍历数组</span><br><span class="line">                + 判断交换位置之间是否存在相同的值</span><br><span class="line">                    + 从index开始（index本身也算交换，相同就和后面重复）</span><br><span class="line">                + 若存在相同的值，则说明已经交换过</span><br><span class="line">                    + 本位置再次交换，结果相同</span><br><span class="line">        + 不交换，跳过</span><br><span class="line">+ 前面的交换结果不一样，也被排除？</span><br><span class="line">    + 提前剪枝</span><br><span class="line">    + 本质上一样，后面进行排列组合的结果一样</span><br><span class="line">+ 保证index位置值只出现一次</span><br><span class="line">    + 若index一样，后面即使不一样，排列组合也一样</span><br><span class="line">    + 若index头不一样，后面必然不一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184319057.png" alt="image-20220405184319057"></p><h2 id="22、括号生成"><a href="#22、括号生成" class="headerlink" title="22、括号生成"></a>22、括号生成</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184331643.png" alt="image-20220405184331643"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 生成指定数量小括号</span><br><span class="line">    + 合法</span><br><span class="line">    + 排列组合</span><br><span class="line">+ 总量：左括号3个，右括号3个</span><br><span class="line">+ 限制：当剩余数量相同（已经匹配完），必须选左括号</span><br><span class="line">+ 实现</span><br><span class="line">    + 特殊情况</span><br><span class="line">    + dfs递归（传入左括号，右括号剩余情况）</span><br><span class="line">        + 结束条件：最后一层，添加结果</span><br><span class="line">        + 情况判断（拆开for循环的选择，分别判断）</span><br><span class="line">            + 左括号大于0</span><br><span class="line">                + 本层选择左括号</span><br><span class="line">                + 递归下一层，左括号-1</span><br><span class="line">            + 右括号大于0，右不等于左</span><br><span class="line">                + 本层选择右括号</span><br><span class="line">                + 递归下一层，右括号-1</span><br><span class="line">        + 回溯，不需要恢复</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184406890.png" alt="image-20220405184406890"></p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>51、52、112、113</p><p>39、93</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 路径总和2</span><br><span class="line">    + 结束条件</span><br><span class="line">        + 边界条件：达到叶子节点停止</span><br><span class="line">        + 添加结果：路径和是否满足，满足则添加</span><br><span class="line">    + 参数：剩余选择的值总和</span><br><span class="line">+ 组合总和</span><br><span class="line">    + 找出总和为target的组合</span><br><span class="line">    + 元素可以选择多次！！</span><br><span class="line">    + dfs</span><br><span class="line">        + 参数：剩余值</span><br><span class="line">        + 根据剩余值，枚举可选择值</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DFS：</p><p>1、结束条件：边界条件，添加结果</p><p>2、每一层，for枚举选择</p><ul><li>选择、情况筛选</li><li>递归</li><li>回溯修改</li></ul><h1 id="高频题"><a href="#高频题" class="headerlink" title="高频题"></a>高频题</h1><h2 id="283、移动零"><a href="#283、移动零" class="headerlink" title="283、移动零"></a>283、移动零</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184543330.png" alt="image-20220405184543330"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 一趟遍历 + 双指针（保证相对顺序）</span><br><span class="line">    + 遇到非0的挪到前面</span><br><span class="line">        + i和cur交换</span><br><span class="line">        + 同时后移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184556090.png" alt="image-20220405184556090"></p><h2 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184605349.png" alt="image-20220405184605349"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力 n²</span><br><span class="line">    + 枚举全部情况</span><br><span class="line">+ 一次遍历</span><br><span class="line">    + 扫描到每一个数，判断前面有没有target-i的数（O(1)查找）</span><br><span class="line">        + map</span><br><span class="line">+ sort&amp;双指针（头尾）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184623995.png" alt="image-20220405184623995"></p><h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184632963.png" alt="image-20220405184632963"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力 O(n3)</span><br><span class="line">    + 枚举每个三元组</span><br><span class="line">    + 去重</span><br><span class="line">+ 暴力优化</span><br><span class="line">    + 1、sort排序</span><br><span class="line">    + 2、i遍历每个元素</span><br><span class="line">        + 去重</span><br><span class="line">            + 若i与前面重复，则跳过</span><br><span class="line">        + l和r指针指向后面区间的头尾</span><br><span class="line">        + while循环查找和</span><br><span class="line">            + 偏小</span><br><span class="line">                + 跳过相同元素</span><br><span class="line">                + l++</span><br><span class="line">            + 偏大</span><br><span class="line">                + 跳过相同元素</span><br><span class="line">                + r--</span><br><span class="line">    + 原理</span><br><span class="line">        + 定一值，获取新的target</span><br><span class="line">            + 在剩下区间搜索和为target，双指针法</span><br><span class="line">        + 区间</span><br><span class="line">+ 偏门做法（复杂）</span><br><span class="line">    + 尽可能排除不必要扫描</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184713294.png" alt="image-20220405184713294"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184717053.png" alt="image-20220405184717053"></p><h2 id="50、pow-x-n"><a href="#50、pow-x-n" class="headerlink" title="50、pow(x,n)"></a>50、pow(x,n)</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184726470.png" alt="image-20220405184726470"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力O(n)</span><br><span class="line">    + while循环</span><br><span class="line">+ 快速幂（分治）</span><br><span class="line">    + O(logn)</span><br><span class="line">    + 递归法</span><br><span class="line">        + 结束条件：n为0</span><br><span class="line">        + 递归拆分</span><br><span class="line">        + 结果相乘</span><br><span class="line">+ 递归：复杂度计算</span><br><span class="line">    + 非递归法</span><br><span class="line">        + 循环</span><br><span class="line">            + x——x2——x4——x8——x16</span><br><span class="line">            + 结果相乘，需要的参数为1，不需要的参数为0</span><br><span class="line">            + 根据n的二进制位判断0/1</span><br><span class="line">                + 负数的/2和&gt;&gt;1不同</span><br><span class="line">+ 快速幂补充</span><br><span class="line">    + 不能先算x的y次方再模（可能溢出）</span><br><span class="line">    + 使用公式</span><br><span class="line">        + 每次相乘之前都模z，相乘之后模z</span><br><span class="line">    + 非递归</span><br><span class="line">    + 递归</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184821403.png" alt="image-20220405184821403"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184832719.png" alt="image-20220405184832719"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184837058.png" alt="image-20220405184837058"></p><h2 id="面试题62、圆圈中最后剩下的数字"><a href="#面试题62、圆圈中最后剩下的数字" class="headerlink" title="面试题62、圆圈中最后剩下的数字"></a>面试题62、圆圈中最后剩下的数字</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184849853.png" alt="image-20220405184849853"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ 约瑟夫环问题</span><br><span class="line">    + 循环数n个数，删除</span><br><span class="line">    + 求最后一个数</span><br><span class="line">    + 环形链表解决</span><br><span class="line">        + 环形链表不好实现</span><br><span class="line">+ 数学公式解决</span><br><span class="line">    + 递归实现（自顶向下）</span><br><span class="line">        + 结束条件：n为1，返回0（需要剩下一个人）</span><br><span class="line">        + 公式递归</span><br><span class="line">    + 非递归实现（自底向上）</span><br><span class="line">        + 遍历人数</span><br><span class="line">            + 使用公式，从小到大递推</span><br><span class="line">+ 公式推导</span><br><span class="line">    + 先杀一个元素</span><br><span class="line">    + 剩下n-1个元素和n个元素，最后的元素相同</span><br><span class="line">        + 开始的索引不同，n-1个相比n偏移了m个位置</span><br><span class="line">        + 防止越界，最后模上长度</span><br><span class="line">    + 编号不从0开始：</span><br><span class="line">        + 正常算出最后元素，加上偏移位置即可</span><br><span class="line">            + 中间删除位置都是相对的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184935987.png" alt="image-20220405184935987"></p><h2 id="54、螺旋矩阵"><a href="#54、螺旋矩阵" class="headerlink" title="54、螺旋矩阵"></a>54、螺旋矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405184942786.png" alt="image-20220405184942786"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 顺时针列出矩阵元素</span><br><span class="line">+ 思路</span><br><span class="line">    + 标识每一圈</span><br><span class="line">    + while循环每一圈</span><br><span class="line">        + 遍历top行：left到right</span><br><span class="line">            + top++</span><br><span class="line">        + 遍历right列：top到bottom</span><br><span class="line">            + right--</span><br><span class="line">        + 特殊处理：奇数行、偶数列情况</span><br><span class="line">            + top&gt;bottom || left &gt; right</span><br><span class="line">        + 遍历bottom行：right到left</span><br><span class="line">            + bottom--</span><br><span class="line">        + 遍历left列：bottom到top</span><br><span class="line">            + left++</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185000309.png" alt="image-20220405185000309"></p><h2 id="146、LRU缓存机制"><a href="#146、LRU缓存机制" class="headerlink" title="146、LRU缓存机制"></a>146、LRU缓存机制</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185011387.png" alt="image-20220405185011387"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+ LRU：最近最少使用</span><br><span class="line">    + 操作系统页面置换算法，选择LRU的页面淘汰</span><br><span class="line">+ 常用实现方式</span><br><span class="line">    + 哈希表 + 双向链表</span><br><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + hashmap(capacity)</span><br><span class="line">    + get()</span><br><span class="line">        + 元素存在</span><br><span class="line">            + 链表插入：</span><br><span class="line">            + 返回元素</span><br><span class="line">    + put()</span><br><span class="line">        + 条件判断</span><br><span class="line">            + 是否已经存在？更新值</span><br><span class="line">        + 容量达到capacity，淘汰算法：</span><br><span class="line">            + List存储最近使用的key</span><br><span class="line">                + 尾插，删除头元素</span><br><span class="line">            + 双向链表</span><br><span class="line">        + put</span><br><span class="line">+ 自己实现双向链表</span><br><span class="line">    + 准备</span><br><span class="line">        + 虚拟头、尾节点</span><br><span class="line">        + node类</span><br><span class="line">            + key、value、双向指针</span><br><span class="line">    + 节点被get、put修改、添加之后：更新优先级</span><br><span class="line">        + 头插法，插入到头结点的后面</span><br><span class="line">            + 删除节点deleteNode</span><br><span class="line">                + 后面的pre指向前面的node</span><br><span class="line">                + 前面的next指向后面的node</span><br><span class="line">            + 添加到头结点后面insertFirst</span><br><span class="line">                + 先指向后面的节点，再连接头节点</span><br><span class="line">    + put新元素，且容量已满：淘汰最后节点</span><br><span class="line">        + 删除最后一个node节点、删除map中的值</span><br><span class="line">            + map remove</span><br><span class="line">            + deleteNode</span><br><span class="line">        + insertFirst</span><br><span class="line">+ 主流原理</span><br><span class="line">    + 哈希表 + 双向链表（自己实现）</span><br><span class="line">    + 哈希表</span><br><span class="line">        + 存储k-v</span><br><span class="line">    + 双向链表</span><br><span class="line">        + 维护元素的使用优先级</span><br><span class="line">        + 新元素插到最前面</span><br><span class="line">        + 淘汰链表的最后一个元素</span><br><span class="line">    + get</span><br><span class="line">        + get时提升优先级（插入到链表最前面）</span><br><span class="line">    + put</span><br><span class="line">        + 修改</span><br><span class="line">            + 提升优先级</span><br><span class="line">        + 添加新元素，未满</span><br><span class="line">            + 直接put到map</span><br><span class="line">            + 提升优先级</span><br><span class="line">        + 添加新元素，已满</span><br><span class="line">            + 淘汰链表末尾元素</span><br><span class="line">            + 提升新元素的优先级</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185119211.png" alt="image-20220405185119211"></p><h2 id="7、整数反转"><a href="#7、整数反转" class="headerlink" title="7、整数反转"></a>7、整数反转</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185130224.png" alt="image-20220405185130224"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 1、转为字符串 + 双指针</span><br><span class="line">+ 2、取各个位数</span><br><span class="line">    + 循环倒序取出每一位（取模）</span><br><span class="line">        + 正序组合新的数</span><br><span class="line">        + 防止溢出（计算回去判断是否是之前的值），返回0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185144721.png" alt="image-20220405185144721"></p><h2 id="252、会议室"><a href="#252、会议室" class="headerlink" title="252、会议室"></a>252、会议室</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185152025.png" alt="image-20220405185152025"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 判断区间是否重叠</span><br><span class="line">    + 排序sort（开始时间）</span><br><span class="line">    + 判断前后两个区间</span><br><span class="line">        + 前面结束时间和后面开始时间是否符合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185203239.png" alt="image-20220405185203239"></p><h2 id="252、会议室2"><a href="#252、会议室2" class="headerlink" title="252、会议室2"></a>252、会议室2</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185209314.png" alt="image-20220405185209314"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ 避免会议冲突，至少需要多少间会议室</span><br><span class="line">    + 贪心算法</span><br><span class="line">+ 1、最小堆（小顶堆：获取最小值O(1)）</span><br><span class="line">    + 思路</span><br><span class="line">        + 排序</span><br><span class="line">        + 结束时间放到堆中</span><br><span class="line">        + 开始时间比较堆顶的结束时间</span><br><span class="line">            + 符合，则移除堆顶，结束时间进入堆</span><br><span class="line">            + 每次拿最小值：越小结束的越先利用</span><br><span class="line">    + 实现</span><br><span class="line">        + 准备：</span><br><span class="line">            + priorityqueue最小堆</span><br><span class="line">            + sort开始时间</span><br><span class="line">            + 添加0号会议结束时间</span><br><span class="line">    + 遍历每个会议</span><br><span class="line">        + 判断i的开始时间是否大于堆顶</span><br><span class="line">            + 堆顶：占用一个会议室的最早会议结束时间</span><br><span class="line">            + 大于</span><br><span class="line">                + 堆顶移除</span><br><span class="line">                + i的结束时间进入堆</span><br><span class="line">            + 小于</span><br><span class="line">                + 再开一间会议室</span><br><span class="line">                + i的结束时间进入堆</span><br><span class="line">+ 原理</span><br><span class="line">    + 排排序开始时间</span><br><span class="line">    + 堆中排序结束时间</span><br><span class="line">+ 2、分开排序（相当于提前排好堆）</span><br><span class="line">    + 分别排序开始、结束时间</span><br><span class="line">    + 扫描会议开始时间</span><br><span class="line">        + 只关心结束时间最短的</span><br><span class="line">        + 小于结束时间最小值，开一个房间</span><br><span class="line">        + 大于结束时间最小值，结束时间后移（堆顶变化）</span><br><span class="line">+ 原理：贪心 + 一次遍历</span><br><span class="line">    + 按照会议（排序好）进行遍历</span><br><span class="line">        + 维护全部会议室最小结束时间</span><br><span class="line">            + 若小于全部会议室结束时间，加会议室</span><br><span class="line">            + 若大于一间的结束时间，可以利用会议室</span><br><span class="line">                + 最小结束时间更新（上一个时间已被使用）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185315742.png" alt="image-20220405185315742"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185320766.png" alt="image-20220405185320766"></p><h2 id="11、盛最多水的容器"><a href="#11、盛最多水的容器" class="headerlink" title="11、盛最多水的容器"></a>11、盛最多水的容器</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185336392.png" alt="image-20220405185336392"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力</span><br><span class="line">    + 枚举任意两根柱子</span><br><span class="line">    + 维护最大值</span><br><span class="line">+ 双指针（首尾） + 一次遍历</span><br><span class="line">    + 小的指针移动</span><br><span class="line">        + 大柱子不动，为了求出最大值</span><br><span class="line">        + 减少不必要、小的组合</span><br><span class="line">    + 实现</span><br><span class="line">        + 循环（左指针小于右指针）</span><br><span class="line">            + 小于移动</span><br><span class="line">            + 求面积</span><br><span class="line">                + 宽度、高度（小的）</span><br><span class="line">+ 优化：跳过不必要组合</span><br><span class="line">    + 维护左右算过的min</span><br><span class="line">    + 小于min直接跳过</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185405367.png" alt="image-20220405185405367"></p><h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185415324.png" alt="image-20220405185415324"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ 1、求每一行能接多少</span><br><span class="line">+ 2、求每根柱子i上接多少水</span><br><span class="line">    + 思路</span><br><span class="line">        + i接的水取决于min（左、右柱子最大值）</span><br><span class="line">            + 左边右边必须有比i大的柱子</span><br><span class="line">        + 接水量：高度减去当前柱子高度</span><br><span class="line">    + 实现</span><br><span class="line">        + 准备</span><br><span class="line">            + 左、右最大柱子数组</span><br><span class="line">        + 求左边最大值数组（一次遍历 or 动态规划）</span><br><span class="line">            + 动态规划dp[i]：i左边的最大值</span><br><span class="line">                + dp[i] = max(high[i],dp[i-1])</span><br><span class="line">                    + i-1左边柱子最大值、i-1柱子</span><br><span class="line">            + 一次遍历：max记录最大值</span><br><span class="line">                + 遍历每个值，进行比较，维护max</span><br><span class="line">        + 求右边最大值数组</span><br><span class="line">        + 遍历每个柱子求接水量（第二个到倒数第二个）</span><br><span class="line">            + 获取左右大柱子最小的高度</span><br><span class="line">            + 若大于当前高度</span><br><span class="line">                + 接水：减去当前高度</span><br><span class="line">+ 优化</span><br><span class="line">    + 放到一个循环中</span><br><span class="line">    + 只记录前面的max，省略数组</span><br><span class="line">+ 3、双指针（左右边界） + 一次遍历</span><br><span class="line">    + while循环</span><br><span class="line">        + 取出较小的柱子lower</span><br><span class="line">            + 高度小的往前移动</span><br><span class="line">        + 维护每次较小的柱子的lowerMax</span><br><span class="line">        + 每个柱子能放多少水：lowerMax - lower</span><br><span class="line">    + 原理</span><br><span class="line">        + 往中间移动过程中，若小于外围的（两个柱子中的最小值）的最大值</span><br><span class="line">            + 说明这个柱子可以盛水</span><br><span class="line">        + lowermax一直更新，所以必是外围最大值（两边最小那个）</span><br><span class="line">+ 双指针相比之前</span><br><span class="line">    + 之前：先搞清楚了每个柱子左右最大值是多少</span><br><span class="line">        + 所以直接可以遍历取值计算</span><br><span class="line">    + 一次遍历：边遍历，边维护左边右边最大值</span><br><span class="line">        + 没有必要把每个位置左右都求出来</span><br><span class="line">        + 只需要遍历过程中max记录就行</span><br><span class="line">        + 因为每次都是取左右最小的那个</span><br><span class="line">            + 所以另一边一定大于当前最大值</span><br><span class="line">            + 所以只需要维护当前边的最大值进行计算即可 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220405185842638.png" alt="image-20220405185842638"></p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p>215、315、4、149、200</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ 刷题建议</span><br><span class="line">    + 10-15分钟没思路，看答案</span><br><span class="line">        + 读懂答案，照抄一遍（自己思路 + 作者思路）</span><br><span class="line">        + 自己手写一遍</span><br><span class="line">    + 每道题所有解法都看一遍！！</span><br><span class="line">    + 英文版讨论区靠前的代码（全世界大神写的）</span><br><span class="line">        + 优雅、精简</span><br><span class="line">    + 观摩中文、英文打败时间100%的提交代码</span><br><span class="line">+ 面试建议</span><br><span class="line">    + 沟通题目细节</span><br><span class="line">        + 时间、空间复杂度</span><br><span class="line">    + 口述：把能想到的专业术语关键词、解法都可以说出来</span><br><span class="line">        + 每种解法空间、时间复杂度</span><br><span class="line">    + 笔试、机试</span><br><span class="line">        + 写思路比代码更重要</span><br><span class="line">        + 写出空间时间复杂度</span><br><span class="line">+ 联想关键词</span><br><span class="line">    + 数组：</span><br><span class="line">        + 排序、双指针、三指针、扫描方向、一次遍历</span><br><span class="line">    + 链表：</span><br><span class="line">        + 虚拟头结点、双指针、快慢指针、翻转、中间节点</span><br><span class="line">    + 排列组合</span><br><span class="line">        + DFS</span><br><span class="line">    + 最值</span><br><span class="line">        + 贪心、排序、动态优化</span><br><span class="line">    + 对称\顺序</span><br><span class="line">        + 栈\队列</span><br><span class="line">    + 二叉树</span><br><span class="line">        + 递归、遍历</span><br><span class="line">    + 搜索数据要求O(1)时间</span><br><span class="line">        + 哈希表</span><br><span class="line">+ 完结撒花</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——贪心算法&amp;分治&amp;递归&amp;回溯&amp;动态规划</title>
      <link href="/2022/04/03/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95&amp;%E5%88%86%E6%B2%BB&amp;%E9%80%92%E5%BD%92&amp;%E5%9B%9E%E6%BA%AF&amp;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/04/03/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95&amp;%E5%88%86%E6%B2%BB&amp;%E9%80%92%E5%BD%92&amp;%E5%9B%9E%E6%BA%AF&amp;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1、贪心策略，也称为贪婪策略。</p><p>每一步都采取当前状态下最优的选择（局部最优解），从而希望推导出全局最优解。</p><p>2、贪心的应用：</p><p>哈夫曼树</p><p>最小生成树算法：Prim、Kruskal</p><p>最短路径算法：Dijkstra</p><h2 id="练习-最优装载问题（加勒比海盗）"><a href="#练习-最优装载问题（加勒比海盗）" class="headerlink" title="练习-最优装载问题（加勒比海盗）"></a>练习-最优装载问题（加勒比海盗）</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174436167.png" alt="image-20220403174436167"></p><p>贪心策略：每次选择最轻的上去（局部最优）</p><h2 id="练习-零钱兑换"><a href="#练习-零钱兑换" class="headerlink" title="练习-零钱兑换"></a>练习-零钱兑换</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174514977.png" alt="image-20220403174514977"></p><p>贪心策略：每次最优选择最大的（每次最优选择）</p><p>结果不一定全局最优。</p><h2 id="练习-01背包"><a href="#练习-01背包" class="headerlink" title="练习-01背包"></a>练习-01背包</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174509161.png" alt="image-20220403174509161"></p><p>贪心策略：</p><p>1、优先价值（价值最大）</p><p>2、优先重量（重量最轻）</p><p>3、优先价值密度（价值/重量）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174531358.png" alt="image-20220403174531358"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + 物品类（价值、重量、价值密度）</span><br><span class="line">        + 物品数组（sort：根据价值密度排序！！！）</span><br><span class="line">        + 总重量、当前重量、总价值、装入物品list</span><br><span class="line">    + 遍历物品数组</span><br><span class="line">        + 装入物品（更新背包重量、价值、物品等）</span><br><span class="line">        + 结束条件：装满</span><br><span class="line">+ 动态规划：严谨做法</span><br><span class="line">+ 贪心算法很多时候作为辅助（直接用不一定是最优的）！！！</span><br><span class="line">+ 哈夫曼树</span><br><span class="line">    + 贪心策略：每次选择最小的两个作为子节点！！！（放到最下面）</span><br><span class="line">    + 保证距离远的权值小，权值大的距离进，实现最终结果小</span><br><span class="line">+ 最小生成树</span><br><span class="line">    + 普利姆（选路径小的相邻节点）、克鲁斯卡尔（选边，连成树）</span><br><span class="line">    + 贪心策略：每次选择最小的边！！！（在生成树的前提下）</span><br><span class="line">+ 最短路径</span><br><span class="line">    + 克鲁斯卡尔（到每个节点最短的距离）</span><br><span class="line">    + 贪心策略：找到最短路径！！！</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>递归：函数（方法）直接或间接调用自身。</p><p>栈空间：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173517519.png" alt="image-20220403173517519"></p><p>拆解问题：同类型小问题</p><p>1、把规模大的问题变成规模较小的同类型问题</p><p>2、由最小规模问题的解得出较大规模问题的解</p><p>3、很多链表、二叉树相关的问题都可以使用递归来解决</p><ul><li>因为链表、二叉树本身就是递归的结构（链表中包含链表，二叉树中包含二叉树）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173604958.png" alt="image-20220403173604958"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 使用套路</span><br><span class="line">    + 函数功能</span><br><span class="line">    + 原问题和子问题的关系</span><br><span class="line">        + f(n)和f(n-1)</span><br><span class="line">    + 结束条件</span><br><span class="line">        + 什么情况下直接得出解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173727258.png" alt="image-20220403173727258"></p><h2 id="练习-斐波那契数列"><a href="#练习-斐波那契数列" class="headerlink" title="练习-斐波那契数列"></a>练习-斐波那契数列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 斐波那契数列</span><br><span class="line">    + 结束条件：n&lt;2</span><br><span class="line">    + 递归：两个函数之和 </span><br><span class="line">    + 时间复杂度较大</span><br><span class="line">    + 调用过程</span><br><span class="line">        + 重复计算</span><br><span class="line">        + 自顶向下的调用过程</span><br><span class="line">+ 优化1</span><br><span class="line">    + 数组存放计算过的结果（临时缓存）</span><br><span class="line">        + 避免重复计算</span><br><span class="line">    + list[i]放斐波那契第i位的结果</span><br><span class="line">        + 简易缓存</span><br><span class="line">            + 若缓存不存在，则计算</span><br><span class="line">            + 若存在则直接返回</span><br><span class="line">+ 优化2</span><br><span class="line">    + 去除递归</span><br><span class="line">    + 遍历填数组即可</span><br><span class="line">+ 优化3</span><br><span class="line">    + 每次运算只需用到数组中的两个元素</span><br><span class="line">        + 滚动数组</span><br><span class="line">            + 减少空间利用</span><br><span class="line">    + 取模（&amp;）效率更高、求余</span><br><span class="line">+ 优化4</span><br><span class="line">    + 两个int保存数据</span><br><span class="line">    + 双指针</span><br><span class="line">+ 优化5</span><br><span class="line">+ 公式</span><br></pre></td></tr></table></figure><h2 id="递归转非递归"><a href="#递归转非递归" class="headerlink" title="递归转非递归"></a>递归转非递归</h2><p>100%可以转非递归。</p><p>模拟栈。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174118410.png" alt="image-20220403174118410"></p><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>最后一个动作是调用自身。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174144620.png" alt="image-20220403174144620"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174156578.png" alt="image-20220403174156578"></p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>选择不同的岔路口来通往目的地。很适合递归。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174233069.png" alt="image-20220403174233069"></p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>1、分治，也就是分而治之。</p><ul><li>将原问题分解成若干个规模较小的子问题（子问题和原问题的结构一样，只是规模不一样）</li><li>子问题又不断分解成规模更小的子问题，直到不能再分解（直到可以轻易计算出子问题的解）</li><li>利用子问题的解推导出原问题的解</li></ul><p>因此，分治策略非常适合用递归</p><p>2、子问题相互独立——分治</p><p>子问题有关系——动态规划</p><p>3、应用：</p><p>快排（不断分两个子问题）</p><p>归并（分开排序）</p><p>Karatsuba算法（大数乘法）</p><p>4、分治策略：</p><p>分成子问题</p><p>合并子问题</p><h2 id="练习-最大子序列"><a href="#练习-最大子序列" class="headerlink" title="练习-最大子序列"></a>练习-最大子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174854284.png" alt="image-20220403174854284"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力穷举（所有区间）：</span><br><span class="line">    + 双指针划子序列区间</span><br><span class="line">    + 暴力优化：</span><br><span class="line">        + 利用上一次sum统计和</span><br><span class="line">+ 分治</span><br><span class="line">    + 若在mid中间（左右延伸）</span><br><span class="line">        + 从mid加到左边，统计max</span><br><span class="line">        + 从mid加到右边，统计max</span><br><span class="line">    + 若在两边（取最大值）</span><br><span class="line">        + 递归mid，begin</span><br><span class="line">        + 递归mid，end</span><br><span class="line">    + 从三者取最大值</span><br><span class="line">+ 类似归并排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403174933841.png" alt="image-20220403174933841"></p><h2 id="练习-大数乘法"><a href="#练习-大数乘法" class="headerlink" title="练习-大数乘法"></a>练习-大数乘法</h2><p>字符串一个一个相乘，一个一个相加</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175015229.png" alt="image-20220403175015229"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>1、求解最优化问题</p><p>2、通常的使用套路（一步一步优化）</p><p>暴力递归（自顶向下，出现了重叠子问题）</p><p>记忆化搜索（自顶向下）</p><p>递推（自底向上）</p><h2 id="练习-找零钱"><a href="#练习-找零钱" class="headerlink" title="练习-找零钱"></a>练习-找零钱</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175202831.png" alt="image-20220403175202831"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ dp(i)：凑到i最少硬币数</span><br><span class="line">+ 状态转移方程</span><br><span class="line">    + 考虑所有情况</span><br><span class="line">    + 每次选择都有四种情况</span><br><span class="line">+ 暴力递归</span><br><span class="line">    + 问题</span><br><span class="line">        + 自顶向下</span><br><span class="line">        + 子问题重复</span><br><span class="line">+ 记忆化搜索（临时缓存数组）</span><br><span class="line">    + 递归时携带数组（边界等写入数组）</span><br><span class="line">    + 问题</span><br><span class="line">        + 自顶向下</span><br><span class="line">        + 防止坐标越界</span><br><span class="line">+ 动态规划！！！</span><br><span class="line">    + 从第一个值往后推！！！（每个值都计算）</span><br><span class="line">        + 后面的值借助前面的结果！！！</span><br><span class="line">    + 所有的情况考虑进去</span><br><span class="line">    + 自底向上递推</span><br><span class="line">+ 求出方案所选硬币</span><br><span class="line">    + 借助数组记录（arr[n]：总价为n，最后选的硬币）！！！</span><br><span class="line">        + 若是最小值，修改数组（记录为本次选的硬币）</span><br><span class="line">    + 遍历查找数组</span><br><span class="line">        + 根据数组的值（选的硬币）确定前面的索引</span><br><span class="line">+ 用数组存储硬币面值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175220167.png" alt="image-20220403175220167"></p><h2 id="常规流程"><a href="#常规流程" class="headerlink" title="常规流程"></a>常规流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 定义状态（状态是原问题、子问题的解！！！）</span><br><span class="line">        + dp[i]的含义等</span><br><span class="line">    + 设置初始状态（边界）</span><br><span class="line">        + dp[0]的值等</span><br><span class="line">    + 确定状态转移方程</span><br><span class="line">        + 确定dp[i]和dp[i-1]的关系等！！！</span><br><span class="line">+ 题目特点</span><br><span class="line">    + 最优子结构</span><br><span class="line">        + 求解子问题的最优解，可以得到原问题的最优解</span><br><span class="line">    + 无后效性！！！</span><br><span class="line">        + 后面状态的演变不受前面的影响（未来与过去无关）</span><br><span class="line">        + 推导状态只关心前面状态的值，不关心推导过程（只关心值：状态转移方程！！！）</span><br></pre></td></tr></table></figure><h2 id="练习-最大连续子序列和"><a href="#练习-最大连续子序列和" class="headerlink" title="练习-最大连续子序列和"></a>练习-最大连续子序列和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 1、状态定义</span><br><span class="line">    + dp[i]：以nums[i]结尾的最大连续子序列的和</span><br><span class="line">+ 2、初始条件（边界：底层、最前面的值）</span><br><span class="line">    + dp[0] = num[0]</span><br><span class="line">+ 3、状态转移方程（由前面值推出来，后面推导与前面无关）</span><br><span class="line">    + 若前面的最大子序列大于0，则加上末尾</span><br><span class="line">    + 若前面最大小于0，只取末尾</span><br><span class="line">+ 步骤</span><br><span class="line">+ dp[i]</span><br><span class="line">+ dp[0]（前推后最底层）</span><br><span class="line">+ 遍历dp（转移条件！！！）</span><br><span class="line">    + 记录max</span><br><span class="line">+ 求dp(n)只关心前面的dp(n-1)，更前面的不关心，且没有作用了</span><br><span class="line">    + 优化</span><br><span class="line">        + 只用一个空间（后面的覆盖前面的值）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175339285.png" alt="image-20220403175339285"></p><h2 id="练习-最长上升子序列"><a href="#练习-最长上升子序列" class="headerlink" title="练习-最长上升子序列"></a>练习-最长上升子序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 求最大递增长度（非连续）</span><br><span class="line">+ 解法1：动态规划 </span><br><span class="line">    + 状态定义 dp[i]以num[i]结尾的长度</span><br><span class="line">    + 初始状态</span><br><span class="line">        + 每个dp[i]为1</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 遍历前面所有dp[j]</span><br><span class="line">            + 若大于num[j]，则dp[i] = dp[j] + 1</span><br><span class="line">            + 若小于，跳过</span><br><span class="line">+ 解法2：二分搜索★</span><br><span class="line">    + 遍历数组</span><br><span class="line">        + 若某一牌顶元素大于当前，放到其牌顶</span><br><span class="line">        + 最终牌堆数量就是最长上升子序列长度</span><br><span class="line">    + 原理</span><br><span class="line">        + 保证从左往右，牌顶的大小一定是从小到大的！！！</span><br><span class="line">        + 大的数（大于牌顶）往右移 </span><br><span class="line">        + 小的数（大于之前的牌顶，小于之后的牌顶）放到合适的前面合适的位置</span><br><span class="line">    + 牌堆数组</span><br><span class="line">        + 遍历每个元素时遍历牌堆数组，判断、赋值即可</span><br><span class="line">    + 优化</span><br><span class="line">        + 二分查找（数组有序），找到合适牌堆</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175410310.png" alt="image-20220403175410310"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175920416.png" alt="image-20220403175920416"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175942401.png" alt="image-20220403175942401"></p><h2 id="练习-最长公共子序列"><a href="#练习-最长公共子序列" class="headerlink" title="练习-最长公共子序列"></a>练习-最长公共子序列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ 最长公共子序列（可以不连续）</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp(i,j) 前i个和前j个 公共子序列最大长度</span><br><span class="line">    + 初始化</span><br><span class="line">        + dp i 0 、dp j 0 初始值均为0</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 如果i j最后一个元素相等，则dp(i-1,j-1) + 1</span><br><span class="line">        + 如果不相等，最后一位元素对方前面元素是否有子序列</span><br><span class="line">            + i-1和j的公共子序列、i 和 j-1的公共子序列 的最大值</span><br><span class="line">+ 状态转移方程</span><br><span class="line">    + 总之最后一个dp(i,j) 或者dp(i)</span><br><span class="line">    + 要由前面的推出来i-1，j-1等之类的</span><br><span class="line">    + 必须到考虑所有情况</span><br><span class="line">+ 本次dp i j</span><br><span class="line">    + 往前推 i-1,j-1，可以比较最后一位，若相等则构成子序列，直接+1</span><br><span class="line">    + 若等于的情况，还不能确定是否有子序列</span><br><span class="line">        + 最后一位往前继续比较</span><br><span class="line">        + 则可以拿两个的最后一位分别和对面的前面进行比较</span><br><span class="line">+ 实现</span><br><span class="line">    + 递归解决</span><br><span class="line">        + 结束条件（i=0,j=0）</span><br><span class="line">        + 若相等，直接+1</span><br><span class="line">        + 若不相等，获取最大值（i-1,j和i,j-1两个公共子序列，是否有构成新的序列）</span><br><span class="line">+ 动态规划</span><br><span class="line">    + 保证表格的每个格子都能由前面推出来</span><br><span class="line">    + 一个格子一个格子推导</span><br><span class="line">+ 一个格子只跟前面三个格子有关</span><br><span class="line">    + 滚动数组</span><br><span class="line">        + 一维数组（记住一行数据即可！！！）</span><br><span class="line">    + 三个变量 ×</span><br><span class="line">        + 表是一行一行计算的，并非斜着计算</span><br><span class="line">+ 使用一维数组，需要提前保留左上角的值，否则被下面的覆盖</span><br><span class="line">    + 计算左边的数之前，保留左上角的值</span><br><span class="line">    + cur保存上面的值，给下次使用（当做左上角）</span><br><span class="line">+ 优化</span><br><span class="line">    + 使用长度小的作为一维数组</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175550122.png" alt="image-20220403175550122"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175537146.png" alt="image-20220403175537146"></p><h2 id="练习-最长公共子串"><a href="#练习-最长公共子串" class="headerlink" title="练习-最长公共子串"></a>练习-最长公共子串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义：dp(i,j) 以i-1、j-1结尾的长度</span><br><span class="line">        + 不存在则为0</span><br><span class="line">    + 状态初始化</span><br><span class="line">        + (i,0)、(j,0)均为0</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 若i-1 == j-1，dp ij = dp i-1,j-1 + 1</span><br><span class="line">            + 下一个两个字符相等</span><br><span class="line">        + 若不相等，则为0（结尾不相等则为0）</span><br><span class="line">    + 结果：max(dp i j )</span><br><span class="line">+ 每一行进行遍历</span><br><span class="line">+ 实现</span><br><span class="line">+ 画表，容易理解流程，配合参数</span><br><span class="line">    + 格子由左上角推得</span><br><span class="line">+ 一维数组优化</span><br><span class="line">    + 保留一行的左上角</span><br><span class="line">    + 先保留上面，作为下一个的左上角</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175645678.png" alt="image-20220403175645678"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175700075.png" alt="image-20220403175700075"></p><h2 id="练习-01背包-1"><a href="#练习-01背包-1" class="headerlink" title="练习-01背包"></a>练习-01背包</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175736475.png" alt="image-20220403175736475"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp(i,j) 前i件物品，承重为j的可以选的最大价值</span><br><span class="line">    + 状态初始化</span><br><span class="line">        + i,0 、j,0 为0</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 目标放在最后一件物品选还是不选：0/1</span><br><span class="line">        + 如果j&lt;weights[i]，无法选</span><br><span class="line">            + 则最后选择：dp(i,j) = dp(i-1,j)</span><br><span class="line">        + 如果可以选</span><br><span class="line">            + 如果最后一件物品不选，dp(i,j) = dp(i-1,j)</span><br><span class="line">            + 如果选最后一件，dp(i,j) = dp(i-1,j-weights[i-1]) + values[i-1]</span><br><span class="line">            + 则最后选择：dp(i,j) = max&#123; i 件商品0/1&#125;</span><br><span class="line">+ 实现</span><br><span class="line">+ 一行一行计算</span><br><span class="line">+ 一维数组优化</span><br><span class="line">    + 每行从右往左算（左右不依赖，只依赖上面、左上的某一个值）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175742522.png" alt="image-20220403175742522"></p><p>01背包-恰好装满：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 初始状态</span><br><span class="line">    + dp(i,0) = 0 dp(0,j) = 负无穷</span><br><span class="line">+ 必须从已经凑齐的格子过来（非负无穷），且下一个重量必须也凑齐（正数）</span><br><span class="line">    + 才能计算出正数</span><br><span class="line">+ 前面已经凑齐（只要值），只要这次凑齐就行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403175823680.png" alt="image-20220403175823680"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、步骤</p><p>定义状态（状态是原问题、子问题的解）：比如定义 dp(i) 的含义</p><p>设置初始状态（边界）比如设置 dp(0) 的值</p><p>确定状态转移方程：比如确定 dp(i) 和 dp(i – 1) 的关系</p><p>2、可以用动态规划来解决的问题，通常具备2个特点。</p><p>最优子结构（最优化原理）</p><ul><li>通过求解子问题的最优解，可以获得原问题的最优解</li></ul><p>无后效性</p><ul><li><p>某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响（未来与过去无关）</p></li><li><p>在推导后面阶段的状态时，只关心前面阶段的具体状态值，不关心这个状态是怎么一步步推导出来的</p></li></ul><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>1、字符串 thank 的前缀（prefix）、真前缀（proper prefix）、后缀（suffix）、真后缀（proper suffix）</p><p>2、串匹配算法</p><p>蛮力（Brute Force） </p><p>KMP</p><p>Boyer-Moore</p><p>Karp-Rabin</p><p>Sunday</p><p>3、tlen 代表文本串 text 的长度，plen 代表模式串 pattern 的长度</p><h2 id="暴力1"><a href="#暴力1" class="headerlink" title="暴力1"></a>暴力1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + 循环 pi ti &lt; plen tlen 有一个成立</span><br><span class="line">        + 匹配成功</span><br><span class="line">            + pi++</span><br><span class="line">            + ti++</span><br><span class="line">        + 匹配失败</span><br><span class="line">            + ti -= pi - 1</span><br><span class="line">            + pi = 0</span><br><span class="line">    + true（pi == plen）</span><br><span class="line">+ 优化</span><br><span class="line">    + t 后面长度小于 p的长度</span><br><span class="line">    + 没有必要比较了，直接失败</span><br><span class="line">        + ti - pi &lt;= tlen - plen</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180344492.png" alt="image-20220403180344492"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180331607.png" alt="image-20220403180331607"></p><h2 id="暴力2"><a href="#暴力2" class="headerlink" title="暴力2"></a>暴力2</h2><p>ti含义：每一轮比较中，文本串首个比较字符的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + 双循环 ti、pi</span><br><span class="line">        + 匹配成功</span><br><span class="line">            + pi++</span><br><span class="line">        + 匹配失败</span><br><span class="line">            + pi = 0</span><br><span class="line">            + ti++</span><br><span class="line">        + pi == plen</span><br><span class="line">            + true</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180511861.png" alt="image-20220403180511861"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180459122.png" alt="image-20220403180459122"></p><p>暴力性能分析</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180517162.png" alt="image-20220403180517162"></p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>next表的使用：</p><p>1、KMP会预先根据pattern生成一张next表</p><p>2、在哪个地方失败，pi设为next[]相应的值</p><p>3、ti不变</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180558819.png" alt="image-20220403180558819"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180608761.png" alt="image-20220403180608761"></p><p>得到next表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180622269.png" alt="image-20220403180622269"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180638917.png" alt="image-20220403180638917"></p><p>优化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180654371.png" alt="image-20220403180654371"></p><p>性能分析</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180707021.png" alt="image-20220403180707021"></p><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180758846.png" alt="image-20220403180758846"></p><h2 id="RK算法"><a href="#RK算法" class="headerlink" title="RK算法"></a>RK算法</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180847224.png" alt="image-20220403180847224"></p><h2 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403180840183.png" alt="image-20220403180840183"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——百度、阿里、腾讯、京东等面试题</title>
      <link href="/2022/04/03/%E7%AE%97%E6%B3%95-%E7%99%BE%E5%BA%A6%E3%80%81%E9%98%BF%E9%87%8C%E3%80%81%E8%85%BE%E8%AE%AF%E3%80%81%E4%BA%AC%E4%B8%9C%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/03/%E7%AE%97%E6%B3%95-%E7%99%BE%E5%BA%A6%E3%80%81%E9%98%BF%E9%87%8C%E3%80%81%E8%85%BE%E8%AE%AF%E3%80%81%E4%BA%AC%E4%B8%9C%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="面试题01-09-字符串轮转"><a href="#面试题01-09-字符串轮转" class="headerlink" title="面试题01.09.字符串轮转"></a>面试题01.09.字符串轮转</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170011293.png" alt="image-20220403170011293"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 旋转词</span><br><span class="line">    + 特点</span><br><span class="line">        + 拼接两个相同的词</span><br><span class="line">        + 滑动窗口，每个窗口都包含全部词</span><br><span class="line">        + 判断是否为其子串</span><br><span class="line">            + contains()方法</span><br><span class="line">            + KMP</span><br><span class="line">+ 两个数据结构拼接</span><br><span class="line">    + 旋转</span><br><span class="line">    + 链表相交</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170035618.png" alt="image-20220403170035618"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170044049.png" alt="image-20220403170044049"></p><h2 id="572、另一个树的子树"><a href="#572、另一个树的子树" class="headerlink" title="572、另一个树的子树"></a>572、另一个树的子树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170053397.png" alt="image-20220403170053397"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ 判断一棵树是否是另一棵树的子树</span><br><span class="line">    + 遍历（非层次遍历）</span><br><span class="line">+ 暴力</span><br><span class="line">    + 找到子树</span><br><span class="line">    + 判断是否所有子节点都相等</span><br><span class="line">+ 二叉树序列化</span><br><span class="line">    + 遍历，序列化为字符串</span><br><span class="line">        + 如果序列化后是其子串</span><br><span class="line">            + 则为其子树</span><br><span class="line">+ 序列化</span><br><span class="line">    + 每个节点结束后加！（连在一起位数都无法判断）</span><br><span class="line">    + 空节点值为#（保证构建的二叉树唯一）</span><br><span class="line">        + 只有一个后序遍历无空节点，构建无数棵树</span><br><span class="line">+ 如何反序列化？</span><br><span class="line">+ 实现</span><br><span class="line">    + 两个树序列化</span><br><span class="line">        + 序列化（递归）</span><br><span class="line">            + 结束条件：节点为空，序列化#</span><br><span class="line">            + 序列化当前左子树</span><br><span class="line">            + 序列化右子树</span><br><span class="line">            + 拼接当前子树</span><br><span class="line">                + StringBuilder拼接字符串</span><br><span class="line">    + 判断是否为子串</span><br><span class="line">        + contains()</span><br><span class="line">+ 打印树</span><br><span class="line">+ 测试KMP</span><br><span class="line">    + contains改为KMP</span><br><span class="line">+ 前序遍历bug</span><br><span class="line">    + 解决：最前面再加个符号</span><br><span class="line">+ 二叉树序列化字符串</span><br><span class="line">    + 判断两个树的结构方面的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170155652.png" alt="image-20220403170155652"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170204117.png" alt="image-20220403170204117"></p><h2 id="242、有效的字母异位词"><a href="#242、有效的字母异位词" class="headerlink" title="242、有效的字母异位词"></a>242、有效的字母异位词</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170225236.png" alt="image-20220403170225236"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 两个字符串，所有字母都一样，字母的顺序不一样</span><br><span class="line">+ 1、map统计字符</span><br><span class="line">    + 统计每个字符的kv</span><br><span class="line">    + 判断map中是否还有值</span><br><span class="line">+ 2、数组统计字符（都是小写）轻量级</span><br><span class="line">    + askii码进行计算</span><br><span class="line">    + arr[26]统计所有字符的数量</span><br><span class="line">    + 实现</span><br><span class="line">        + 扫描数组</span><br><span class="line">            + 一个字符串，进行相加</span><br><span class="line">            + 一个字符串，进行相减</span><br><span class="line">                + 若数量小于0，则直接返回false</span><br><span class="line">        + 最后判断是否数组元素都为0</span><br><span class="line">+ 优化</span><br><span class="line">    + 继续空间换时间</span><br><span class="line">        + charAt()一直在调方法</span><br><span class="line">        + 字符串转为char[]数组</span><br><span class="line">        + 直接用索引进行取值，效率很快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170303602.png" alt="image-20220403170303602"></p><h2 id="151、翻转字符串里的单词"><a href="#151、翻转字符串里的单词" class="headerlink" title="151、翻转字符串里的单词"></a>151、翻转字符串里的单词</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170533557.png" alt="image-20220403170533557"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 1、消除字符串中多余空格</span><br><span class="line">    + 双指针</span><br><span class="line">        + 若为字符，赋值到前面</span><br><span class="line">        + 若为空格，且前面为字符，赋值空格</span><br><span class="line">            + flag标记：前一个字符是否为空格</span><br><span class="line">+ 2、获取字符串有效长度</span><br><span class="line">    + 若最后为空格，则为cur的位置-1</span><br><span class="line">    + 若最后为字符，则cur位置</span><br><span class="line">+ 3、方法：翻转指定范围字符串</span><br><span class="line">    + 左右边界为两个指针</span><br><span class="line">    + 循环（指针不重合）</span><br><span class="line">        + 左右交换指针值，指针归中</span><br><span class="line">+ 4、对整个字符串逆序</span><br><span class="line">+ 5、对每个单词进行逆序</span><br><span class="line">    + 扫描数组，记录前一个空格位置pre（哨兵）</span><br><span class="line">        + 发现空格时，结束了一个单词</span><br><span class="line">        + 单词在前一个空格和后一个空格之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170618225.png" alt="image-20220403170618225"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170624055.png" alt="image-20220403170624055"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170632372.png" alt="image-20220403170632372"></p><h2 id="3、无重复字符的最长子串"><a href="#3、无重复字符的最长子串" class="headerlink" title="3、无重复字符的最长子串"></a>3、无重复字符的最长子串</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170644411.png" alt="image-20220403170644411"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ 类似动态规划</span><br><span class="line">    + 以i结尾的最长无重复串</span><br><span class="line">    + 维护最大值即为结果</span><br><span class="line">+ 扫描字符</span><br><span class="line">    + 求以i结尾的最长不重复串</span><br><span class="line">        + 假设i-1的子串已经求出来（li到i-1不重复）</span><br><span class="line">            + li为i-1子串的起始位置，pi为i字符上一次出现的位置</span><br><span class="line">                + 如果li在pi右边</span><br><span class="line">                    + i的子串：li到i</span><br><span class="line">                + 如果li在pi左边</span><br><span class="line">                    + i的子串：pi+1到i</span><br><span class="line">                + 如果li==pi</span><br><span class="line">                    + i的子串：pi+1到i</span><br><span class="line">    + 记录每个字符上一次出现的位置（map：k-v、arr[]）</span><br><span class="line">    + 实现</span><br><span class="line">        + map</span><br><span class="line">        + 扫描每个字符（从1开始）</span><br><span class="line">            + 如果pi不存在（map中不存在），设置pi为-1，直接li为起始</span><br><span class="line">                + getOrDefault()</span><br><span class="line">            + 如果pi存在</span><br><span class="line">                + li小于或等于pi才改li的值为li+1</span><br><span class="line">                + 其他情况都li不变（li在右边）</span><br><span class="line">            + 维护max记录i到li子串的长度</span><br><span class="line">+ 优化</span><br><span class="line">    + arr[26] + ascii</span><br><span class="line">+ 想出来？</span><br><span class="line">    + 之前有经验！！</span><br><span class="line">    + 经历过，刷题越来越多</span><br><span class="line">        + 扫一眼就知道用什么思路！ </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170757314.png" alt="image-20220403170757314"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170803833.png" alt="image-20220403170803833"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>5、最长回文子串</p><p>72、编辑距离</p><p>1143、32、1048</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 二叉树序列化</span><br><span class="line">    + 序列化反序列化</span><br><span class="line">    + 判断两棵树的的相同结构</span><br><span class="line">+ 字符串查找子串</span><br><span class="line">    + KMP</span><br><span class="line">    + contains()</span><br><span class="line">+ 字符统计</span><br><span class="line">    + map</span><br><span class="line">    + 数组</span><br><span class="line">+ 结构拼接</span><br><span class="line">    + 字符串拼接</span><br><span class="line">        + 判断翻转</span><br><span class="line">    + 链表拼接</span><br><span class="line">        + 查找相交位置</span><br><span class="line">+ 翻转字符串</span><br><span class="line">+ 分割单词</span><br><span class="line">+ 哨兵pre</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170831008.png" alt="image-20220403170831008"></p><h2 id="面试题47、礼物的最大价值"><a href="#面试题47、礼物的最大价值" class="headerlink" title="面试题47、礼物的最大价值"></a>面试题47、礼物的最大价值</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170842706.png" alt="image-20220403170842706"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义：dp[i][j]：走到ij的最大价值</span><br><span class="line">    + 初始条件：首行首列，不能放在在循环递推</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 一行一行求</span><br><span class="line">        + 依靠上和左的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170858115.png" alt="image-20220403170858115"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403170902652.png" alt="image-20220403170902652"></p><h2 id="121、买卖股票的最佳时机"><a href="#121、买卖股票的最佳时机" class="headerlink" title="121、买卖股票的最佳时机"></a>121、买卖股票的最佳时机</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171107378.png" alt="image-20220403171107378"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 求前面最低买入，和后面最高卖出</span><br><span class="line">+ 从卖的角度思考</span><br><span class="line">    + 每一天都有可能卖，求其最大利润</span><br><span class="line">        + 维护最大利润</span><br><span class="line">    + 扫描一遍 + 双指针</span><br><span class="line">        + 一个指针维护最小值</span><br><span class="line">        + 一个指针遍历</span><br><span class="line">            + 计算与最小值的利润</span><br><span class="line">+ 动态规划</span><br><span class="line">    + 求出相邻两天的价格差</span><br><span class="line">        + 转为：求最大连续子序列和问题</span><br><span class="line">            + dp[i]：以i结尾的最大子序列和</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171147347.png" alt="image-20220403171147347"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171154871.png" alt="image-20220403171154871"></p><h2 id="72、编辑距离"><a href="#72、编辑距离" class="headerlink" title="72、编辑距离"></a>72、编辑距离</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171206720.png" alt="image-20220403171206720"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp i j ：s1 [0,i)转为s2 [0,j)最少操作数</span><br><span class="line">            + s1 的前i个字符转为 s2 前j个字符 最少操作数</span><br><span class="line">    + 初始化</span><br><span class="line">        + [0][j]、[i][0]</span><br><span class="line">            + 最小操作数：i次（全部删除、插入）</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 按行推导</span><br><span class="line">            + dp[i][j]</span><br><span class="line">            + 上、左、左上三种情况推得</span><br><span class="line">        + 四种情况</span><br><span class="line">            + dp[i-1][j]转换过来：差一个字符，+ 1</span><br><span class="line">                + aa-&gt;bb = aaa -&gt; bb + 1</span><br><span class="line">                + 删除一个字符</span><br><span class="line">            + dp[i][j-1]转换过来：差一个字符，+ 1</span><br><span class="line">                + aa -&gt; b = aa -&gt; bb + 1</span><br><span class="line">                + 插入一个字符</span><br><span class="line">            + dp[i-1][j-1]转换过来：</span><br><span class="line">                + 如果最后一个字符相等：相比之前操作一次，替换一个字符，+1</span><br><span class="line">                    + aa -&gt; bb = aaa -&gt; bbb + 1 </span><br><span class="line">                        + bba -&gt; bbb + 1</span><br><span class="line">                    + 换掉一个字符</span><br><span class="line">                + 如果最后一个字符不相等：不操作</span><br><span class="line">                    + 最后一个字符不用动，只用操作前面的</span><br><span class="line">                    + aa -&gt; bb = aab + bbb</span><br><span class="line">                    + 不用操作</span><br><span class="line">        + 遍历，每次求最小转换情况</span><br><span class="line">+ 状态转移方程</span><br><span class="line">    + 考虑所有情况，可以从前面推导来的情况</span><br><span class="line">+ 优化</span><br><span class="line">    + 一维数组</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171325888.png" alt="image-20220403171325888"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171336257.png" alt="image-20220403171336257"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171344200.png" alt="image-20220403171344200"></p><h2 id="5、最长回文子串"><a href="#5、最长回文子串" class="headerlink" title="5、最长回文子串"></a>5、最长回文子串</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171355598.png" alt="image-20220403171355598"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">+ 暴力</span><br><span class="line">    + 双指针遍历所有子串n²</span><br><span class="line">        + 判断回文n</span><br><span class="line">    + 记录最大长度</span><br><span class="line"></span><br><span class="line">+ 动态规划</span><br><span class="line">    + 状态定义</span><br><span class="line">        + dp[i][j]：s[i,j]是否为回文串</span><br><span class="line">    + 初始化</span><br><span class="line">        + i = j : T</span><br><span class="line">    + 状态转移方程</span><br><span class="line">        + 子串长度为2，判断元素是否相同</span><br><span class="line">        + 子串长度大于2</span><br><span class="line">            + 如果[i+1,j-1]是回文串，且元素相等，那么是回文串</span><br><span class="line">                + 左右都减去一个元素且为回文串，判断最后元素</span><br><span class="line">    + 遍历方式</span><br><span class="line">        + 无法从左往右</span><br><span class="line">            + 由左下角推导的</span><br><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + str转换为char[]</span><br><span class="line">        + dp[i][j]</span><br><span class="line">    + 遍历（从下达到上，从左到右）</span><br><span class="line">        + 最后一个字符必须两个相等 &amp;&amp; （长度&lt;=2 或者 子串已经回文）</span><br><span class="line">        + 维护max</span><br><span class="line">+ 优化</span><br><span class="line">    + 一维数组</span><br><span class="line"></span><br><span class="line">+ 扩展中心法</span><br><span class="line">    + 以i为中心，向外拓展</span><br><span class="line">    + 以字符间隙为中心，向外拓展</span><br><span class="line">+ 实现</span><br><span class="line">    + 遍历扫描</span><br><span class="line">        + 不管是间隙为中心还是元素为中心，只要给左右元素的位置就行</span><br><span class="line">        + 扫描字符为中心的回文子串</span><br><span class="line">        + 扫描间隙为中心的回文子串</span><br><span class="line">            + 左右扫描回文子串方法</span><br><span class="line">                + 循环，条件（双指针移动且相等）</span><br><span class="line">                    + 双指针向外扩散（到边界出退出）</span><br><span class="line">        + 维护最大值</span><br><span class="line">+ 优化</span><br><span class="line">    + 1、减少没必要的扫描</span><br><span class="line">        + 已求得的最长子串长度大于剩下的字符长度</span><br><span class="line">    + 2、中间有很多没必要的扩散</span><br><span class="line">        + 实现</span><br><span class="line">            + l和r左右扩散</span><br><span class="line">                + 找到右边第一个不相等的元素为r</span><br><span class="line">                + 左边相邻元素为l</span><br><span class="line">            + 下一次i跳到r（跳到下一个不相等元素）</span><br><span class="line">                + 中间的元素已经相等，没必要扩散</span><br><span class="line">                    + 可能是1个、2个、3个，中间相等的元素（不管多少个）已经构成了回文串</span><br><span class="line">                + 只用从r和l的位置进行扩散就行！！！</span><br><span class="line">        + 原理：</span><br><span class="line">            + 核心：如果元素连续相等，变成一个拓展中心</span><br><span class="line">            + 可以省去间隙的拓展中心</span><br><span class="line">                + 因为每个都找右边第一个不相等的位置</span><br><span class="line">        + 代码</span><br><span class="line">            + 遍历数组</span><br><span class="line">                + 找到右边第一个不相等的位置r</span><br><span class="line">                    + while 判断</span><br><span class="line">                + 向左向右扩散</span><br><span class="line">                    + i -1、r</span><br><span class="line">                    + 循环双指针比较</span><br><span class="line">                + 拓展结束。计算长度，开始索引位置</span><br><span class="line"></span><br><span class="line">+ 马拉车算法</span><br><span class="line">    + 原理</span><br><span class="line">        + O(n)</span><br><span class="line">        + 预处理</span><br><span class="line">            + 头尾加特殊字符，元素之间加特殊字符</span><br><span class="line">        + m[i]</span><br><span class="line">            + 以i为拓展中心的最大回文子串的长度（不含#）</span><br><span class="line">            + 以i为拓展中心的最大回文子串的右半部分或左半部分的长度（包含#）</span><br><span class="line">        + 核心</span><br><span class="line">            + l、r、c：前一个回文串，li回文串对称位置，i当前位置</span><br><span class="line">            + 根据前面的回文串，进行对称，获取后面的回文串长度</span><br><span class="line">                + 根据对称性，前面的回文长度等于后面的长度</span><br><span class="line">                + 前提 i + m[i] &lt; r，不能超过对称范围</span><br><span class="line">                    + 超过对称范围，外面的元素不一定对称</span><br><span class="line">                    + 对称范围内的，若前半部分是回文，则后半部分是回文且相等的</span><br><span class="line">                        + 可以保证范围内的都对称，超出的不知道</span><br><span class="line">                    + 如果恰好 i + m[i] = r</span><br><span class="line">                        + 不一定等于前面的（最少情况），r右边的元素不知，也可能回文</span><br><span class="line">                        + 拓展中心法，继续比较</span><br><span class="line">            + 更新c、r、l等</span><br><span class="line">            + 维护max</span><br><span class="line">        + 总结：对称性质</span><br><span class="line">            + 对称范围内的，和对称的回文串长度相等</span><br><span class="line">            + 对称范围外的，需要拓展比较</span><br><span class="line">            + 四种情况</span><br><span class="line">                + i==r，拓展中心法</span><br><span class="line">                + i &lt; r</span><br><span class="line">                    + i + m[i] &lt; r，相等</span><br><span class="line">                    + i + m[i] = r，最少值，拓展计算</span><br><span class="line">                    + i + m[i] &gt; r，最少值，拓展计算</span><br><span class="line">    + 实现</span><br><span class="line">        + 预处理字符</span><br><span class="line">        + 遍历，从第一个元素到最后一个元素</span><br><span class="line">            + i==r</span><br><span class="line">            + i&lt;r，求出根据c求出li（对称）</span><br><span class="line">                + 直接赋值，至少是m[li]</span><br><span class="line">                + 拓展中心法</span><br><span class="line">                    + 双指针</span><br><span class="line">                + 更新c、r等</span><br><span class="line">            + 维护max：m[i]</span><br></pre></td></tr></table></figure><p>暴力</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171759900.png" alt="image-20220403171759900"></p><p>动态规划</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171835548.png" alt="image-20220403171835548"></p><p>拓展中心</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171805084.png" alt="image-20220403171805084"></p><p>拓展中心优化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171901259.png" alt="image-20220403171901259"></p><p>马拉车</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171915978.png" alt="image-20220403171915978"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171920775.png" alt="image-20220403171920775"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403171927194.png" alt="image-20220403171927194"></p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>47、72、5优化</p><p>1143、53、42、322、面试08.11</p><p>300、70、198、213、674、63、122、123、188、714</p><p>1235、943、516、376</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 三步</span><br><span class="line">+ 状态定义</span><br><span class="line">+ 初始值</span><br><span class="line">+ 状态转移方程</span><br><span class="line">+ 优化</span><br><span class="line">+ 一维——&gt;变量</span><br><span class="line">+ 二维——&gt;变量、数组</span><br><span class="line">+ 注意递推关系</span><br><span class="line">+ 后无效性、前推后</span><br><span class="line">+ 考虑所有情况，可以从前面推导来的情况</span><br><span class="line">+ 拓展中心法</span><br><span class="line">+ 拓展中心法优化</span><br><span class="line">+ 右边第一个不同元素</span><br><span class="line">+ 马拉车算法</span><br><span class="line">+ 回文串对称</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>绝大多数题目解决：</p><p>递归 + 遍历（前序、中序、后序、层次）</p><h2 id="236、二叉树的最近公共祖先"><a href="#236、二叉树的最近公共祖先" class="headerlink" title="236、二叉树的最近公共祖先"></a>236、二叉树的最近公共祖先</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172009431.png" alt="image-20220403172009431"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ 两个节点最近的公共祖先</span><br><span class="line">    + 可以为节点本身</span><br><span class="line">    + 递归实现</span><br><span class="line">        + 方法功能：查找以root为根节点的p、q的最近公共祖先</span><br><span class="line">        + 递归</span><br><span class="line">            + 去左子树为根节点找</span><br><span class="line">            + 去右子树为根节点找</span><br><span class="line">        + 结束条件</span><br><span class="line">            + 根节点为空，或者根节点为目标元素</span><br><span class="line">                + 直接返回根节点</span><br><span class="line">            + 错误</span><br><span class="line">                + 如果左子树找到</span><br><span class="line">                    + 返回左子树</span><br><span class="line">                + 如果右子树找到</span><br><span class="line">                    + 返回右子树</span><br><span class="line">                + 如果左右子树都找不到，说明p、q节点在两个子树</span><br><span class="line">                    + root节点即为公共祖先，直接返回root</span><br><span class="line">            + 分析递归方法</span><br><span class="line">                + 如果pq在两边，递归左右子树不能返回null</span><br><span class="line">                    + 只有一个节点，应该直接返回该节点</span><br><span class="line">                    + 两边同时找到，说明根节点为公共祖先</span><br><span class="line">                + 如果pq都存在，返回公共祖先</span><br><span class="line">            + 正确</span><br><span class="line">                + 左右子树都找到，返回root</span><br><span class="line">                + 左子树或右子树找到，返回找到的节点</span><br><span class="line">                + 都没找到，返回null</span><br><span class="line">+ 原理</span><br><span class="line">    + 向下找到节点就返回节点，找不到就返回null</span><br><span class="line">    + 如果左右都找到，返回root</span><br><span class="line">    + 如果找到一个，说明找到的是节点，继续向上返回</span><br><span class="line">    + 如果为父子节点，父节点返回，其他路没有节点返回，父节点为祖先，符合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172108264.png" alt="image-20220403172108264"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172113711.png" alt="image-20220403172113711"></p><h2 id="99、恢复二叉搜索树"><a href="#99、恢复二叉搜索树" class="headerlink" title="99、恢复二叉搜索树"></a>99、恢复二叉搜索树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172122402.png" alt="image-20220403172122402"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ 二叉搜素树</span><br><span class="line">    + 中序遍历升序</span><br><span class="line">+ 错误交换后</span><br><span class="line">    + 中序遍历，找到一个或两个逆序对</span><br><span class="line">+ 实现</span><br><span class="line">    + 递归中序遍历，找到错误节点</span><br><span class="line">        + 退出条件：root为空</span><br><span class="line">        + 递归左子树</span><br><span class="line">        + 比较当前节点和上次遍历节点大小是否逆序</span><br><span class="line">            + 准备两个指针标记错误节点</span><br><span class="line">        + 递归右子树</span><br><span class="line">    + 交换node</span><br><span class="line">        + 交换值</span><br><span class="line">+ 二叉树的Morris遍历</span><br><span class="line">    + 使用前驱节点连线，进行回溯</span><br><span class="line">    + 线索二叉树</span><br><span class="line">+ Morris中序遍历</span><br><span class="line">    + 动态线索二叉树</span><br><span class="line">    + 把原来栈里的指针存放在了node里面</span><br><span class="line">    + 实现</span><br><span class="line">        + 循环（node不为空）</span><br><span class="line">            + 若左子树不为空</span><br><span class="line">                + 找到前驱节点</span><br><span class="line">                    + 左子树最右边</span><br><span class="line">                + 判断前驱节点右指针</span><br><span class="line">                    + 为空（第一次）</span><br><span class="line">                        + 前驱节点指向当前node</span><br><span class="line">                        + 移动到左子树</span><br><span class="line">                    + 不为空（第二次来）</span><br><span class="line">                        + 打印当前节点，清空指针</span><br><span class="line">                        + 移动到右子树</span><br><span class="line">            + 若左子树为空</span><br><span class="line">                + 打印当前节点</span><br><span class="line">                + 移动到右子树</span><br><span class="line">+ Morris查找错误节点</span><br><span class="line">    + 把打印改成find</span><br><span class="line">+ Morris前序、中序、后序遍历</span><br><span class="line">    + 空间复杂度O(1)</span><br><span class="line">        + 动态线索树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172244094.png" alt="image-20220403172244094"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403172251620.png" alt="image-20220403172251620"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220403173035837.png" alt="image-20220403173035837"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——字节、美团、滴滴等面试题</title>
      <link href="/2022/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E8%8A%82%E3%80%81%E7%BE%8E%E5%9B%A2%E3%80%81%E6%BB%B4%E6%BB%B4%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/02/%E7%AE%97%E6%B3%95-%E5%AD%97%E8%8A%82%E3%80%81%E7%BE%8E%E5%9B%A2%E3%80%81%E6%BB%B4%E6%BB%B4%E7%AD%89%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数组-amp-排序"><a href="#数组-amp-排序" class="headerlink" title="数组&amp;排序"></a>数组&amp;排序</h1><h2 id="88、合并两个有序数组"><a href="#88、合并两个有序数组" class="headerlink" title="88、合并两个有序数组"></a>88、合并两个有序数组</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132218661.png" alt="image-20220402132218661"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 双指针 + 倒排</span><br><span class="line">    + while循环（条件：下面退出）</span><br><span class="line">        + 上指针未结束，且大于下指针</span><br><span class="line">        + 上指针结束（提前走完）或者小于下面指针</span><br><span class="line">+ 其他方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132335462.png" alt="image-20220402132335462"></p><h2 id="75、颜色分类"><a href="#75、颜色分类" class="headerlink" title="75、颜色分类"></a>75、颜色分类</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132349617.png" alt="image-20220402132349617"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 对数组排序（只包含0、1、2），原地排序（常数空间），一趟扫描</span><br><span class="line">+ sort ×</span><br><span class="line">+ 排序算法 ×</span><br><span class="line">+ 双、三指针（扫描一趟常用解法）</span><br><span class="line">    + 左边两个指针（放0、遍历扫描），右边一个指针（放2），判断左边元素</span><br><span class="line">    + 遍历（条件：扫描退出）</span><br><span class="line">        + 扫描到1跳过</span><br><span class="line">            + 扫描移动</span><br><span class="line">        + 扫描到0与左指针交换</span><br><span class="line">            + 左指针移动</span><br><span class="line">            + 扫描移动（交换来的值已经被扫描过，无需判断）</span><br><span class="line">        + 扫描到2与右指针交换</span><br><span class="line">            + 右指针移动</span><br><span class="line">            + 扫描再次判断（交换来的值未被判断过）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132456943.png" alt="image-20220402132456943"></p><h2 id="16、部分排序"><a href="#16、部分排序" class="headerlink" title="16、部分排序"></a>16、部分排序</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132511409.png" alt="image-20220402132511409"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ 找到中间未排序的区间（两边已排序）</span><br><span class="line">    + 寻找逆序对</span><br><span class="line">    + 找到最后一个逆序对</span><br><span class="line"></span><br><span class="line">+ 花时间思考值得</span><br><span class="line">    + 类似的问题就容易解决了</span><br><span class="line">    + 总结、思考</span><br><span class="line"></span><br><span class="line">+ 双指针</span><br><span class="line">    + 两边同时扫描</span><br><span class="line">        + 记录扫描过程的最大值</span><br><span class="line">            + 若比最大值小，则记录位置（逆序）</span><br><span class="line">            + 统计最大逆序位置</span><br><span class="line">        + 记录最左和最右的最大逆序位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132528787.png" alt="image-20220402132528787"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402132725332.png" alt="image-20220402132725332"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>977、164-hard</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>双指针（常用）</p><p>左右扫描</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="203、移除链表元素"><a href="#203、移除链表元素" class="headerlink" title="203、移除链表元素"></a>203、移除链表元素</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133042094.png" alt="image-20220402133042094"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 删除节点</span><br><span class="line">+ 想象成一个全新的链表</span><br><span class="line">    + 如果是要删除的，跳过</span><br><span class="line">    + 如果不是，连接节点</span><br><span class="line">+ 双指针 + 遍历一遍</span><br><span class="line">    + 一指针遍历，一指针指向尾节点</span><br><span class="line">        + 若为删除节点，尾节点不动（非尾部）</span><br><span class="line">        + 若为正常节点，尾节点指向当前</span><br><span class="line">+ 虚拟头结点</span><br><span class="line">    + 方便删除第一个节点</span><br><span class="line">    + 遍历将next作为头</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133048665.png" alt="image-20220402133048665"></p><h2 id="2、两数相加"><a href="#2、两数相加" class="headerlink" title="2、两数相加"></a>2、两数相加</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133107021.png" alt="image-20220402133107021"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 虚拟头结点</span><br><span class="line">+ 遍历 + 进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133120030.png" alt="image-20220402133120030"></p><h2 id="160、相交链表"><a href="#160、相交链表" class="headerlink" title="160、相交链表"></a>160、相交链表</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133130614.png" alt="image-20220402133130614"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 快慢指针？</span><br><span class="line">+ 拼接链表</span><br><span class="line">    + 方法</span><br><span class="line">        + 下一个为null时移动到另一个头结点</span><br><span class="line">    + 原理</span><br><span class="line">        + 两个链表长度相同</span><br><span class="line">        + 最后的节点必然相同——相交之处（开始相同的地方）</span><br><span class="line">+ 遍历（相同时结束）</span><br><span class="line">    + 走完时到另一个节点头部</span><br><span class="line">    + 结束时指向第一个相同位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133157555.png" alt="image-20220402133157555"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133206604.png" alt="image-20220402133206604"></p><h2 id="86、分隔链表"><a href="#86、分隔链表" class="headerlink" title="86、分隔链表"></a>86、分隔链表</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133222815.png" alt="image-20220402133222815"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 两个虚拟头结点lhead、rhead</span><br><span class="line">    + lhead</span><br><span class="line">        + 小于的串进来</span><br><span class="line">        + ltai指向末尾</span><br><span class="line">    + rhead</span><br><span class="line">        + 大于的串进来</span><br><span class="line">        + rtail指向末尾</span><br><span class="line">+ 配合last指针记录每条链表尾部</span><br><span class="line">+ 遍历链表head指针</span><br><span class="line">    + 判断值进行链表串接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133249278.png" alt="image-20220402133249278"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133300887.png" alt="image-20220402133300887"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133346850.png" alt="image-20220402133346850"></p><h2 id="234、回文联表"><a href="#234、回文联表" class="headerlink" title="234、回文联表"></a>234、回文联表</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133354186.png" alt="image-20220402133354186"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 1、链表反转</span><br><span class="line">    + 1、创建新链表翻转</span><br><span class="line">    + 2、后半部分原地翻转</span><br><span class="line">        + 两个链表头</span><br><span class="line">        + 双指针比较</span><br><span class="line">        + 移动到null结束</span><br><span class="line">+ 实现</span><br><span class="line">    + 找到中间节点（常用操作）</span><br><span class="line">        + 奇数-中间的</span><br><span class="line">        + 偶数-左边的</span><br><span class="line">        + 快慢指针</span><br><span class="line">            + 快指针一次两步，慢指针一次一步</span><br><span class="line">            + 快指针到头，慢指针到中间节点</span><br><span class="line">    + 翻转链表（常用操作）</span><br><span class="line">        + 指针逆序</span><br><span class="line">    + 双指针遍历比较</span><br><span class="line">    + 若需不改变原结构</span><br><span class="line">        + 再次翻转</span><br><span class="line">+ 这些基本操作100%快速手写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133431358.png" alt="image-20220402133431358"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133439442.png" alt="image-20220402133439442"></p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>138、708、237、141、206、21、23</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 99%题目画图</span><br><span class="line">+ 虚拟头结点</span><br><span class="line">+ 快慢指针</span><br><span class="line">+ 求中心节点</span><br><span class="line">+ 判断环</span><br><span class="line">+ 多指针</span><br><span class="line">+ 链表翻转</span><br></pre></td></tr></table></figure><h1 id="栈-amp-队列"><a href="#栈-amp-队列" class="headerlink" title="栈&amp;队列"></a>栈&amp;队列</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133800668.png" alt="image-20220402133800668"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 栈</span><br><span class="line">    + 解决问题：对称</span><br><span class="line">        + 回文链表</span><br><span class="line">            + 前面半部分入栈</span><br><span class="line">            + 后面半部分出栈判断是否相等</span><br><span class="line">        + 有效的括号</span><br><span class="line">            + 左右括号对称</span><br><span class="line">+ 队列</span><br><span class="line">    + 解决问题：顺序</span><br><span class="line">+ 双端队列</span><br><span class="line">    + 头尾都可添加、删除元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133845463.png" alt="image-20220402133845463"></p><h2 id="155、最小栈"><a href="#155、最小栈" class="headerlink" title="155、最小栈"></a>155、最小栈</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133857251.png" alt="image-20220402133857251"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 获取栈中最小元素</span><br><span class="line">    + 要求常数时间</span><br><span class="line">    + 空间换时间</span><br><span class="line">+ 1、两个栈</span><br><span class="line">    + 正常栈、最小栈（只存放当前及以下层最小数据）</span><br><span class="line">    + 两个栈同步 入栈、出栈</span><br><span class="line">        + 最小栈入栈只放最小值</span><br><span class="line">+ 核心思想</span><br><span class="line">    + push的时候知道当前栈的最小值</span><br><span class="line">    + 维护一个最小值</span><br><span class="line">+ 优化</span><br><span class="line">    + 链表</span><br><span class="line">        + head节点始终保存最小值</span><br><span class="line">        + 头插法</span><br><span class="line">    + 实现</span><br><span class="line">        + 创建node类</span><br><span class="line">            + 保存当前值和最小值</span><br><span class="line">        + 初始化创建虚拟头结点</span><br><span class="line">            + 值为最大</span><br><span class="line">        + push</span><br><span class="line">            + 维护当前值和最小值（比较head）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402133938307.png" alt="image-20220402133938307"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134001226.png" alt="image-20220402134001226"></p><h2 id="239、滑动窗口最大值"><a href="#239、滑动窗口最大值" class="headerlink" title="239、滑动窗口最大值"></a>239、滑动窗口最大值</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134021286.png" alt="image-20220402134021286"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">+ 为什么想不到方法？</span><br><span class="line">    + 做的题太少！！！</span><br><span class="line">    + 刷题</span><br><span class="line">    + 套路总结</span><br><span class="line">    </span><br><span class="line">+ 1:暴力</span><br><span class="line">    + 遍历，每次往后找k个元素</span><br><span class="line">+ 2:动态规划</span><br><span class="line"></span><br><span class="line">+ 3:双端队列</span><br><span class="line">    + 准备</span><br><span class="line">        + i指向滑动窗口最后一个元素</span><br><span class="line">        + w指向第一个元素</span><br><span class="line">        + node</span><br><span class="line">            + 索引和对应的值</span><br><span class="line">    + 实现</span><br><span class="line">        + 从队尾入队，前面小的都移除</span><br><span class="line">            + 队列中头元素最大</span><br><span class="line">        + 当w合法时，获取队列头元素（滑动窗口最大值）</span><br><span class="line">        + 移动后，判断队列头部元素索引是否有效</span><br><span class="line">        + 队列按索引、从大到小排列</span><br><span class="line">            + 只需遍历一遍O(n)</span><br><span class="line">    + 原理</span><br><span class="line">        + 索引判断节点位置，是否在滑动窗口</span><br><span class="line">        + 值进行大小比较，前面永远是滑动窗口最大值</span><br><span class="line">+ 思考每一步都是为了什么？</span><br><span class="line">    + 为什么这么做</span><br><span class="line">+ 必须要弄明白原理</span><br><span class="line">+ 双端队列（linkedlist双向链表）</span><br><span class="line">    + 遍历数组</span><br><span class="line">        + while判断队头元素和当前元素</span><br><span class="line">            + 删除全部比当前元素小的</span><br><span class="line">        + 将i加入队尾</span><br><span class="line">        + 检查窗口的索引是否合法</span><br><span class="line">            + 最后k-1个元素结束遍历</span><br><span class="line">        + 检查队头索引是否合法</span><br><span class="line">            + 不合法移除</span><br><span class="line">            + 最多只需删掉一个（每次移动都会删除）</span><br><span class="line">        + 设置窗口的最大值</span><br><span class="line">        + 队头元素设置到最大值数组中</span><br><span class="line">    + 为什么使用双端队列？</span><br><span class="line">        + 单调队列</span><br><span class="line">            + 递减</span><br><span class="line">        + 整体目的</span><br><span class="line">            + 一次遍历找到滑动窗口最值</span><br><span class="line">            + 找到最值：保证对头元素是当前滑动窗口的最大值</span><br><span class="line">                + 大的元素往前靠</span><br><span class="line">                + 小的元素没有意义</span><br><span class="line">                + 队列单调</span><br><span class="line">                </span><br><span class="line">+ 4:双指针</span><br><span class="line">    + 实现</span><br><span class="line">        + 先扫描前k个元素找到最值的索引</span><br><span class="line">        + 遍历数组</span><br><span class="line">            + 每次移动，维护最大值索引</span><br><span class="line">                + 若最值索引在滑动窗口内</span><br><span class="line">                    + 若最后元素大于最大值索引，设为最值</span><br><span class="line">                    + 若最后元素不大于，继续</span><br><span class="line">                + 若不在窗口内，则重新扫描k个窗口元素，找到最值，更新最大值索引</span><br><span class="line">            + 设置最大值索引为窗口最值</span><br><span class="line">    + 性能</span><br><span class="line">        + 对于递减数列，需要不断重新扫描最值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134322988.png" alt="image-20220402134322988"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134342003.png" alt="image-20220402134342003"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134406537.png" alt="image-20220402134406537"></p><h2 id="654、最大二叉树"><a href="#654、最大二叉树" class="headerlink" title="654、最大二叉树"></a>654、最大二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134420556.png" alt="image-20220402134420556"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ 先找最值</span><br><span class="line">    + 左边元素：左子树构建最大二叉树</span><br><span class="line">    + 右边元素：右子树构件最大二叉树</span><br><span class="line">+ 递归</span><br><span class="line">    + 找到指定范围中的根节点（最大值node）</span><br><span class="line">        + 结束条件：范围左右重合，直接返回</span><br><span class="line">            + 创建节点</span><br><span class="line">                + 遍历扫描</span><br><span class="line">                    + 找到最值的索引i</span><br><span class="line">        + 左子树递归找到根节点（left，i）</span><br><span class="line">        + 右子树递归找到根节点（i，right）</span><br><span class="line">        </span><br><span class="line">+ 变种题目</span><br><span class="line">+ 返回父节点索引数组</span><br><span class="line">+ 每个元素，两边找（都有可能）</span><br><span class="line">    + 往右找第一个比当前元素大的为父节点</span><br><span class="line">        + 当前为左子树</span><br><span class="line">    + 往左找第一个比当前元素大的为父节点</span><br><span class="line">        + 当前为右子树</span><br><span class="line">    + 取小的那个父节点</span><br><span class="line">        + 大的是上层的</span><br><span class="line"></span><br><span class="line">+ 单调栈</span><br><span class="line">    + 暴力，每个位置扫两遍</span><br><span class="line">    + 栈，扫描一遍</span><br><span class="line">    + 用栈求左、右边第一个比它大的数</span><br><span class="line">        + 实现</span><br><span class="line">            + 栈从下往上，维护单调递减</span><br><span class="line">            + 扫描元素</span><br><span class="line">                + 判断栈顶元素是否大于当前</span><br><span class="line">                    + 小于栈顶，入栈</span><br><span class="line">                        + 栈顶元素为当前元素的左边第一个比它大的数</span><br><span class="line">                    + 大于栈顶，弹出栈顶元素</span><br><span class="line">                        + 当前元素设置为栈顶元素的右边第一个比它大的数</span><br><span class="line">                        + 小的元素全部出栈</span><br><span class="line">                        + 保证大的入栈</span><br><span class="line">        + 原理</span><br><span class="line">            + 能push进去，下面的元素比它大</span><br><span class="line">            + 能pop出去，即将push的元素比它大</span><br><span class="line"></span><br><span class="line">+ 反过来求？</span><br><span class="line">    + 左小，右小</span><br><span class="line"></span><br><span class="line">+ 实现</span><br><span class="line">    + 准备</span><br><span class="line">        + 栈、两个数组（左大右大）</span><br><span class="line">    + 扫描元素，维护两个数组</span><br><span class="line">        + 栈顶小，循环弹出</span><br><span class="line">            + 设置栈顶右大为当前元素</span><br><span class="line">        + 栈顶大，入栈</span><br><span class="line">            + 设置栈顶为当前元素左大</span><br><span class="line">            + 若栈顶为空，不设置</span><br><span class="line">    + 设置父节点索引</span><br><span class="line">        + 比较两个数组，找出最小的作为父节点</span><br><span class="line">+ 两个for循环跟一个一样</span><br><span class="line">+ 执行的东西一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134743050.png" alt="image-20220402134743050"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134753678.png" alt="image-20220402134753678"></p><h2 id="739、每日温度"><a href="#739、每日温度" class="headerlink" title="739、每日温度"></a>739、每日温度</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402134834567.png" alt="image-20220402134834567"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ 找到下次升温天数（和右大索引距离）</span><br><span class="line">+ 直接复制过来，单调栈</span><br><span class="line">    + 只记录右大</span><br><span class="line">    + 设置结果为 右大索引-当前索引</span><br><span class="line">+ 倒推法</span><br><span class="line">+ 思路</span><br><span class="line">        + 从右往左遍历元素</span><br><span class="line">        + 类似动态规划</span><br><span class="line">            + 如果j&gt;i的值</span><br><span class="line">                + j是右大</span><br><span class="line">            + 如果j&lt;i的值</span><br><span class="line">                + 寻找j的右大继续判断</span><br><span class="line">                    + 找到j的右大作为新值</span><br><span class="line">                        + 找到j对应升温的天数</span><br><span class="line">                    + 如果仍然小，则继续移动，重新进入判断</span><br><span class="line">                    + 若找不到，则设为0</span><br><span class="line">            + 如果j=i的值</span><br><span class="line">                + 同样寻找j的右大</span><br><span class="line">    + 实现</span><br><span class="line">        + 倒序遍历数组</span><br><span class="line">            + 循环（true）：必然会结束</span><br><span class="line">                + 如果j比当前元素大的</span><br><span class="line">                    + j设为当前元素右大</span><br><span class="line">                    + 结束循环</span><br><span class="line">                + 如果不存在右大</span><br><span class="line">                    + 设为0</span><br><span class="line">                    + 结束循环</span><br><span class="line">                + 如果j与当前元素相等</span><br><span class="line">                    + 找到j的右大就是当前元素的右大</span><br><span class="line">                    + 结束循环</span><br><span class="line">                + 如果j小于当前元素</span><br><span class="line">                    + j的右大作为新j</span><br><span class="line">                    + 继续循环</span><br><span class="line">    + 原理</span><br><span class="line">        + 动态规划的思想</span><br><span class="line">        + 从后往前推</span><br><span class="line">            + 前面的值依靠后面的值进行计算</span><br><span class="line">    + 代码简化</span><br><span class="line">        + 等于情况和小于情况合并</span><br><span class="line">            + 等于也要找后面的元素，小于也要找后面的元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220402135055695.png" alt="image-20220402135055695"></p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p>42接雨水、232…</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 单调栈</span><br><span class="line">    + 求左大右大</span><br><span class="line">+ 双端队列、单调队列</span><br><span class="line">    + 滑动窗口最值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——跳表、B+树</title>
      <link href="/2022/03/30/%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E3%80%81B+%E6%A0%91/"/>
      <url>/2022/03/30/%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8%E3%80%81B+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>有序链表搜索、添加、删除</p><ul><li>时间复杂度较高</li><li>二分搜索无法应用</li></ul><p>需要搜索、添加、删除快速的数据结构！！</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330225401357.png" alt="image-20220330225401357"></p><h2 id="跳表-1"><a href="#跳表-1" class="headerlink" title="跳表"></a>跳表</h2><p>相比较于红黑树</p><ul><li>实现、维护更加简单</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330225513786.png" alt="image-20220330225513786"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330225733600.png" alt="image-20220330225733600"></p><p>跳表：增加多层快速路线</p><p>一个node有多层</p><ul><li>每层每层都有一个指针</li><li>最下层指向下一个节点</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> P = <span class="number">0.25</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Comparator&lt;K&gt; comparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有效层数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不存放任何K-V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">(Comparator&lt;K&gt; comparator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">first = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, MAX_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// first.nexts[3] == 21节点</span></span><br><span class="line"><span class="comment">// first.nexts[2] == 9节点</span></span><br><span class="line"><span class="comment">// first.nexts[1] == 6节点</span></span><br><span class="line"><span class="comment">// first.nexts[0] == 3节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key = 30</span></span><br><span class="line"><span class="comment">// level = 4</span></span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node.nexts[i].key &gt;= key</span></span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node.nexts[i].value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line">Node&lt;K, V&gt;[] prevs = <span class="keyword">new</span> Node[level];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123; <span class="comment">// 节点是存在的</span></span><br><span class="line">V oldV = node.nexts[i].value;</span><br><span class="line">node.nexts[i].value = value;</span><br><span class="line"><span class="keyword">return</span> oldV;</span><br><span class="line">&#125;</span><br><span class="line">prevs[i] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新节点的层数</span></span><br><span class="line"><span class="keyword">int</span> newLevel = randomLevel();</span><br><span class="line"><span class="comment">// 添加新节点</span></span><br><span class="line">Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value, newLevel);</span><br><span class="line"><span class="comment">// 设置前驱和后继</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newLevel; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= level) &#123;</span><br><span class="line">first.nexts[i] = newNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">newNode.nexts[i] = prevs[i].nexts[i];</span><br><span class="line">prevs[i].nexts[i] = newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点数量增加</span></span><br><span class="line">size++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算跳表的最终层数</span></span><br><span class="line">level = Math.max(level, newLevel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">keyCheck(key);</span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line">Node&lt;K, V&gt;[] prevs = <span class="keyword">new</span> Node[level];</span><br><span class="line"><span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> cmp = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line">prevs[i] = node;</span><br><span class="line"><span class="keyword">if</span> (cmp == <span class="number">0</span>) exist = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!exist) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要被删除的节点</span></span><br><span class="line">Node&lt;K, V&gt; removedNode = node.nexts[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量减少</span></span><br><span class="line">size--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置后继</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; removedNode.nexts.length; i++) &#123;</span><br><span class="line">prevs[i].nexts[i] = removedNode.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新跳表的层数</span></span><br><span class="line"><span class="keyword">int</span> newLevel = level;</span><br><span class="line"><span class="keyword">while</span> (--newLevel &gt;= <span class="number">0</span> &amp;&amp; first.nexts[newLevel] == <span class="keyword">null</span>) &#123;</span><br><span class="line">level = newLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> removedNode.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (Math.random() &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keyCheck</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;key must not be null.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(K k1, K k2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> comparator != <span class="keyword">null</span> </span><br><span class="line">? comparator.compare(k1, k2)</span><br><span class="line">: ((Comparable&lt;K&gt;)k1).compareTo(k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K, V&gt;[] nexts;</span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; right;</span></span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; down;</span></span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; top;</span></span><br><span class="line"><span class="comment">//Node&lt;K, V&gt; left;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">nexts = <span class="keyword">new</span> Node[level];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> key + <span class="string">&quot;:&quot;</span> + value + <span class="string">&quot;_&quot;</span> + nexts.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">&quot;一共&quot;</span> + level + <span class="string">&quot;层&quot;</span>).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">Node&lt;K, V&gt; node = first;</span><br><span class="line"><span class="keyword">while</span> (node.nexts[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(node.nexts[i]);</span><br><span class="line">sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">node = node.nexts[i];</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ 跳表</span><br><span class="line">    + 初始化</span><br><span class="line">        + node&lt;K,V&gt;：k、v、next[32]（最高）</span><br><span class="line">        + k：comparable</span><br><span class="line">        + head首节点</span><br><span class="line">            + 当前next[]有效层数</span><br><span class="line">    + get（查找）</span><br><span class="line">    + 顶层开始，每一层</span><br><span class="line">            + 找到大于目标元素为止！！！</span><br><span class="line">            + 退回到前一个元素</span><br><span class="line">                + 转到下一层</span><br><span class="line">            + 若node值相等，则返回</span><br><span class="line">    + put（添加）</span><br><span class="line">        + 查找前驱节点（插入位置）</span><br><span class="line">        + 创建新节点</span><br><span class="line">            + 设置层数</span><br><span class="line">                + 随机、抛硬币</span><br><span class="line">            + 每层指针修改</span><br><span class="line">                + 查找每层前驱节点</span><br><span class="line">                    + 每个往下走一层的节点！！！（与后面没有其他元素）</span><br><span class="line">                + 每层插入节点指向前驱的后继</span><br><span class="line">                + 每层的前驱指向插入节点</span><br><span class="line">            + 特殊情况（节点高度比全部都高！！！）</span><br><span class="line">                + 首节点响应层数指向插入节点</span><br><span class="line">                + 修改跳表高度</span><br><span class="line">    + remove（删除）</span><br><span class="line">        + 查找每层前驱节点</span><br><span class="line">            + 一直找到最后一层（保证找到每层前驱）</span><br><span class="line">        + 设置前驱节点指向删除节点的后继</span><br></pre></td></tr></table></figure><h2 id="跳表的层数"><a href="#跳表的层数" class="headerlink" title="跳表的层数"></a>跳表的层数</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230137119.png" alt="image-20220330230137119"></p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>b树的变体</p><p>b树：</p><ul><li><strong>平衡多路搜索树</strong></li><li>n阶，n个分叉，n-1个节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230448597.png" alt="image-20220330230448597"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230501240.png" alt="image-20220330230501240"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ b+树</span><br><span class="line">    + 分为内部节点和叶子节点</span><br><span class="line">        + 内部节点只存储key，不存储数据</span><br><span class="line">        + 叶子节点存储key和具体数据</span><br><span class="line">    + 所有叶子节点形成一条有序链表！！！</span><br></pre></td></tr></table></figure><h2 id="磁盘IO流程"><a href="#磁盘IO流程" class="headerlink" title="磁盘IO流程"></a>磁盘IO流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ 硬盘的分类</span><br><span class="line">    + 固态硬盘</span><br><span class="line">    + 机械硬盘</span><br><span class="line">        + 多个盘片</span><br><span class="line">            + 两个盘面（每个盘片）</span><br><span class="line">                + 一个读写磁头（每个盘面）</span><br><span class="line">                + 磁道（盘面中灰色圆环）</span><br><span class="line">                    + 扇区（每条磁道上的一个弧段）</span><br><span class="line">                        + 磁盘的最小读写单位</span><br><span class="line">                        + 通常512字节、4096字节</span><br><span class="line">                    + 扇区数相同</span><br><span class="line">                    + 外圈扇区面积大，记录数据密度小，浪费空间</span><br><span class="line">        + 存储容量计算</span><br><span class="line">        + 柱面（相同编号的磁道的圆柱）</span><br><span class="line">        + 磁盘块</span><br><span class="line">            + 操作系统最小读写单位（相邻多个扇区的组合）</span><br><span class="line">            + 一般4096字节</span><br><span class="line">            + 操作系统虚拟概念</span><br><span class="line">    + 查看硬盘信息</span><br><span class="line">+ 操作系统读取磁盘数据过程</span><br><span class="line">    + 操作系统将LBA（逻辑块地址：设备、磁头、磁道、扇区）传送给磁盘驱动器并启动读取命令</span><br><span class="line">    + 磁盘驱动器将磁头移动到正确的磁道，盘片开始旋转，将目标扇区旋转到磁头下</span><br><span class="line">    + 磁盘控制器将扇区数据等信息传送到一个处于磁盘界面的缓冲区</span><br><span class="line">    + 磁盘驱动器向操作系统发出“数据就绪”的信号</span><br><span class="line">    + 操作系统从磁盘界面的缓冲区读取数据</span><br><span class="line">+ 磁盘IO时间</span><br><span class="line">    + 寻道时间</span><br><span class="line">        + 操作系统软件层面可以优化</span><br><span class="line">        + 合理安排磁头移动，磁盘调度算法！！！</span><br><span class="line">    + 旋转延迟时间</span><br><span class="line">    + 数据传输时间</span><br></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>对比b树的优势：</p><ul><li>每个节点存储的key数量更多，树的高度更低！！！</li><li>所有具体数据都存储在叶子节点上，所以每次查询都要查到叶子节点，查询速度比较稳定</li><li>所有的叶子节点构成了一个有序链表，做区间查询时比较方便</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>给内部节点增加了指向兄弟节点的指针</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330230746979.png" alt="image-20220330230746979"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——并查集、布隆过滤器</title>
      <link href="/2022/03/29/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2022/03/29/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>设计一个数据结构，能够快速执行2个操作</p><p>1、查询</p><p>2、连接</p><p>数组、链表、平衡二叉树、集合（Set）？</p><p>查询、连接的时间复杂度都是：O(n) </p><h2 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h2><p>并查集也叫作不相交集合（Disjoint Set）</p><p>并查集有2个核心操作 </p><ul><li><p>查找（Find）：查找元素所在的集合（这里的集合并不是特指Set这种数据结构，是指广义的数据集合） </p></li><li><p>合并（Union）：将两个元素所在的集合合并为一个集合</p></li></ul><p>有2种常见的实现思路：</p><p>Quick Find </p><ul><li><p>查找（Find）的时间复杂度：O(1) </p></li><li><p>合并（Union）的时间复杂度：O(n)</p></li></ul><p>Quick Union </p><ul><li><p>查找（Find）的时间复杂度：O(logn)，可以优化至 O （𝛼 （𝑛）） ，α(𝑛) &lt; 5 </p></li><li><p>合并（Union）的时间复杂度：O(logn)，可以优化至 O （𝛼 （n）） ，α(𝑛) &lt; 5</p></li></ul><p>如何存储数据：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121343572.png" alt="image-20220330121343572"></p><p>可以用数组实现的树形结构</p><h2 id="Quick-find"><a href="#Quick-find" class="headerlink" title="Quick find"></a>Quick find</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121553568.png" alt="image-20220330121553568"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121559153.png" alt="image-20220330121559153"></p><p>连接节点</p><ul><li>树的高度最多是2</li></ul><p>查找节点</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330121814330.png" alt="image-20220330121814330"></p><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ 准备</span><br><span class="line">    + 父节点数组</span><br><span class="line">    + 初始化</span><br><span class="line">        + 每个节点单独一个集合（父节点为本身！！！）</span><br><span class="line">+ find查找所属的集合（根节点）</span><br><span class="line">    + 参数校验！！！</span><br><span class="line">    + 直接返回查找元素的父节点</span><br><span class="line">+ issame（查找是否同一集合）</span><br><span class="line">    + 判断父节点是否相等！！</span><br><span class="line">+ union（合并节点所属的集合！！）</span><br><span class="line">    + 参数校验（若已经是同一集合，直接返回）</span><br><span class="line">    + 遍历数组（查找父节点）！！！</span><br><span class="line">        + 将所有父节点为p1的改为父节点为p2！！（包括p1节点本身）</span><br><span class="line">+ 时间效率</span><br><span class="line">Find O(1)</span><br><span class="line">Union O(n)</span><br></pre></td></tr></table></figure><h2 id="Quick-union"><a href="#Quick-union" class="headerlink" title="Quick union"></a>Quick union</h2><p>时间效率：都是logn</p><p>连接原理：找到最根的节点进行连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ Union（node1，node2）</span><br><span class="line">    + （左边根节点）跟随（右边根节点）！！！</span><br><span class="line">        + 将v1的根节点嫁接到v2的根节点上</span><br><span class="line">    + 找到两个节点的根节点</span><br><span class="line">    + 根节点1父节点指向根节点2</span><br><span class="line"></span><br><span class="line">+ Find（找到集合根节点）</span><br><span class="line">    + 参数校验</span><br><span class="line">    + 向上循环查找即可（while）</span><br></pre></td></tr></table></figure><p>优化（基于quick union）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ 树不平衡、甚至链表情况</span><br><span class="line"></span><br><span class="line">+ 优化方案</span><br><span class="line">    + 1、基于size的优化</span><br><span class="line">        + 元素少的数 嫁接到 元素多的树！！！</span><br><span class="line">    + 2、基于rank的优化</span><br><span class="line">        + 矮的数 嫁接到 高的树！！！</span><br><span class="line"></span><br><span class="line">+ 基于size的优化</span><br><span class="line">    + 初始化</span><br><span class="line">        + size为1</span><br><span class="line">    + union</span><br><span class="line">        + 连接时判断根节点size</span><br><span class="line">            + size小的连接到size大的下面</span><br><span class="line">        + 修改size！！！</span><br><span class="line">            + 大的根节点size相应增加</span><br><span class="line">    + 问题</span><br><span class="line">        + 树不平衡无法解决</span><br><span class="line"></span><br><span class="line">+ 基于rank的优化！！！</span><br><span class="line">    + 初始化</span><br><span class="line">        + 每个集合rank（高度）为1</span><br><span class="line">        + 在union时修改即可</span><br><span class="line">    + union</span><br><span class="line">        + 连接时判断根节点rank</span><br><span class="line">            + rank小的根节点连接到rank大的下面</span><br><span class="line">            + rank相等时！！！</span><br><span class="line">                + 左边嫁接到右边</span><br><span class="line">                + 修改rank（其他情况下嫁接后rank不变）</span><br><span class="line">                    + 右边的rank+1即可！！</span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 树的高度越来越高</span><br><span class="line">    + find效率变慢</span><br><span class="line"></span><br><span class="line">+ find时路径上的所有节点都指向根节点</span><br><span class="line">    + 降低树的高度</span><br><span class="line">    + 查找越多，越接近2层</span><br><span class="line">    + union、find时效率提升</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122034632.png" alt="image-20220330122034632"></p><p>find实现（每个节点指向其祖父）</p><ul><li>保存父节点继续循环</li></ul><h2 id="路径分裂"><a href="#路径分裂" class="headerlink" title="路径分裂"></a>路径分裂</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122107739.png" alt="image-20220330122107739"></p><h2 id="路径减半"><a href="#路径减半" class="headerlink" title="路径减半"></a>路径减半</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122117242.png" alt="image-20220330122117242"></p><p>find（路径减半）</p><ul><li>保存祖父，继续循环（跳过父节点）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122131976.png" alt="image-20220330122131976"></p><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>实现</p><p>1、hash计算</p><p>2、链表+映射（map）</p><ul><li>node(value、parent、rank)</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Quick Union - 基于rank的优化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind_QU_R</span> <span class="keyword">extends</span> <span class="title">UnionFind_QU</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] ranks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind_QU_R</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(capacity);</span><br><span class="line"></span><br><span class="line">ranks = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ranks.length; i++) &#123;</span><br><span class="line">ranks[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p1 = find(v1);</span><br><span class="line"><span class="keyword">int</span> p2 = find(v2);</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ranks[p1] &lt; ranks[p2]) &#123;</span><br><span class="line">parents[p1] = p2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[p1] &gt; ranks[p2]) &#123;</span><br><span class="line">parents[p2] = p1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parents[p1] = p2;</span><br><span class="line">ranks[p2] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quick Union - 基于rank的优化 - 路径压缩(Path Compression)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPC</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// v == 1, parents[v] == 2</span></span><br><span class="line">rangeCheck(v);</span><br><span class="line"><span class="keyword">if</span> (parents[v] != v) &#123;</span><br><span class="line">parents[v] = find(parents[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parents[v];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quick Union - 基于rank的优化 - 路径减半(Path Halving)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPH</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">rangeCheck(v);</span><br><span class="line"><span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line">parents[v] = parents[parents[v]];</span><br><span class="line">v = parents[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quick Union - 基于rank的优化 - 路径分裂(Path Spliting)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; </span><br><span class="line">rangeCheck(v);</span><br><span class="line"><span class="keyword">while</span> (v != parents[v]) &#123;</span><br><span class="line"><span class="keyword">int</span> p = parents[v];</span><br><span class="line">parents[v] = parents[parents[v]];</span><br><span class="line">v = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">搭配建议：</span><br><span class="line"></span><br><span class="line">1、Quick Union</span><br><span class="line"></span><br><span class="line">2、基于 rank 的优化</span><br><span class="line"></span><br><span class="line">3、Path Halving 或 Path Spliting</span><br></pre></td></tr></table></figure><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h2><p>如果要经常判断 1 个元素是否存在，你会怎么做？</p><p>1、很容易想到使用哈希表（HashSet、HashMap），将元素作为 key 去查找</p><p>时间复杂度：O(1)，但是空间利用率不高，需要占用比较多的内存资源</p><p>2、是否存在时间复杂度低、占用内存较少的方案？</p><p>布隆过滤器（Bloom Filter）</p><h2 id="布隆过滤器-1"><a href="#布隆过滤器-1" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>1970年由布隆提出</p><ul><li>它是一个空间效率高的概率型数据结构，可以用来告诉你：一个元素一定不存在或者可能存在</li><li><strong>二进制向量 + hash函数组成</strong></li></ul><p>优缺点</p><ul><li><p>优点：空间效率和查询时间都远远超过一般的算法</p></li><li><p>缺点：有一定的误判率、删除困难</p></li></ul><p>它实质上是一个很长的二进制向量和一系列随机映射函数（Hash函数）</p><p>常见应用：</p><p>网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统、解决缓存穿透问题</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122743580.png" alt="image-20220330122743580"></p><p><strong>二进制向量 + hash函数组成</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 查找元素是否存在</span><br><span class="line">    + 全部哈希函数索引有一个不为1，不存在 √</span><br><span class="line">    + 全部哈希函数都为1，存在（有一定概率不存在）</span><br><span class="line"></span><br><span class="line">+ 索引：二进制</span><br><span class="line">+ 降低误判率：减少哈希冲突</span><br><span class="line">    + 数组加长</span><br><span class="line">    + hash函数增加</span><br></pre></td></tr></table></figure><p>误判率计算</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220330122812353.png" alt="image-20220330122812353"></p><p>根据误判率、数据规模</p><ul><li>推导二进制位、hash函数个数</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>Guava: Google Core Libraries For Java</p><p><a href="https://mvnrepository.com/artifact/com.google.guava/guava">https://mvnrepository.com/artifact/com.google.guava/guava</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制向量的长度(一共有多少个二进制位)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> bitSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] bits;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希函数的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数据规模</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 误判率, 取值范围(0, 1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span> || p &lt;= <span class="number">0</span> || p &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;wrong n or p&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ln2 = Math.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 求出二进制向量的长度</span></span><br><span class="line">bitSize = (<span class="keyword">int</span>) (- (n * Math.log(p)) / (ln2 * ln2));</span><br><span class="line"><span class="comment">// 求出哈希函数的个数</span></span><br><span class="line">hashSize = (<span class="keyword">int</span>) (bitSize * ln2 / n);</span><br><span class="line"><span class="comment">// bits数组的长度</span></span><br><span class="line">bits = <span class="keyword">new</span> <span class="keyword">long</span>[(bitSize + Long.SIZE - <span class="number">1</span>) / Long.SIZE];</span><br><span class="line"><span class="comment">// 每一页显示100条数据, pageSize</span></span><br><span class="line"><span class="comment">// 一共有999999条数据, n</span></span><br><span class="line"><span class="comment">// 请问有多少页 pageCount = (n + pageSize - 1) / pageSize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">nullCheck(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用value生成2个整数</span></span><br><span class="line"><span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line"><span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line"><span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">combinedHash = ~combinedHash;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 生成一个二进位的索引</span></span><br><span class="line"><span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line"><span class="comment">// 设置index位置的二进位为1</span></span><br><span class="line"><span class="keyword">if</span> (set(index)) result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   101010101010010101</span></span><br><span class="line"><span class="comment">// | 000000000000000100   1 &lt;&lt; index</span></span><br><span class="line"><span class="comment">//   101010111010010101</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一个元素是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">nullCheck(value);</span><br><span class="line"><span class="comment">// 利用value生成2个整数</span></span><br><span class="line"><span class="keyword">int</span> hash1 = value.hashCode();</span><br><span class="line"><span class="keyword">int</span> hash2 = hash1 &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hashSize; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line"><span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">combinedHash = ~combinedHash;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 生成一个二进位的索引</span></span><br><span class="line"><span class="keyword">int</span> index = combinedHash % bitSize;</span><br><span class="line"><span class="comment">// 查询index位置的二进位是否为0</span></span><br><span class="line"><span class="keyword">if</span> (!get(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置index位置的二进位为1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line"><span class="keyword">int</span> bitValue = <span class="number">1</span> &lt;&lt; (index % Long.SIZE);</span><br><span class="line">bits[index / Long.SIZE] = value | bitValue;</span><br><span class="line"><span class="keyword">return</span> (value &amp; bitValue) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看index位置的二进位的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true代表1, false代表0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> value = bits[index / Long.SIZE];</span><br><span class="line"><span class="keyword">return</span> (value &amp; (<span class="number">1</span> &lt;&lt; (index % Long.SIZE))) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nullCheck</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Value must not be null.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ 不提供删除功能（保证查询高效）</span><br><span class="line"></span><br><span class="line">+ 布隆过滤器</span><br><span class="line">    + 构造</span><br><span class="line">        + 利用long[]作为二进制向量</span><br><span class="line">        + 求出二进制位数、hash函数个数</span><br><span class="line">        + 根据数据规模、误判率</span><br><span class="line">+ 添加元素</span><br><span class="line">        + 原始</span><br><span class="line">            + hashcode()得到元素的hash值</span><br><span class="line">            + hash函数计算生成索引</span><br><span class="line">        + 采用谷歌的实现</span><br><span class="line">            + 生成哈希，并将索引设为1</span><br><span class="line">    + 判断元素是否存在</span><br><span class="line">        + 查询哈希的index是否为1</span><br><span class="line">            + 若有0，则返回false</span><br><span class="line">+ 设置指定索引为1！！！</span><br><span class="line">    + 找到long数组对应的位置</span><br><span class="line">    + 按位或</span><br><span class="line">+ 查看index位置的二进制值！！！</span><br><span class="line">    + 找到long数组对应的位置</span><br><span class="line">    + 按位与</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——读写锁原理&amp;乐观读锁&amp;CHM原理&amp;阻塞队列原理</title>
      <link href="/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86&amp;%E4%B9%90%E8%A7%82%E8%AF%BB%E9%94%81&amp;CHM%E5%8E%9F%E7%90%86&amp;%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86&amp;%E4%B9%90%E8%A7%82%E8%AF%BB%E9%94%81&amp;CHM%E5%8E%9F%E7%90%86&amp;%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ReentrantReadWriteLock原理"><a href="#ReentrantReadWriteLock原理" class="headerlink" title="ReentrantReadWriteLock原理"></a>ReentrantReadWriteLock原理</h1><p>t1 w.lock t2 r.lock</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145600222.png" alt="image-20220320145600222"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145619378.png" alt="image-20220320145619378"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145624167.png" alt="image-20220320145624167"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">+ 读写锁原理</span><br><span class="line">    + 使用的同一个sycn同步器</span><br><span class="line">    + t1 w.lock 写锁</span><br><span class="line">        + 与可重入锁基本相同</span><br><span class="line">        + state低16位写锁，高16位读锁</span><br><span class="line">        + tryacquire</span><br><span class="line">            + 这段看书没懂，现在终于懂了</span><br><span class="line">            + 判断有无：读锁、写锁（非本线程）</span><br><span class="line">    + t2 r.lock</span><br><span class="line">        + 读源码最好的办法是写个小栗子然后通过idea调试阅读，直接读太慢，还容易理解错了</span><br><span class="line">        + 判断有无写锁、当前线程的写锁</span><br><span class="line">        + 阻塞，和独占锁差不多</span><br><span class="line">            + 只是节点类型不同：node类型为shared</span><br><span class="line">            + 判断是否为老二</span><br><span class="line">                + 重试尝试获取</span><br><span class="line">            + 前驱设为-1（哨兵）</span><br><span class="line">            + 再次进入循环，尝试获取</span><br><span class="line">                + 一共三次尝试</span><br><span class="line">            + park阻塞</span><br><span class="line">    + t3 r.lock  t4 w.lock</span><br><span class="line">        + 进入阻塞队列</span><br><span class="line">            + 读锁类型为shared</span><br><span class="line">            + 写锁为独占</span><br><span class="line">            + node state</span><br><span class="line">                + 前面为-1</span><br><span class="line">                + 最后为0</span><br><span class="line">    + t1 w.unlock</span><br><span class="line">        + tryrelease</span><br><span class="line">            + state--</span><br><span class="line">            + 检查是否有读锁</span><br><span class="line">            + 唤醒节点</span><br><span class="line">            + 老二唤醒</span><br><span class="line">                + 非公平锁体现在持有锁的线程释放锁后，外来线程直接去尝试获取锁，而不会去判断队列是否有线程，这时队列中的线程和外来线程争抢锁，就是非公平的</span><br><span class="line">                + 公平锁体现在外来线程要获取锁时，会先判断队列有没有线程阻塞，有就自己去队列排队，不会去尝试获取锁</span><br><span class="line">            + 老二继续循环，tryacquire获取读锁</span><br><span class="line">                + state高位变成1</span><br><span class="line">                + 讲到也不细，必须自己调试源码</span><br><span class="line">                + 关键是思考，多读源码</span><br><span class="line">                + setHead(node)之后的代码的意思是，当阻塞队列中有多个连续的读线程时，会传播式地逐一唤醒，if(s.isShared())&#123;doReleaseShared()&#125;这段代码是关键</span><br><span class="line">            + 拿到下个node，若为shared</span><br><span class="line">                + 把哨兵节点状态改为0</span><br><span class="line">                    + 避免其他线程干扰</span><br><span class="line">                + 继续唤醒shared node</span><br><span class="line">                    + 继续循环，获取锁tryacquire</span><br><span class="line">                    + 读锁计数（高位）+1</span><br><span class="line">                    + 循环唤醒节点方法</span><br><span class="line">                        + 判断下一个node是否为shared</span><br><span class="line">                        ...</span><br><span class="line">    + t2 r.unlock t3 r.unlock</span><br><span class="line">        + tryreleaseshare</span><br><span class="line">            + 状态-1</span><br><span class="line">                + 若不为0，其他读锁继续-1</span><br><span class="line">            + 读state为0</span><br><span class="line">                + 解锁流程</span><br><span class="line">                    + 哨兵节点状态-1改为0</span><br><span class="line">                    + 后继节点唤醒unpark</span><br><span class="line">                        + 循环继续，当前是老二，获取锁tryacquire</span><br><span class="line">                        + 当前node作为哨兵</span><br><span class="line">                        + 写state状态修改</span><br></pre></td></tr></table></figure><h1 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145720741.png" alt="image-20220320145720741"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ StamedLock</span><br><span class="line">    + 作用</span><br><span class="line">        + 增加读的性能</span><br><span class="line">        + 配合戳使用</span><br><span class="line">            + 加锁返回戳</span><br><span class="line">            + 用戳解锁</span><br><span class="line">            + 乐观读</span><br><span class="line">                + 验戳，锁升级</span><br><span class="line">    + 演示</span><br><span class="line">        + 乐观读，戳不变，未被修改读取成功</span><br><span class="line">        + 戳改变，锁升级</span><br><span class="line">            + 真正加读锁，与写锁互斥</span><br><span class="line">        + 读读</span><br><span class="line">            + 乐观读等于无锁读取</span><br><span class="line">        + 读写</span><br><span class="line">            + 乐观读锁验证戳失败</span><br><span class="line">            + 加读锁，进入阻塞</span><br><span class="line">            + 写锁释放后，读锁加成功</span><br><span class="line">                + 读取最新值</span><br><span class="line">        + 缺点：</span><br><span class="line">            + 无条件变量</span><br><span class="line">            + 不支持可重入</span><br></pre></td></tr></table></figure><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145742093.png" alt="image-20220320145742093"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+ Semaphore</span><br><span class="line">    + 作用</span><br><span class="line">        + 信号量</span><br><span class="line">            + 限制同时访问共享资源的线程上限</span><br><span class="line">    + 演示</span><br><span class="line">        + acquire获取信号量</span><br><span class="line">    + 应用</span><br><span class="line">        + 简单限流（单机）</span><br><span class="line">        + 限制线程数，而非资源数</span><br><span class="line">            + 适合一个线程一个连接：数据库连接池</span><br><span class="line">        + 改进数据库连接池</span><br><span class="line">            + 获取连接</span><br><span class="line">                + 获取信号量</span><br><span class="line">                    + 获取成功才能获取连接</span><br><span class="line">                    + 没有信号量，阻塞</span><br><span class="line">            + 归还连接</span><br><span class="line">                + 归还后，release信号量</span><br><span class="line">    + 原理</span><br><span class="line">        + 构造方法</span><br><span class="line">            + 信号量给同步器sync，赋值信号量给state</span><br><span class="line">        + acquire</span><br><span class="line">            + tryacquireshare</span><br><span class="line">                + 获取state</span><br><span class="line">                + 判断state--是否小于0</span><br><span class="line">                    + 无信号量，AQS阻塞队列</span><br><span class="line">                    + 老二try获取，cas</span><br><span class="line">                    + 前驱改为-1</span><br><span class="line">                    + 最后park线程</span><br><span class="line">                + cas修改state--</span><br><span class="line">        + release</span><br><span class="line">            + tryreleaseshare</span><br><span class="line">                + 获取state</span><br><span class="line">                + cas state++</span><br><span class="line">            + doreleaseshare</span><br><span class="line">                + 哨兵节点是否-1</span><br><span class="line">                    + 改为0</span><br><span class="line">                + 唤醒后序节点</span><br><span class="line">                    + 老二 tryacquire，成功</span><br><span class="line">                        + cas state</span><br><span class="line">                    + 自己设为哨兵</span><br><span class="line">                    + 唤醒后序共享节点</span><br><span class="line">                        + 由于信号量不够，又被阻塞</span><br><span class="line">                    + 这里有个双unpark机制，就是运行结束后的线程会释放锁去唤醒，另外一个刚获得释放的锁的线程也会去唤醒，不过被唤醒后的线程不能获得锁还是会park住</span><br></pre></td></tr></table></figure><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145822476.png" alt="image-20220320145822476"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145829350.png" alt="image-20220320145829350"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ CountDownLatch</span><br><span class="line">    + 简介</span><br><span class="line">        + 倒计时锁，线程间同步协作</span><br><span class="line">            + await()等待计数归零，countdown()计数-1</span><br><span class="line">        + aqs同步器</span><br><span class="line">            + acquire：state为0获得锁</span><br><span class="line">            + release：计数-1</span><br><span class="line">        + 主线程等待，其他线程计数减完，主线程继续运行</span><br><span class="line">    + 改进</span><br><span class="line">        + 线程池等不能用join等待线程结束</span><br><span class="line">            + 可以用countdownlatch</span><br><span class="line">    + 应用</span><br><span class="line">        + 等待多线程准备完毕</span><br><span class="line">            + 加载完毕计数-1</span><br><span class="line">            + 计数结束，主线程运行</span><br><span class="line">        + 等待多个远程调用结束</span><br><span class="line">            + CompletableFuture异步编排</span><br><span class="line">            + 倒计时锁</span><br><span class="line">            + 我选择AsyncTool</span><br><span class="line">            + 使用future获取返回值</span><br><span class="line">+ Cyclicbarrier</span><br><span class="line">    + 问题</span><br><span class="line">        + countdownlatch不能被重用</span><br><span class="line">        + Cyclicbarrier</span><br><span class="line">    + 使用</span><br><span class="line">        + await</span><br><span class="line">            + state-1 阻塞</span><br><span class="line">            + 当state为0，全部唤醒继续</span><br><span class="line">        + 当全部执行完，运行参数中的任务</span><br><span class="line">        + 计数为0后，再次调用await又重新开始</span><br><span class="line">    + 注意</span><br><span class="line">        + 线程数要跟计数一样</span><br></pre></td></tr></table></figure><h1 id="JUC-Collection"><a href="#JUC-Collection" class="headerlink" title="JUC-Collection"></a>JUC-Collection</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145839640.png" alt="image-20220320145839640"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ 线程安全集合类</span><br><span class="line">    + 概述</span><br><span class="line">        + 遗留的</span><br><span class="line">            + hahtable、vector：都用synchronize修饰</span><br><span class="line">        + 修饰的安全集合</span><br><span class="line">            + collections中类的包装</span><br><span class="line">            + 装饰器模式</span><br><span class="line">        + juc安全集合</span><br><span class="line">            + blocking类</span><br><span class="line">                + 大部分基于锁（可重用锁），阻塞方法</span><br><span class="line">            + copyonwrite类</span><br><span class="line">                + 修改时拷贝的方式</span><br><span class="line">                + cow写时复制</span><br><span class="line">            + concurrent类</span><br><span class="line">                + 内部很多采用cas优化，提高吞吐</span><br><span class="line">                + 弱一致性</span><br><span class="line">                    + 遍历时，其他线程修改，迭代器继续运行（旧内容）</span><br><span class="line">                    + 求大小、读取</span><br><span class="line">                    + 这里的弱一致性，其实是安全失败机制（fail-safe）实现原理：获得原集合的一份拷贝，在拷贝而来的集合上进行遍历，原集合发生的改变时，不会抛出CME异常</span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320145853898.png" alt="image-20220320145853898"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ ConcurrentHashMap</span><br><span class="line">    + 面试的神!CHM</span><br><span class="line">    + 错误用法</span><br><span class="line">        + 统计单词个数</span><br><span class="line">            + 线程不安全</span><br><span class="line">        + hm改为chm</span><br><span class="line">            + 仍然不行</span><br><span class="line">                + 每个方法原子</span><br><span class="line">                + 组合起来非原子</span><br><span class="line">            + 解决：</span><br><span class="line">                + 直接加synchronize重量级锁</span><br><span class="line">                + CAS</span><br><span class="line">    + computeIfAbsent</span><br><span class="line">        + 跟我在极客时间学的一样，哈哈哈哈</span><br><span class="line">        + 这个demo感觉信息量好大，学到很多编程思路和手段</span><br><span class="line">        + 第一次若key不存在，则生成key和累加器（原子性）</span><br><span class="line">        + 后面直接返回累加器，进行累加（原子性）</span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150154452.png" alt="image-20220320150154452"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150213295.png" alt="image-20220320150213295"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">+ ConcurrentHashMap原理</span><br><span class="line">    + hashmap</span><br><span class="line">        + 回顾</span><br><span class="line">            + 数组+链表+红黑树</span><br><span class="line">            + hash地址冲突，链地址法</span><br><span class="line">                + jdk7放到链表头部</span><br><span class="line">                + jdk8放到链表尾部</span><br><span class="line">            + 超过3/4，扩容，重新计算桶下标</span><br><span class="line">                + 低位的下标不变，高位的加个oldSize就是新下标</span><br><span class="line">                + 为什么数组扩容后，链表长度会减半？因为我们确定桶位置是数组长度与hash进行&amp;操作，长度扩为2倍，桶位置正好会改为2倍</span><br><span class="line">            + 多线程下扩容，并发死链问题</span><br><span class="line">        + 死链</span><br><span class="line">            + 两个线程同时触发扩容</span><br><span class="line">            + 出现环形链表</span><br><span class="line">                + 第一次扩容结束后，线程再进行扩容的时候链表上出现了环。导致程序不能再往下继续运行</span><br><span class="line">            + jdk8，尾插法</span><br><span class="line">                + 仍有其他问题（扩容丢数据）</span><br><span class="line">+ concurrenthashmap-jdk8</span><br><span class="line">    + 原理</span><br><span class="line">        + 属性&amp;内部类&amp;方法</span><br><span class="line">            + 迁移</span><br><span class="line">                + 从后往前处理</span><br><span class="line">                + 处理完加fnode节点</span><br><span class="line">            + 红黑树</span><br><span class="line">                + 扩容到64</span><br><span class="line">                + 链表转换成红黑树</span><br><span class="line">        + 构造</span><br><span class="line">            + 初始容量、负载因子（3/4）、并发度</span><br><span class="line">                + 最少初始容量等于并发度</span><br><span class="line">            + 懒惰初始化</span><br><span class="line">            + 计算容量大小（变成为2的n次方）</span><br><span class="line">        + get</span><br><span class="line">            + 这个地方说的不清楚，看完也不知道为什么不加锁，实际上是用了volatile关键字</span><br><span class="line">            + 不加锁就是volatile带来的好处，即使写操作更新了也可见不会脏读</span><br><span class="line">            + 遍历链表，用equals比较key，返回val</span><br><span class="line">        + put</span><br><span class="line">            + 默认覆盖旧值</span><br><span class="line">            + 不允许null</span><br><span class="line">            + 若table为空</span><br><span class="line">                + cas创建table</span><br><span class="line">            + 若链表无头结点（桶下标不冲突）</span><br><span class="line">                + cas添加链表头</span><br><span class="line">                + 头结点被占，再循环一遍，这个结点会加在刚刚那个头结点的后面</span><br><span class="line">            + 帮忙扩容</span><br><span class="line">                + 锁住当前链表帮忙扩容</span><br><span class="line">            + 桶下标冲突</span><br><span class="line">                + 加锁synchronize，锁住链表头结点</span><br><span class="line">                + 再次校验链表头节点是否被移动</span><br><span class="line">                + 节点hash&gt;0</span><br><span class="line">                    + key找到相同的，更新操作</span><br><span class="line">                        + 更新value</span><br><span class="line">                    + key不存在，添加操作</span><br><span class="line">                        + 已经是最后的节点了</span><br><span class="line">                        + 新增node链表尾插</span><br><span class="line">                + 节点hash&lt;0，判断是否为红黑树</span><br><span class="line">                    + 往红黑树中添加node</span><br><span class="line">                + 释放锁，判断链表长度是否大于树化阈值</span><br><span class="line">            + 计数器计数</span><br><span class="line">        + initTable</span><br><span class="line">            + 懒惰初始化</span><br><span class="line">            + table若没被创建，进入循环</span><br><span class="line">                + 双重校验是否被创建</span><br><span class="line">                    + 第一次并发</span><br><span class="line">                + cas将sizeCtl设为-1（正在创建hash表）</span><br><span class="line">                + 成功cas，准备创建hash表</span><br><span class="line">                    + 根据初始容量sc，创建node数组</span><br><span class="line">                    + sc赋值给sizeCtl，恢复到正数</span><br><span class="line">                + 并发线程都在循环中退出</span><br><span class="line">        + addcount</span><br><span class="line">            + 增加元素计数</span><br><span class="line">            + 多个累加单元，保证多线程效率</span><br><span class="line">            + 没有累加单元，cas向basecount累加</span><br><span class="line">            + 有了累加单元，cas累加++</span><br><span class="line">                + @Contended注解防止数据伪共享</span><br><span class="line">                + 之前讲LongAdder原理的时候讲过，说的是@Contened注解，这个注解是在对象或变量前后加padding，就是占位，为了避免多CPU缓存行伪共享问题</span><br><span class="line">                + 元素个数若大于sizeCtl，进入循环，扩容操作</span><br><span class="line">                    + 校验sc是否为负数</span><br><span class="line">                        + 若newtable已创建</span><br><span class="line">                            + 帮忙扩容</span><br><span class="line">                    + cas将sizeCtl设为负数</span><br><span class="line">                    + cas成功，进入transfer，传入table</span><br><span class="line">        + size</span><br><span class="line">            + 没有竞争发生，basecount累加</span><br><span class="line">            + 有竞争发生，用累加单元计数</span><br><span class="line">                + sum 累加单元的值和basecount</span><br><span class="line">            + 很明显在sumCount计算的过程中无法防止别的线程进行一些累加和删除操作</span><br><span class="line">        + transfer</span><br><span class="line">            + 若nexttable为null，创建nexttable</span><br><span class="line">                + 原有容量&lt;&lt;1</span><br><span class="line">            + 节点搬迁</span><br><span class="line">                + 以链表为单位移动</span><br><span class="line">                + 若链表处理完，替换为forwardingnode</span><br><span class="line">                + 若已经为fwd，处理下一个链表</span><br><span class="line">                + 若链表头有元素</span><br><span class="line">                    + synchronize锁住当前链表</span><br><span class="line">                    + 节点hash&gt;0（普通节点）</span><br><span class="line">                    + 节点hash&lt;0且类型为treebin，树节点搬迁</span><br><span class="line">+ concurrenthashmap-jdk7</span><br><span class="line">    + 结构</span><br><span class="line">        + 维护segment数组（每个继承可重用锁）</span><br><span class="line">            + 多把锁</span><br><span class="line">            + jdk8：锁加在链表头</span><br><span class="line">        + 缺点：</span><br><span class="line">            + 锁数组大小固定</span><br><span class="line">            + 非懒惰初始化</span><br><span class="line">        + 构造时就创建</span><br><span class="line">        + 每个segment（分段锁）对应小的hashentry</span><br><span class="line">            + 不同锁，锁的内容不一样</span><br><span class="line">    + 定位segment</span><br><span class="line">        + 多看两遍，JUC的东西还是连续性很强的</span><br><span class="line">        + 根据hash求segment位置（位运算），获取segment</span><br><span class="line">    + put</span><br><span class="line">        + 计算key的hash，找到segment下标</span><br><span class="line">        + 获取segment，进入segment的put方法</span><br><span class="line">            + 可重入锁加锁</span><br><span class="line">            + hashentry，求桶下标</span><br><span class="line">                + 链表：更新/新增</span><br><span class="line">                    + key找到相等，更新值</span><br><span class="line">                    + 找不到key，新增</span><br><span class="line">                        + 创建node节点</span><br><span class="line">                        + 扩容等</span><br><span class="line">                        + 做为链表头</span><br><span class="line">    + rehash扩容</span><br><span class="line">        + 在外层已经加锁</span><br><span class="line">        + 旧容量移位，创建newtable</span><br><span class="line">        + 遍历搬迁</span><br><span class="line">            + 如果只有头节点，直接搬迁</span><br><span class="line">            + 链表多个节点，遍历链表</span><br><span class="line">                + 记录node改变后位置</span><br><span class="line">                + 把不变的node重用</span><br><span class="line">        + 新增时才rehash</span><br><span class="line">            + 新的node在扩容完才加入new table</span><br><span class="line">    + get</span><br><span class="line">        + unsafe方法保证可见性</span><br><span class="line">        + 定位segment、桶下标</span><br><span class="line">        + 遍历key，找到直接返回value</span><br><span class="line">    + size</span><br><span class="line">        + 循环，遍历segment</span><br><span class="line">            + sum累加count</span><br><span class="line">                + 期间若被修改（不等于上次计数），则重新计数</span><br><span class="line">                + 最多循环计数三次，加锁处理统计操作</span><br><span class="line">        + 先不加锁计算2次，认为个数正确返回</span><br><span class="line">        + 如果不一样，重试，超过3次，锁住所有segment</span><br></pre></td></tr></table></figure><h1 id="LinkedBlockingQueue原理"><a href="#LinkedBlockingQueue原理" class="headerlink" title="LinkedBlockingQueue原理"></a>LinkedBlockingQueue原理</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150052835.png" alt="image-20220320150052835"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ LinkedBlockingQueue</span><br><span class="line">    + 入队出队</span><br><span class="line">        + 阻塞队列</span><br><span class="line">        + node（item、next）</span><br><span class="line">        + 初始化链表</span><br><span class="line">            + 指向哨兵节点</span><br><span class="line">        + 节点入队</span><br><span class="line">            + 尾插</span><br><span class="line">        + 节点出队</span><br><span class="line">            + 哨兵节点垃圾回收</span><br><span class="line">            + 获取老二的值，老二变成哨兵节点</span><br><span class="line">            + 占位哨兵在数构设计中的作用是，一开始头有所指，尾有所向。进出队时或者查找，少大约n次的if else</span><br><span class="line">    + 加锁分析</span><br><span class="line">        + 用了两把锁和哨兵</span><br><span class="line">            + 两把锁允许两个线程执行</span><br><span class="line">                + 生产者（队列尾）消费者（队列头）</span><br><span class="line">                + 允许同时get和put</span><br><span class="line">        + 线程安全</span><br><span class="line">            + 节点大于2</span><br><span class="line">                + 队尾队头两把锁（一个哨兵），保证入队出队无竞争</span><br><span class="line">            + 节点等于2</span><br><span class="line">                + 仍然两把锁（一个哨兵），锁两个对象</span><br><span class="line">            + 节点为1</span><br><span class="line">                + 就一个哨兵，队列为空，take会被阻塞</span><br><span class="line">    + put</span><br><span class="line">        + 非空判断</span><br><span class="line">        + 创建node</span><br><span class="line">        + 拿到put锁</span><br><span class="line">            + 若队列满容量，等待</span><br><span class="line">            + 若有空位，入队方法，计数++</span><br><span class="line">            + 若队列容量仍不满，叫醒put线程（signal一个）</span><br><span class="line">        + 解锁</span><br><span class="line">        + 如果队列只有一个元素，通知消费take线程（signal一个）</span><br><span class="line">        + 消费者也会唤醒，只是不是唤醒全部，只会唤醒一个，唤醒完一个后再由生产者自己唤醒生产者</span><br><span class="line">        + 如果有多个元素，那么take线程肯定是在执行的，如果只有一个元素，表示是我这次put进去的，需要唤醒take线程来取</span><br><span class="line">        + take，take锁</span><br><span class="line">            + 为空，等待</span><br><span class="line">            + 出队</span><br><span class="line">            + 队列有容量，叫醒一个消费者</span><br><span class="line">        + 解锁</span><br><span class="line">        + 如果队列只有一个空位，叫醒put生产者线程（signal）</span><br><span class="line">    + vs arrayblockingqueue</span><br><span class="line">        + linked懒惰的，初始不创建</span><br><span class="line">        + linked入队才生成node，array提前创建好的</span><br><span class="line">        + linked两把锁，array一把锁</span><br></pre></td></tr></table></figure><h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320150125092.png" alt="image-20220320150125092"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ ConcurrentLinkedQueue</span><br><span class="line">    + 与linked像，两把锁，队列头尾，哨兵</span><br><span class="line">    + 使用cas实现锁</span><br><span class="line">        + cas保证线程安全</span><br><span class="line">+ CopyOnWriteArrayList</span><br><span class="line">    + copyonwrite：写入时拷贝思想</span><br><span class="line">        + 增删改，在新数组上执行</span><br><span class="line">            + 不影响其他线程并发读</span><br><span class="line">            + 读写分离、读写并发</span><br><span class="line">    + add</span><br><span class="line">        + 加锁（写写互斥）</span><br><span class="line">            + 旧数组拷贝（长度+1）新数组</span><br><span class="line">            + 添加新元素</span><br><span class="line">            + 替换旧数组</span><br><span class="line">    + 读使用旧数组（新数组还未替换完）</span><br><span class="line">    + 读未加锁</span><br><span class="line">    + get弱一致性</span><br><span class="line">        + 线程同时读和remove，仍能读到</span><br><span class="line">        + 迭代器弱一致性</span><br><span class="line">            + 即使remove，迭代器仍拿到旧数组引用</span><br><span class="line">            + 优点</span><br><span class="line">                + 数据库的MVCC都是弱一致性表现</span><br><span class="line">                + 并发度高</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——手写线程池&amp;AQS原理&amp;可重入锁原理&amp;读写锁</title>
      <link href="/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;AQS%E5%8E%9F%E7%90%86&amp;%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86&amp;%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2022/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;AQS%E5%8E%9F%E7%90%86&amp;%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86&amp;%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h1><p>结构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320135837804.png" alt="image-20220320135837804"></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 任务队列</span></span><br><span class="line"><span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">// 2. 锁</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 3. 生产者条件变量</span></span><br><span class="line"><span class="keyword">private</span> Condition fullWaitSet = lock.newCondition();</span><br><span class="line"><span class="comment">// 4. 消费者条件变量</span></span><br><span class="line"><span class="keyword">private</span> Condition emptyWaitSet = lock.newCondition();</span><br><span class="line"><span class="comment">// 5. 容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ blocking queue</span><br><span class="line">    + 任务队列-双向链表</span><br><span class="line">    + 可重入锁</span><br><span class="line">        + 生产者条件变量</span><br><span class="line">            + 队列容量限制</span><br><span class="line">        + 消费者条件变量</span><br><span class="line">            + 队列空限制</span><br><span class="line">    + 容量上限</span><br><span class="line">    + 阻塞获取</span><br><span class="line">        + 上锁</span><br><span class="line">            + 队列不为空，获取队列头元素</span><br><span class="line">            + 唤醒队列满条件变量</span><br><span class="line">    + 阻塞添加</span><br><span class="line">        + 上锁</span><br><span class="line">            + 队列不满，进入队列尾部</span><br><span class="line">            + 唤醒队列空条件变量</span><br><span class="line">+ poll增强</span><br><span class="line">    + 带超时阻塞获取</span><br><span class="line">    + await返回的是：被唤醒后剩余时间</span><br><span class="line">        + 剩余时间赋值给下一个等待时间</span><br><span class="line">        + 剩余时间用完，退出</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ 实现</span><br><span class="line">    + TheadPool</span><br><span class="line">        + blockqueue</span><br><span class="line">        + hashset：线程worker</span><br><span class="line">            + 如果任务数没超过最大，交给线程执行</span><br><span class="line">            + 如果任务数超过最大，任务进入阻塞队列</span><br><span class="line">        + MAX</span><br><span class="line">        + timeout</span><br><span class="line">+ 执行任务</span><br><span class="line">+ worker执行</span><br><span class="line">    + 从传过来的task、任务队列中的task不断获取执行</span><br><span class="line">    + 执行完毕，移除线程</span><br><span class="line">    + 现在这个好像一旦没任务就扔掉，这不是享元模式啊</span><br><span class="line">    + 并不会移除，因为taskQueue的take方法是阻塞的，也就是说线程会一直活在休息室</span><br><span class="line">+ take死等&amp;poll超时</span><br><span class="line">    + take()死等</span><br><span class="line">        + 不会停止线程池中的线程</span><br><span class="line">+ 采用poll超时</span><br><span class="line">        + 没有任务，超时结束线程</span><br><span class="line">+ 当任务队列已满</span><br><span class="line">    + 阻塞等待添加任务队列</span><br><span class="line">+ offer增强</span><br><span class="line">    + 带超时时间，阻塞添加队列</span><br><span class="line">+ 拒绝策略</span><br><span class="line">    + 策略模式</span><br><span class="line">        + tryput</span><br><span class="line">+ 拒绝策略测试</span><br><span class="line">    + 面试手写线程池不慌了</span><br><span class="line">    + 等待、放弃、自己执行</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>构造方法</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320141145740.png" alt="image-20220320141145740"></p><p>执行流程</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320141746086.png" alt="image-20220320141746086"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+ JDK的线程池</span><br><span class="line">+ 线程池状态</span><br><span class="line">    + 存在原子变量中</span><br><span class="line">        + 一个整数同时保存了状态和线程个数</span><br><span class="line">+ 构造方法</span><br><span class="line">    + 工作方式</span><br><span class="line">        + 救急线程</span><br><span class="line">            + 阻塞队列满了之后，开启</span><br><span class="line">            + 执行完毕销毁</span><br><span class="line">            + 可设置生存时间</span><br><span class="line">        + 核心线程一直保存</span><br><span class="line">        + 救急线程都满了</span><br><span class="line">            + 执行拒绝策略</span><br><span class="line">    + 执行流程</span><br><span class="line">        + 拒绝策略：四种</span><br><span class="line">            + 抛出异常</span><br><span class="line">            + 调用者执行任务</span><br><span class="line">            + 放弃任务</span><br><span class="line">            + 放弃队列中最早的任务，本任务取代</span><br><span class="line">        + 其他框架</span><br><span class="line">            + 站在架构角度思考问题</span><br><span class="line">            + dubbo</span><br><span class="line">                + 抛异常前记录日志，线程栈信息</span><br><span class="line">            + netty</span><br><span class="line">                + 创建新线程</span><br><span class="line">            + activemq</span><br><span class="line">                + 带超时放入队列</span><br><span class="line">            + pinpoint</span><br><span class="line">                + 拒绝策略链，逐一尝试每种策略</span><br><span class="line">    + 将框架拆解开，从自己实现到带逐一分析别人怎么实现，思路清晰。</span><br><span class="line">+ 工厂方法创建线程池</span><br><span class="line">    + 固定大小线程池</span><br><span class="line">        + 没有救急线程，线程不会结束</span><br><span class="line">        + 无界队列</span><br><span class="line">        + 厉害，底层使用到了许多设计模式</span><br><span class="line">    + 带缓冲线程池</span><br><span class="line">        + 全部救急线程，60s回收</span><br><span class="line">        + 队列：没有容量</span><br><span class="line">            + 没有线程取是放不进去的</span><br><span class="line">            + 队列的put只有其他线程take才会被执行</span><br><span class="line">    + 单线程线程池</span><br><span class="line">        + 保证线程池始终有一个可用的线程</span><br><span class="line">        + 装饰器模式</span><br><span class="line">            + 只能调用返回包装对象中的方法</span><br><span class="line">+ submit（带返回结果）</span><br><span class="line">    + execute（runnable）</span><br><span class="line">    + submit（callable）</span><br><span class="line">        + 返回结果</span><br><span class="line">        + 保护性暂停模式</span><br><span class="line">    + TODO 异步编排和ThreadLocal</span><br><span class="line">    + 测试</span><br><span class="line">+ invokeAll（执行任务集合、超时时间）</span><br><span class="line">+ invokeAny</span><br><span class="line">    + 执行完一个即可（最先执行完毕）</span><br><span class="line">+ 停止</span><br><span class="line">    + shutdown（执行完毕所有任务（队列）停止）</span><br><span class="line">        + 主线程异步，不会等待</span><br><span class="line">    + showdownnow</span><br><span class="line">        + STOP立即停止</span><br><span class="line">        + 返回队列</span><br><span class="line">    + 判断暂停，等待结束等</span><br><span class="line">+ 测试</span><br><span class="line">    + 结束</span><br><span class="line">    + 等待</span><br></pre></td></tr></table></figure><h1 id="设计模式-工作线程"><a href="#设计模式-工作线程" class="headerlink" title="设计模式-工作线程"></a>设计模式-工作线程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 异步模式之工作线程</span><br><span class="line">    + 定义</span><br><span class="line">        + 工作线程：线程池、享元模式</span><br><span class="line">            + 不同任务类型采用不同线程池</span><br><span class="line">                + 不同类型的任务 执行时间不一样 所以同一个线程池可能导致有些线程很难或者很迟被执行  而且每个task的优先级不同</span><br><span class="line">    + 饥饿</span><br><span class="line">        + 现象</span><br><span class="line">            + 线程数量不足导致饥饿（固定大小线程池）</span><br><span class="line">                + 线程数不足，无法处理任务</span><br><span class="line">        + 解决</span><br><span class="line">            + 不同任务类型，应该使用不同线程池</span><br><span class="line">    + 池大小</span><br><span class="line">        + 过小、过大都不合适</span><br><span class="line">        + 运算类型</span><br><span class="line">            + IO密集型公式</span><br></pre></td></tr></table></figure><h1 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ timer的缺点</span><br><span class="line">    + timer：一个线程调度，串行执行</span><br><span class="line">    + 前面任务执行时间会影响、终止后面的任务</span><br><span class="line">+ ScheduledThreadPoolExecutor</span><br><span class="line">    + 延时执行</span><br><span class="line">        + 改变线程池大小</span><br><span class="line">        + 出现异常，不影响下面的运行</span><br><span class="line">    + 定时执行</span><br><span class="line">        + 按照间隔不断执行一次任务</span><br><span class="line">            + 一个任务开始为起点的</span><br><span class="line">        + delay</span><br><span class="line">            + 结束时间算</span><br><span class="line">        + 这些还是属于比较基础的</span><br><span class="line">+ 正确处理线程池异常</span><br><span class="line">    + trycatch</span><br><span class="line">    + future对象 + callable</span><br><span class="line">        + get()</span><br><span class="line">+ 线程池应用</span><br><span class="line">    + 定时任务</span><br><span class="line">        + 记得Linux或者spring里有个cron表达式专门做定时任务</span><br><span class="line">        + 用quartz或springtask</span><br><span class="line">        + 可以用Xxl-job</span><br><span class="line">        + 下次执行时间 + 间隔时间</span><br><span class="line">+ tomcat线程池</span><br><span class="line">    + 线程池-分工</span><br><span class="line">    + 拒绝策略：尝试放入队列后，抛异常</span><br><span class="line">    + 配置</span><br><span class="line">        + 最大线程不够，再放入队列</span><br><span class="line">+ fork/join线程池</span><br><span class="line">    + 分治、任务拆分线程池</span><br><span class="line">    + 使用</span><br><span class="line">        + 任务对象：recursivetask</span><br><span class="line">        + 拆分任务：递归思想</span><br><span class="line">        + 测试</span><br><span class="line">            + 这个方法处理斐波那契数列非常慢，还是需要加上记忆化</span><br><span class="line">        + 任务拆分优化</span><br><span class="line">            + 不用一个任务依赖另一个任务</span><br><span class="line">            + 和Java高并发程序设计里的例子一样，很好的分离任务之间的联系</span><br><span class="line">            + 分治</span><br><span class="line">                + 拆分两个任务，分治</span><br></pre></td></tr></table></figure><h1 id="Aqs原理"><a href="#Aqs原理" class="headerlink" title="Aqs原理"></a>Aqs原理</h1><p>JUC包原理部分</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320142555302.png" alt="image-20220320142555302"></p><p>AQS同步器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320142530222.png" alt="image-20220320142530222"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ AQS原理</span><br><span class="line">    + 概述</span><br><span class="line">        + 阻塞式锁和同步工具的框架</span><br><span class="line">            + state</span><br><span class="line">                + 控制获取锁释放锁</span><br><span class="line">            + 等待队列，entrylist</span><br><span class="line">            + 条件变量，waitlist</span><br><span class="line">        + reentrantLock就是用的aqs</span><br><span class="line">    + 自定义锁（不可重入锁）</span><br><span class="line">        + 同步器类-继承aqs</span><br><span class="line">            + tryacquire</span><br><span class="line">                + cas修改status</span><br><span class="line">                + 设置owner为当前线程</span><br><span class="line">            + tryrelease</span><br><span class="line">                + owner为null</span><br><span class="line">                + 直接修改status</span><br><span class="line">                    + 前面为写屏障，保证null被其他线程可见</span><br><span class="line">            + isHeldexclusively</span><br><span class="line">                + 是否持有独占锁</span><br><span class="line">            + newcondition</span><br><span class="line">        + 加锁</span><br><span class="line">        + 加锁、可打断加锁</span><br><span class="line">            + 尝试加锁，尝试加锁带超时</span><br><span class="line">        + 解锁</span><br><span class="line">            + release唤醒</span><br><span class="line">    + 测试</span><br><span class="line">        + 不可重入</span><br></pre></td></tr></table></figure><h1 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320143257653.png" alt="image-20220320143257653"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320143313550.png" alt="image-20220320143313550"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">+ ReentrantLock原理</span><br><span class="line">    + 实现lock</span><br><span class="line">    + 内部sync同步器，继承aqs，实现了非公平和公平锁</span><br><span class="line">    + 非公平锁实现原理（默认）</span><br><span class="line">        + 加锁成功流程——lock()</span><br><span class="line">            + cas修改status</span><br><span class="line">            + 修改owner为当前线程</span><br><span class="line">            + cas修改失败</span><br><span class="line">                + JDK11 已经没有了，直接调用的AQS抽象类的acquire</span><br><span class="line">                + JDK11 对于失败采用的是短路与的方式</span><br><span class="line">                + tryacquire——cas重试</span><br><span class="line">                + 重试失败，acquirequeue加入队列</span><br><span class="line">                    + 第1个线程直接抢占同步器，第2个线程初始化队列：产生哑元和Node1节点，第三个线程产生Node2节点并将其插入到哑元和Node1节点之后。就是这样一个过程</span><br><span class="line">                    + 队列大体是这样的：head-&gt;哑元-&gt;Node1(Thead-1)-&gt;Node2(Thread-2)-&gt;...-&gt;tail)</span><br><span class="line">                    + 获取前驱节点</span><br><span class="line">                        + 若为头结点（哨兵）</span><br><span class="line">                        + 再次尝试获取锁tryacquire</span><br><span class="line">                    + 仍然获取失败</span><br><span class="line">                        + 把前驱节点waitstatus改为-1（有责任唤醒后继节点）</span><br><span class="line">                            + 返回false</span><br><span class="line">                        + 重新进入acquirequeue</span><br><span class="line">                            + 再次tryacquire</span><br><span class="line">                            + 这次前驱node为-1</span><br><span class="line">                            + park阻塞当前线程</span><br><span class="line">        + 解锁竞争成功流程</span><br><span class="line">            + tryrelease</span><br><span class="line">                + status、owner</span><br><span class="line">            + unpark</span><br><span class="line">                + 找到最近没取消的node，unpark</span><br><span class="line">                    + 唤醒后，重新进入循环tryacquire</span><br><span class="line">                    + 变成owner线程</span><br><span class="line">                        + 当前node变为头结点，哨兵节点</span><br><span class="line">        + 解锁竞争失败流程</span><br><span class="line">            + 不在等待队列中的线程，解锁时来竞争</span><br><span class="line">                + node尝试获取锁失败</span><br><span class="line">                + 重新进入park阻塞</span><br><span class="line">    + 可重入原理（非公平锁为例）</span><br><span class="line">        + 同一线程再次调用tryacquire</span><br><span class="line">            + 判断状态为上锁</span><br><span class="line">            + 再次判断owner是否为当前线程</span><br><span class="line">                + 发生锁重入</span><br><span class="line">                + status++表示重入两次</span><br><span class="line">        + 释放锁tryrelease</span><br><span class="line">            + status--</span><br><span class="line">                + 但是status不为0，返回false</span><br><span class="line">            + 再次调用tryrelease时将status变为0，设owner为null</span><br><span class="line">                + 返回true</span><br><span class="line">    + 可打断原理</span><br><span class="line">        + 不可打断模式（默认）</span><br><span class="line">            + 就是在获取到锁之前不能被打断</span><br><span class="line">            + 不可打断就是会用interrupted标记自己被打断过，但不会立即响应打断，等获得锁之后再自己打断自己</span><br><span class="line">        + 可打断模式interruptibly</span><br><span class="line">            + park时打断，直接抛出异常，停止等待锁</span><br><span class="line">    + 公平锁原理</span><br><span class="line">        + 非公平锁</span><br><span class="line">            + 没有锁时，直接去cas获取锁，不会检测等待队列</span><br><span class="line">        + 公平锁</span><br><span class="line">            + 先去检查aqs队列中是否有前驱节点，没有才去获取锁</span><br><span class="line">            + 如果队列中没有第二个节点、第二个节点不是此线程</span><br><span class="line">                + 返回没资格获取</span><br><span class="line">    + 条件变量实现原理</span><br><span class="line">        + 每个条件变量对应一个等待队列</span><br><span class="line">        + await</span><br><span class="line">            + 进入addconditionwaiter流程</span><br><span class="line">                + 把当前线程加入条件变量的链表</span><br><span class="line">                    + 创建新的node状态为-2（每个node都有状态）</span><br><span class="line">                    + 加入链表</span><br><span class="line">            + fullyrelease流程</span><br><span class="line">                + 释放同步器上的所有锁</span><br><span class="line">                + owner空出、 unpark后序节点</span><br><span class="line">            + park当前线程，等待被唤醒</span><br><span class="line">        + signal</span><br><span class="line">            + 判断当前线程是否为锁持有者</span><br><span class="line">                + 非持有者无法唤醒条件变量线程</span><br><span class="line">            + 条件队列，找到队首元素</span><br><span class="line">                + 断开node</span><br><span class="line">            + node转移到竞争锁的队列中</span><br><span class="line">                + 转移成功，修改node状态</span><br><span class="line">                    + 阻塞队列除了最后一个node状态为0，其他都为-1</span><br><span class="line">                    + 然后如果是CAS设置waitStatus出错的话，源码翻译好像说这个状态错误是短暂且无害的，但是为了正确，可能还是得重新让他抢锁，然后重新入队，再次CAS到状态正确就结束</span><br><span class="line">                    + 如果CAS错误，可能也有一种情况就是他超时正在取消，然后还没改waitStatus，等你调用CAS他的watiStatus已经改成取消了</span><br><span class="line">                + 转移失败，使用条件队列下一个node唤醒</span><br></pre></td></tr></table></figure><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220320143730503.png" alt="image-20220320143730503"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">+ ReentrantReadWriteLock</span><br><span class="line">    + 使用</span><br><span class="line">        + 读读并发，读写互斥</span><br><span class="line">            + 只是读就可以读，读的时候写了就阻塞读</span><br><span class="line">        + 测试</span><br><span class="line">            + 同时读取，不互斥</span><br><span class="line">            + 读写，阻塞无法写，等待读锁释放</span><br><span class="line">            + 写写互斥</span><br><span class="line">    + 注意事项</span><br><span class="line">        + 读锁不支持条件变量，写锁支持</span><br><span class="line">        + 重入的时候，不能升级获取</span><br><span class="line">            + 读锁时不能重入获取写</span><br><span class="line">        + 重入时降级支持</span><br><span class="line">            + 写锁时可以再次获取读</span><br><span class="line">                + 有缓存数据，直接读取返回</span><br><span class="line">                + 没有缓存</span><br><span class="line">                    + 获取写锁（提前释放读锁）</span><br><span class="line">                    + 再次判断缓存是否已经更新</span><br><span class="line">                        + 直接返回数据</span><br><span class="line">                    + 缓存仍不存在</span><br><span class="line">                        + 重新计算数据</span><br><span class="line">                    + 获取读锁，防止写线程干扰</span><br><span class="line">                    + 释放写锁</span><br><span class="line">                + 读取数据</span><br><span class="line">        + 应用之缓存</span><br><span class="line">            + 添加缓存</span><br><span class="line">                + 缓存map集合：key：标志缓存（sql、参数）</span><br><span class="line">                + 查询：先从缓存中找，没有查询后添加到缓存</span><br><span class="line"></span><br><span class="line">                    + 查询key</span><br><span class="line">                + 更新：删除缓存，更新</span><br><span class="line">            + 问题分析</span><br><span class="line">                + hashmap不安全</span><br><span class="line">                + 高并发查询不安全</span><br><span class="line">                + 缓存更新策略</span><br><span class="line">                    + 先清缓存，再更新数据库</span><br><span class="line">                        + 清空后还未更新，其他线程查询旧数据，同步到缓存（旧）</span><br><span class="line">                    + 先更新数据库 √</span><br><span class="line">                        + 还未清空缓存，其他线程查询到旧数据，才清空缓存（短暂不一致）</span><br><span class="line">                        + 可以加原子操作</span><br><span class="line">            + 实现</span><br><span class="line">                + 创建读写锁</span><br><span class="line">                    + update（更新、删缓存）添加写锁</span><br><span class="line">                        + 保证原子性</span><br><span class="line">                    + 直接查询缓存添加读锁</span><br><span class="line">                    + 查库（查询、放入缓存）添加写锁</span><br><span class="line">                        + 可能多个线程阻塞在写锁</span><br><span class="line">                        + 双重检查，再次判断缓存存在</span><br><span class="line">                        + 保证原子性</span><br><span class="line">                + 缓存意义是为了减少连接数据库的查询用的，多线程下缓存的访问需要考虑线程安全问题，所以加锁</span><br><span class="line">                + 读本来可以不加锁，但是写操作会导致读错误，所以加了读锁，会导致写锁加了不能写，还有其他原因</span><br><span class="line">            + 补充</span><br><span class="line">                + 适合读多写少</span><br><span class="line">                + 问题</span><br><span class="line">                    + 缓存容量</span><br><span class="line">                    + 缓存过期</span><br><span class="line">                    + 单机</span><br><span class="line">                    + 并发低</span><br><span class="line">                        + 锁细分</span><br><span class="line">                        + 针对不同操作分区，上不同锁</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——共享模型之无锁、不可变-CAS&amp;享元模式</title>
      <link href="/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
      <url>/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 问题提出</span><br><span class="line">    + 保护共享资源</span><br><span class="line">        + 加锁实现</span><br><span class="line">            + synchronize、reentrantlock</span><br><span class="line">        + 无锁实现</span><br><span class="line">            + AtomicInteger：原子整数</span><br><span class="line">                + int封装</span><br><span class="line">            + compareAndSet(prev,next)</span><br><span class="line">                + 修改成功为true</span><br></pre></td></tr></table></figure><h2 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h2><p>cas</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315223914515.png" alt="image-20220315223914515"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ cas与volatile</span><br><span class="line">    + 工作方式</span><br><span class="line">        + cas原子</span><br><span class="line">        + CAS就是JAVA里唯一的乐观锁了...</span><br><span class="line">        + 保证了CAS原子性</span><br><span class="line">    + 慢动作分析</span><br><span class="line">    + volatile</span><br><span class="line">        + 保证了变量的可见性</span><br><span class="line">            + 保证获取新值比较</span><br><span class="line">    + 效率分析</span><br><span class="line">        + 无锁始终运行，有锁会上下文切换</span><br><span class="line">            + runnable——&gt;blocked</span><br><span class="line">            + 代价比较大</span><br><span class="line">        + 无锁线程保存运行，需要额外cpu支持</span><br><span class="line">            + 没有分到时间片，变成可运行状态，还是会上下文阻塞 </span><br><span class="line">        + 多核cpu无锁才有优势</span><br><span class="line">    + 特点</span><br><span class="line">        + 线程少 + 多核cpu</span><br><span class="line">        + 体现乐观锁思想</span><br><span class="line">        + synchronize体现悲观锁思想</span><br><span class="line">        + cas体现无锁开发、无阻塞并发</span><br></pre></td></tr></table></figure><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><p>J.U.C 并发包提供了：</p><ul><li><p>AtomicBoolean</p></li><li><p>AtomicInteger</p></li><li><p>AtomicLong</p></li></ul><p>以 AtomicInteger 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 原子整数</span><br><span class="line">    + AtomicInteger 原子方法</span><br><span class="line">        + compareAndSet </span><br><span class="line">            + 配合while(true)</span><br><span class="line">        + 自增</span><br><span class="line">            + incrementAndGet()：++i</span><br><span class="line">            + getAndIncrement：i++</span><br><span class="line">            + decrementAndGet ...</span><br><span class="line">        + 加法</span><br><span class="line">            + getAndAdd() </span><br><span class="line">            + addAndGet()</span><br><span class="line">            + 这里没有将这些方法底层 底层还是循环获取最新值才能进行加法</span><br><span class="line">        + updateAndGet 表达式</span><br><span class="line">            + 参数：函数接口</span><br><span class="line">            + 原理</span><br><span class="line">                + 用do&#123;&#125;while()吧，源码也是用的do&#123;&#125;while()</span><br><span class="line">                + 通用封装</span><br><span class="line">                + 官方实现</span><br></pre></td></tr></table></figure><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>为什么需要原子引用类型？</p><ul><li><p>AtomicReference</p></li><li><p>AtomicMarkableReference</p></li><li><p>AtomicStampedReference</p></li></ul><p>有如下方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 原子引用</span><br><span class="line">    + AtomicReference</span><br><span class="line">        + 基本类型的赋值也是原子操作，但是要保证成员变量在线程之间的可见性，并且不使用synchronized这种重量级的互斥锁，就需要到atomic包下面的无锁操作</span><br><span class="line">        + bigdecimal</span><br><span class="line">        + 本来就没啥差，就是内部的value是引用类型了</span><br><span class="line">    + ABA问题</span><br><span class="line">        + 问到CAS必问ABA</span><br><span class="line">        + 无法判断是否被别人修改过，只能判断值相同</span><br><span class="line">        + 其他线程A-B-A ，值仍不变，但是修改过了</span><br><span class="line">    + AtomicStampedReference</span><br><span class="line">        + 比较值 + 版本号</span><br><span class="line">        + 维护版本号</span><br><span class="line">    + AtomicMarkableReference</span><br><span class="line">        + 只关心是否被更改过</span><br><span class="line">            + boolean记录</span><br><span class="line">        + 使用AtomicStampedReference也可以实现相同的效果</span><br><span class="line">        + 这其实还是为了解决ABA问题，就是打了一个标记。</span><br></pre></td></tr></table></figure><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 原子数组</span><br><span class="line">    + 不想改变引用本身，修改里面的元素，如数组</span><br><span class="line">    + 这里需要说一下，compareAndSet()的比较是通过引用地址比较的，之前是对String举例，String的不可变性导致了我们每次对String的更改也导致了引用的更改</span><br><span class="line">    + 测试</span><br><span class="line">        + 线程不安全</span><br><span class="line">    + 改为原子数组AtomicIntegerArray</span><br><span class="line">        + 线程安全</span><br></pre></td></tr></table></figure><h2 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 原子更新器</span><br><span class="line">    + 针对对象某个字段进行原子操作</span><br><span class="line">        + 必须volatile</span><br><span class="line">        + integer、long、reference等</span><br></pre></td></tr></table></figure><h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 原子累加器</span><br><span class="line">    + 性能比原子整数好</span><br><span class="line">    + 原子整数测试</span><br><span class="line">        + 200w次累加 57</span><br><span class="line">    + 原子累加器测试</span><br><span class="line">        + 200w次累加 24</span><br><span class="line">    + 原理</span><br><span class="line">        + 设置多个累加单元cell（不会超过cpu核心）</span><br><span class="line">        + 最后将结果汇总</span><br><span class="line">        + 操作不同累加单元cell，cas重试次数减少数</span><br></pre></td></tr></table></figure><h2 id="LongAdder原理"><a href="#LongAdder原理" class="headerlink" title="LongAdder原理"></a>LongAdder原理</h2><p>@sun.misc.Contended</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315224104497.png" alt="image-20220315224104497"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ LongAdder（原子累加器）原理</span><br><span class="line">    + cas锁</span><br><span class="line">        + cellsbusy</span><br><span class="line">            + cas加锁，防止扩容时，多个线程同时扩容</span><br><span class="line">        + 状态标记，用cas来保证原子更改状态</span><br><span class="line">        + 只有更改状态成功——获得锁</span><br><span class="line">            + 就是ReentransLock 使用 AQS 加锁过程</span><br><span class="line">            + 这个就是基本的操作系统实现锁的方式啊。。。</span><br><span class="line">    + 缓存行伪共享</span><br><span class="line">        + cell类</span><br><span class="line">            + contended，防止缓存行伪共享 </span><br><span class="line">        + cpu内存结构</span><br><span class="line">            + 缓存以缓存行为单位</span><br><span class="line">            + 缓存加入造成数据副本产生</span><br><span class="line">            + 保证数据一致性</span><br><span class="line">                + 一个核心对缓存数据更改，另一个核心缓存要失效</span><br><span class="line">            + 两个cell可以放进一个缓存行</span><br><span class="line">                + 对cell进行修改，导致其他核心的缓存行失效</span><br><span class="line">            + 解决</span><br><span class="line">                + 让cell存在于不同缓存行</span><br><span class="line">                + @sun.misc.Contended</span><br><span class="line">                    + 字段前后各加128字节大小的空隙</span><br><span class="line">                    + 保证将对象读到缓存，占用不同缓存行</span><br><span class="line">                    + 不会造成其他核心缓存行失效</span><br><span class="line">    + add</span><br><span class="line">        + 源码最重要</span><br><span class="line">    + LongAccumulate</span><br><span class="line">        + cells未创建</span><br><span class="line">        + cell未创建</span><br><span class="line">        + 逻辑性太强了</span><br><span class="line">        + cell已创建</span><br><span class="line">            + 重要的是要能串起来</span><br><span class="line">        + sum</span><br><span class="line">            + 累加单元求和</span><br></pre></td></tr></table></figure><h2 id="Unsafe对象"><a href="#Unsafe对象" class="headerlink" title="Unsafe对象"></a>Unsafe对象</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ unsafe对象</span><br><span class="line">    + 获取</span><br><span class="line">        + cas、park等都是调用unsafe中方法</span><br><span class="line">        + 反射获取对象</span><br><span class="line">    + cas相关方法</span><br><span class="line">        + cas操作，修改域值</span><br><span class="line">        + 有竞争，需要while重试</span><br><span class="line">    + 模拟实现原子整数</span><br><span class="line">        + AtomicInteger模拟实现</span><br><span class="line">            + 反射获取unsafe对象</span><br><span class="line">            + int成员变量，volatile</span><br><span class="line">                + 获取int偏移量，保护域变量</span><br><span class="line">            + get</span><br><span class="line">            + decrement</span><br><span class="line">                + 循环</span><br><span class="line">                + cas赋值</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ cas、volatile</span><br><span class="line">    + 无锁并发</span><br><span class="line">+ api</span><br><span class="line">    + 原子整数</span><br><span class="line">    + 原子引用</span><br><span class="line">    + 原子数组</span><br><span class="line">    + 字段更新器</span><br><span class="line">    + 原子累加器</span><br><span class="line">+ unsafe</span><br><span class="line">+ 原理</span><br><span class="line">    + LongAdder</span><br><span class="line">    + 伪共享 </span><br></pre></td></tr></table></figure><h1 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h1><h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>string</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315224233141.png" alt="image-20220315224233141"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 不可变对象</span><br><span class="line">    + 使用</span><br><span class="line">        + 不可变 日期时间类</span><br><span class="line">    + 设计</span><br><span class="line">        + string类</span><br><span class="line">            + final修饰，不可修改</span><br><span class="line">            + 保护性拷贝</span><br><span class="line">                + 通过创建副本对象，避免共享，线程安全</span><br></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315224255945.png" alt="image-20220315224255945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ 享元模式</span><br><span class="line">    + 定义和实现</span><br><span class="line">        + 对相同取值的对象进行共享，减少内存使用</span><br><span class="line">        + 体现</span><br><span class="line">            + 事先创建好256个long对象到缓存数组</span><br><span class="line">                + 不超过范围就重用，从数组中获取，避免对象重复创建</span><br><span class="line">            + byte、short、long、integer（上限可变）：-128-127</span><br><span class="line">            + char：0-127、boolean：true false</span><br><span class="line">            + string、bigdecimal</span><br><span class="line">    + 不可变线程安全辨析</span><br><span class="line">        + 就是因为是不可变类才可以用享元模式，不然一个可变的对象你咋能多个线程和变量共享而确定其值你是你需要的？</span><br><span class="line">        + 单个方法线程安全，但组合不一定是安全的，前面就讲过，说牵强的好好听课</span><br><span class="line">    + 自定义连接池</span><br><span class="line">        + 分析</span><br><span class="line">            + 连接池，重用</span><br><span class="line">            + 开发工程师？搬砖码农？</span><br><span class="line">        + 实现</span><br><span class="line">            + 属性、构造</span><br><span class="line">                + final size、数组、数组状态（原子）</span><br><span class="line">                + Integer只是调用单个方法线程安全,修改值之前需要查看状态是否为0然后置为1,这个时候就有可能有线程问题</span><br><span class="line">            + 方法</span><br><span class="line">                + 获取连接</span><br><span class="line">                    + 乐观锁，cas获取空闲连接</span><br><span class="line">                    + 无空闲连接，加锁，进入wait等待</span><br><span class="line">                + 归还连接</span><br><span class="line">                    + 直接修改状态（单线程）</span><br><span class="line">                    + 通知其他线程，notifyall</span><br><span class="line">        + 测试</span><br><span class="line">        + 总结</span><br><span class="line">            + 获取不到连接，wait</span><br><span class="line">                + 防止cpu空转获取</span><br><span class="line">                + 非短时间</span><br><span class="line">            + 优化</span><br><span class="line">                + 连接扩缩容</span><br><span class="line">                + 连接可用性检测</span><br><span class="line">                + 超时处理</span><br><span class="line">                + 分布式hash</span><br></pre></td></tr></table></figure><h2 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ final原理</span><br><span class="line">    + 设置final变量的原理</span><br><span class="line">        + 赋值final变量之后，加入写屏障</span><br><span class="line">            + 前面指令不会重排序到后面</span><br><span class="line">            + 前面变量操作同步到主存，可见性</span><br><span class="line">    + 获取final变量的原理</span><br><span class="line">        + 不加final共享堆空间，从堆中获取</span><br><span class="line">        + 加了复制到栈内存，或者使用常量池中的，用的是复制的</span><br><span class="line">            + 加快访问速度</span><br></pre></td></tr></table></figure><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 不可变：有成员，不可以改变</span><br><span class="line">+ 无状态：没有成员变量（状态信息），没有状态，更是线程安全的</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 不可变类使用</span><br><span class="line">+ 不可变类设计</span><br><span class="line">    + 保护性拷贝</span><br><span class="line">+ 原理</span><br><span class="line">    + final</span><br><span class="line">+ 模式</span><br><span class="line">    + 享元模式</span><br><span class="line">        + 重用对象，减少对内存的使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——共享模型之内存-JMM&amp;Volatile&amp;DCL</title>
      <link href="/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98-JMM&amp;%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92&amp;Volatile&amp;DCL/"/>
      <url>/2022/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98-JMM&amp;%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92&amp;Volatile&amp;DCL/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型-JMM"></a>Java内存模型-JMM</h2><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。</p><p>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul><li><p>可见性</p></li><li><p>一个线程对主存数据修改，对于另外一个线程不可见</p></li><li><p>问题</p><ul><li>初始状态，t线程从主存读取run到工作内存</li><li>因为t要频繁从主内存读取run<ul><li>JIT编译器将run的值存储在工作内存中，减少对主存run的访问<ul><li>CPU高速缓存</li></ul></li></ul></li><li>主线程修改run的值，同步到主存<ul><li>t一直从高速缓存中读</li></ul></li></ul></li><li><p>解决</p><ul><li><p>加上volatile修饰：易变</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130021025.png" alt="image-20220315130021025"></p><ul><li>只能修饰成员、静态成员变量<ul><li>必须从主存获取值</li></ul></li></ul></li><li><p>加上synchronize解决</p><ul><li>在Java内存模型中，synchronized规定，线程在加锁时， 先清空工作内存→在主内存中拷贝最新变量的副本到工作内存 →执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</li></ul></li></ul></li><li><p>可见性vs原子性</p><ul><li><p>不能防止指令交错，只能保证读到最新的值</p></li><li><p>synchronize保证原子性、可见性，重量级</p></li><li><p>volatile保证可见性，适合一个写一个读</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130104860.png" alt="image-20220315130104860"></p><ul><li>print里面有synchronized修饰</li></ul></li></ul></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><p>终止模式之两阶段终止模式</p><ul><li><p>原来用打断标记</p><ul><li>正常执行被打断<ul><li>设置打断标记为真<ul><li>不会进入catch，继续运行</li></ul></li></ul></li><li>sleep被打断<ul><li>进入catch，会清除打断标记<ul><li>重新设置打断标记为真</li></ul></li></ul></li></ul></li><li><p>用volatile改进，boolean是否运行</p><ul><li><p>vo 的使用 场景 就是 boolean 变量 可见性</p></li><li><p>不希望sleep，直接interrupt</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130122284.png" alt="image-20220315130122284"></p><ul><li>不需要重设打断等</li></ul></li></ul></li></ul></li><li><p>同步之Balking（犹豫模式）</p><ul><li><p>保证某个线程同时只能start一次，监控线程</p></li><li><p>标记：boolean变量，一执行改为true</p></li><li><p>原子性、可见性问题</p><ul><li><p>用synchronize加锁，存在读写操作</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130128605.png" alt="image-20220315130128605"></p></li></ul></li><li><p>应用</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130134816.png" alt="image-20220315130134816"></p><ul><li>实现线程安全的单例</li></ul></li></ul></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><ul><li><p>有序性</p><ul><li><p>指令重排</p></li><li><p>指令重排原理</p><ul><li><p>指令并行优化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130152912.png" alt="image-20220315130152912"></p><ul><li><p>同时执行不同指令</p></li><li><p>前提，不影响结果</p></li></ul></li></ul></li><li><p>问题</p><ul><li>num后执行</li></ul></li><li><p>验证</p><ul><li><p>压测验证</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130215855.png" alt="image-20220315130215855"></p></li><li><p>千万次测试，存在指令重排序</p></li></ul></li><li><p>禁用</p><ul><li>ready加上volatile，禁止重排序<ul><li>防止ready之前的代码重排序<ul><li>写屏障</li></ul></li></ul></li><li>volatile保证可见性、有序性</li></ul></li></ul></li></ul><h2 id="Volatile原理"><a href="#Volatile原理" class="headerlink" title="Volatile原理"></a>Volatile原理</h2><ul><li><p>volatile原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130225821.png" alt="image-20220315130225821"></p><ul><li><p>内存屏障</p><ul><li>变量写指令，后加入写屏障</li><li>变量读指令，前加入读屏障</li></ul></li><li><p>保证可见性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130549217.png" alt="image-20220315130549217"></p><ul><li>写操作时，volatile及以前的，都同步到主存</li><li>读操作时，volatile及以后的，对共享变量读取，加载主存</li></ul></li><li><p>保证有序性</p><ul><li><p>写屏障确保指令重排时，写屏障之前代码，不会重排到写屏障后</p></li><li><p>读屏障确保指令重排时，读屏障之后代码，不会重排到度屏障前</p></li><li><p>不能解决指令交错问题</p><ul><li>只能保证可见性和有序性<ul><li>写，之前更改到主存，不能重排到后面</li><li>读，之后读到最新，无法重排到前面</li></ul></li><li>synchronize都能做到，可见、有序、原子</li></ul></li></ul></li><li><p>dcl</p><ul><li><p>简介</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130257450.png" alt="image-20220315130257450"></p><ul><li><p>懒汉式，单例用到才创建</p><ul><li>balking</li><li>只有第一次需要线程保护。后面都是读操作</li></ul></li><li><p>两次检查上锁 </p><ul><li>只在第一次没创建时上锁（外层校验）</li><li>首次访问同步</li></ul></li><li><p>指令重排等问题</p><ul><li>学了多线程现在代码都不敢写了</li></ul></li></ul></li><li><p>问题分析</p><ul><li>synchronized无法禁止指令重排序，但可以保证有序性</li><li>synchronized能保证原子性、可见性和有序性，但不能禁止指令重排</li><li>指令重排，先给变量复制，还没来得及构造对象</li><li>其他线程判断变量不为空，拿到未初始化完毕的单例</li></ul></li><li><p>问题纠正</p><ul><li>think<ul><li>synchronized能保证只有一个线程执行临界区，且保证这个线程在临界区的有序性</li><li>synchronize不能阻止重排序，volatile才能</li><li>synchronized的有序性是建立在原子性的基础上，与volatile实现的有序性原理不同</li><li>因为synchronized修饰的代码块是单线程运行的，因此即使发生重排序也不会影响最终的结果，因此，synchronized是可以保证有序性的，但是保证有序性的方式和volatile不同。</li><li>synchronized不能防止指令重排序，但是重排序是不影响”单线程”的执行结果的，加上synchronized只有一个线程能进入执行指令，所以保证”多线程中的有序性”.</li><li>当前dcl例子中，对INSTANCE的“读取和写入”并没有在synchronized同步块内，不能保证同时只有一个线程执行，而写入的指令中又出现了重排序(写入和构造方法调用)，因此导致了这个问题。</li></ul></li><li>共享变量若完全给synchronize，即使有重排序，也不会有有序性问题</li><li>本例<strong>共享变量没有完全被synchronize保护</strong>，代码块外面还有使用</li><li>内部重排 + 共享变量外部引用 导致问题</li></ul></li><li><p>问题解决</p><ul><li><p>加上volatile</p><ul><li><p>阻止指令重排序</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130316484.png" alt="image-20220315130316484"></p></li><li><p>调用构造方法等指令，不能重排到赋值指令之后</p><ul><li>保证先构造再赋值</li></ul></li><li><p>其他线程读取指令时带读屏障，读取最新结果</p><ul><li><p>其实就是保证了每个线程遇到被volatile修饰的变量时都会从主存中重新获取该值</p></li><li><p>我觉得这里解决的是先调构造方法再赋值的指令顺序，而不是图上画的，因为这是2个线程的图，volatile是单线程指令排序，多线程可见性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130324230.png" alt="image-20220315130324230"></p></li></ul></li><li><p>解决dcl单例</p></li></ul></li></ul></li><li><p>happens-before规则</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220315130331914.png" alt="image-20220315130331914"></p><ul><li>这块和指令重排那块没有书上讲的好，最好看书</li><li>解锁可见</li><li>volatile可见</li><li>start前写</li><li>线程结束</li><li>打断之前对变量的写，可见</li><li>变量默认值的写</li><li>volatile变量前，其他变量的写，都同步到主存（写屏障）</li></ul></li><li><p>习题</p><ul><li>balking模式<ul><li>volatile情况<ul><li>一个线程写其他读</li><li>dcl 锁外，防止指令重排</li></ul></li></ul></li><li>线程安全单例1<ul><li>final<ul><li>防止子类继承这个单例类 然后重写方法</li></ul></li><li>防止反序列化破坏单例<ul><li>对，当用反序列化创建对象时，会调用readResovle()，因此我们直接给它重写，让它返回我们创建的对象就行了。</li><li>克隆、反射、反序列化都会破坏单例</li></ul></li><li>私有<ul><li>防止直接创建，不能防止反射</li></ul></li><li>初始化对象<ul><li>安全</li></ul></li><li>公共静态方法<ul><li>封装、改造、泛型等</li></ul></li></ul></li><li>线程安全单例<ul><li>枚举单例<ul><li>1、定义时有几个就有几个，静态成员变量</li><li>2、没有并发问题，类加载完成</li><li>3、不能反射破坏</li><li>4、可以防止</li><li>5、饿汉式</li><li>6、加到构造方法中</li></ul></li><li>懒汉式<ul><li>线程安全：类对象锁</li><li>效率低</li></ul></li><li>DCL单例<ul><li>只在创建时加锁，效率提高</li><li>防止第一并发访问，其他线程进入锁，再次创建</li><li>防止重排序</li></ul></li><li>静态内部类，懒汉式<ul><li>类加载是懒惰的</li><li>用getinstance时才触发类加载操作，初始化</li></ul></li><li>类加载由JVM保证线程安全</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>JMM<ul><li>可见性<ul><li>JVM缓存优化引起</li></ul></li><li>有序性<ul><li>JVM指令重排优化引起</li></ul></li><li>happens-before规则<ul><li>写读是否可见</li></ul></li></ul></li><li>原理<ul><li>CPU指令并行，重排序问题</li><li>volatile<ul><li>读写屏障</li></ul></li></ul></li><li>模式<ul><li>两阶段终止模式优化<ul><li>volatile改进</li></ul></li><li>同步模式之balking<ul><li>只执行一次情况<ul><li>监控线程启动</li><li>单例</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——共享模型之管程-Monitor&amp;ReentrantLock</title>
      <link href="/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B-Monitor&amp;ReentrantLock/"/>
      <url>/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B-Monitor&amp;ReentrantLock/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><h2 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h2><p>上下文切换问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234314311.png" alt="image-20220314234314311"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ 共享带来的问题</span><br><span class="line">+ 上下文切换分析</span><br><span class="line">    + 单线程</span><br><span class="line">    + 多线程情况</span><br><span class="line">        + 线程的 cpu 时间片用完 -&gt; 线程挂起，运行到就绪 -&gt; 线程上下文切换 -&gt; 字节码指令交错运行 -&gt; 共享变量counter读写冲突</span><br><span class="line">    + 根源：指令交错</span><br><span class="line">+ 临界区与竞态条件</span><br><span class="line">    + 临界区</span><br><span class="line">        + 存在对共享资源的多线程读写区域</span><br><span class="line">    + 竞态条件</span><br><span class="line">        + 结果无法预测</span><br><span class="line">+ 避免竞态条件</span><br><span class="line">    + 非阻塞式</span><br><span class="line">        + 原子变量</span><br><span class="line">    + 阻塞式</span><br><span class="line">        + synchronize、lock</span><br><span class="line">+ synchronize</span><br><span class="line">    + 对象锁</span><br><span class="line">        + 临界区代码变成串行</span><br><span class="line">        + 对象，多个线程共享</span><br><span class="line">    + 理解</span><br><span class="line">        + 比喻</span><br><span class="line">            + synchronize中即使时间片用完，下次获取时间片仍进入（上下文切换）</span><br><span class="line">                + 只有执行完其中代码，从synchronize出来解锁</span><br><span class="line">        + 时序图</span><br><span class="line">            + 执行中，若本线程上下文切换</span><br><span class="line">                + 其他线程获取锁被阻塞blocked</span><br><span class="line">                + 其他线程直接上下文切换，本线程继续执行</span><br><span class="line">            + 释放锁，唤醒阻塞线程</span><br><span class="line">        + 思考</span><br><span class="line">            + 利用对象锁保证临界区中代码的原子性</span><br><span class="line">                + 原子性：原子操作，不可分割</span><br><span class="line">    + 面向对象改进</span><br><span class="line">        + 互斥等逻辑封装在room类内部</span><br><span class="line">            + 对共享资源保护，由内部实现</span><br><span class="line">        + 对外调用即可</span><br><span class="line">    + synchronize加在方法上</span><br><span class="line">        + 成员方法上</span><br><span class="line">            + 相当于锁this对象</span><br><span class="line">        + static方法上</span><br><span class="line">            + 相当于锁类对象</span><br><span class="line">            + jvm中只有一个类对象，但是有多个实例对象。这就是区别</span><br><span class="line">        + 习题：线程八锁</span><br><span class="line">            + sleep即抱着锁睡觉</span><br><span class="line">            + 锁类对象只有一个</span><br></pre></td></tr></table></figure><h2 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234413264.png" alt="image-20220314234413264"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 变量的线程安全分析</span><br><span class="line">    + 成员变量、静态变量被共享</span><br><span class="line">        + 读操作，线程安全</span><br><span class="line">        + 读写操作，临界区，考虑线程安全</span><br><span class="line">    + 局部变量</span><br><span class="line">        + 局部变量在线程之内，不共享</span><br><span class="line">            + 线程安全</span><br><span class="line">        + 局部变量引用的对象，可能被共享</span><br><span class="line">            + 如果引用对象逃离方法的作用范围，考虑线程安全</span><br><span class="line">        + 暴露引用</span><br><span class="line">            + private、final，防止子类影响</span><br></pre></td></tr></table></figure><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234431459.png" alt="image-20220314234431459"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ 线程安全类</span><br><span class="line">    + 多个线程调用他们同一实例时是安全的</span><br><span class="line">        + hashtable put</span><br><span class="line">    + 多个方法组合不安全：非原子</span><br><span class="line">        + 还需在外部上锁</span><br><span class="line">    + 不可变类</span><br><span class="line">    + 直接创建新的实例，不在原有实例上改变</span><br><span class="line">        + 线程安全</span><br><span class="line">    + 实例分析</span><br><span class="line">        + final：对象的引用不可变不代表对象的状态不可变</span><br><span class="line">        + 还可以使用ThreadLocal给每个线程存储一个私有start变量</span><br><span class="line">        + 我觉得主要还是看变量是否1、能逃离，2、共享</span><br><span class="line">        + 先看有木有多个线程同时访问共享变量，再看该共享变量是否可被修改</span><br><span class="line">        + 逃逸分析，要符合闭合原则</span><br><span class="line">+ 习题</span><br><span class="line">    + 售票</span><br><span class="line">        + sell读写操作，不安全</span><br><span class="line">        + add线程安全，有synchronize</span><br><span class="line">        + sell和add</span><br><span class="line">            + 安全， 不是同一共享变量</span><br><span class="line">            + 概括来说就是：下边的原子操作不依赖上边原子操作的结果的话，就不用考虑两个原子操作合在一起的安全性</span><br><span class="line">        + threadlist安全，不被多个线程共享</span><br><span class="line">        + sell加锁</span><br><span class="line">            + 保证原子性</span><br><span class="line">    + 转账</span><br><span class="line">        + 加锁：类对象</span><br></pre></td></tr></table></figure><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>加锁实现原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234449143.png" alt="image-20220314234449143"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 对象头</span><br><span class="line">    + klass word</span><br><span class="line">        + 找到的类对象</span><br><span class="line">    + mark word</span><br><span class="line">+ monitor（锁）</span><br><span class="line">    + 加锁实现原理</span><br><span class="line">        + 对象与monitor相关联</span><br><span class="line">        + 每个synchronize(obj)对象关联一个monitor</span><br><span class="line">            + 只能有一个owner</span><br><span class="line">        + 其他线程执行synchronize（obj）</span><br><span class="line">            + 进入entrylist blocked</span><br><span class="line">        + 执行完同步代码块内容</span><br><span class="line">            + 唤醒entrylist中等待线程</span><br><span class="line">            + 线程相互竞争owner</span><br><span class="line">    + 原理（字节码）</span><br><span class="line">        + 如果出现异常，帮我们正确解锁</span><br><span class="line">            + 重置mark word，唤醒entrylist</span><br><span class="line">            + 抛出异常</span><br></pre></td></tr></table></figure><h2 id="synchronize优化原理"><a href="#synchronize优化原理" class="headerlink" title="synchronize优化原理"></a>synchronize优化原理</h2><p>对象头格式：正常、偏向锁、轻量级锁、重量级锁、GC</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234523762.png" alt="image-20220314234523762"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">+ synchronize优化原理</span><br><span class="line">    + 小故事</span><br><span class="line">    + 轻量级锁</span><br><span class="line">        + 创建锁记录（Lock Record）对象</span><br><span class="line">            + 线程栈帧中包含锁的结构</span><br><span class="line">        + 锁记录中object reference指向锁对象</span><br><span class="line">            + 用cas替换lock record和锁的mark word</span><br><span class="line">                + 用于解锁的恢复和锁记录地址</span><br><span class="line">        + cas替换成功</span><br><span class="line">            + 锁中存储了锁记录地址（哪个线程）和轻量级锁</span><br><span class="line">            + 表示该线程给对象加锁</span><br><span class="line">        + cas替换失败</span><br><span class="line">            + 如果其他线程持有了该obj的轻量级锁</span><br><span class="line">                + 进入锁膨胀过程</span><br><span class="line">            + 如果自己synchronize锁重入</span><br><span class="line">                + 添加lock record，知道是自己线程的锁，作为重入的计数</span><br><span class="line">        + 解锁时如果取值为null，表示锁重入，清除锁记录</span><br><span class="line">        + 解锁时如果取值不为null</span><br><span class="line">            + cas将mark word恢复给锁对象头</span><br><span class="line">                + 变为无锁状态</span><br><span class="line">            + 成功，解锁成功</span><br><span class="line">            + 失败</span><br><span class="line">                + 说明轻量级锁进入了锁膨胀或一级升级为重量级锁</span><br><span class="line">                + 进入重量级锁解锁流程</span><br><span class="line">    + 锁膨胀</span><br><span class="line">        + 将轻量级锁升级为重量级锁</span><br><span class="line">        + 流程</span><br><span class="line">            + 为object对象申请monitor锁</span><br><span class="line">                + mark word指向重量级锁地址，后两位10</span><br><span class="line">            + 其他线程进入monitor的entrylist阻塞</span><br><span class="line">            + 线程执行完，解锁</span><br><span class="line">                + cas将mark word恢复，失败</span><br><span class="line">                + 进入重量级解锁流程</span><br><span class="line">                    + 根据对象头找到monitor</span><br><span class="line">                    + 设置owner为null</span><br><span class="line">                    + 唤醒entrylist</span><br><span class="line">    + 自旋优化</span><br><span class="line">        + 重量级锁竞争时，自旋优化（重试）</span><br><span class="line">            + 减少阻塞发生</span><br><span class="line">                + 阻塞要进行上下文切换</span><br><span class="line">        + 自旋失败，进入阻塞</span><br><span class="line">        + 自旋锁是自适应的，正反馈调节</span><br><span class="line">        + java7以后无法控制是否开启自旋</span><br><span class="line">    + 偏向锁</span><br><span class="line">        + 轻量级锁，锁重入时仍需CAS操作</span><br><span class="line">            + 每一次都要cas操作（翻书包）</span><br><span class="line">        + 偏向锁（刻名字）</span><br><span class="line">            + 第一次cas时将Thread id设置到锁对象头</span><br><span class="line">                + 重入时判断为本线程，无需cas</span><br><span class="line">        + 偏向状态</span><br><span class="line">            + 默认开启偏向锁，mark word中biased_lock为1</span><br><span class="line">                + 默认延迟开启</span><br><span class="line">            + 获取锁对象</span><br><span class="line">                + 设置线程id到锁的mark word</span><br><span class="line">            + synchronize结束后</span><br><span class="line">                + 锁的mark word不变</span><br><span class="line">            + 其他线程获取锁对象</span><br><span class="line">                + 撤销偏向锁，变成轻量级锁</span><br><span class="line">                    + 竞争</span><br><span class="line">                        + 膨胀变成重量级锁</span><br><span class="line">            + 使用偏向锁之前获取hashcode</span><br><span class="line">                + 会禁用偏向锁</span><br><span class="line">                + 哈希码用的时候才产生，填到mark word中</span><br><span class="line">                    + 轻量级锁hashcode存在线程栈帧的锁记录里</span><br><span class="line">                    + 重量级锁hashcode存在monitor对象里</span><br><span class="line">                    + 解锁时都会还原回来</span><br><span class="line">                + 偏向锁没有存储的地方</span><br><span class="line">        + 撤销</span><br><span class="line">            + 调用hashcode</span><br><span class="line">            + 其他线程使用对象</span><br><span class="line">                + 偏向锁升级为轻量级锁</span><br><span class="line">                    + 测试</span><br><span class="line">                        + 轻量级锁、偏向锁前提</span><br><span class="line">                            + 线程错开，否则升级重量级锁</span><br><span class="line">                            + wait会释放CPU和锁资源</span><br><span class="line">                + 多个线程获取偏向锁</span><br><span class="line">                    + 撤销偏向锁</span><br><span class="line">            + 调用wait/notify</span><br><span class="line">                + wait/notify只有重量级锁有</span><br><span class="line">                    + 自动升级为重量级锁</span><br><span class="line">        + 批量重偏向</span><br><span class="line">            + 虽然被多个线程访问，没有竞争</span><br><span class="line">                + 让偏向锁重新偏向，而不升级轻量级锁</span><br><span class="line">            + 撤销偏向次数过多：超过20次</span><br><span class="line">                + 重新偏向新线程</span><br><span class="line">            + 总结就是没超过阈值，先把偏向锁变成轻量锁，然后再偏向锁</span><br><span class="line">        + 批量撤销</span><br><span class="line">            + 撤销偏向次数过多：超过40次</span><br><span class="line">                + 整个类所有对象不可偏向</span><br><span class="line">            + 测试</span><br><span class="line">                + t1 </span><br><span class="line">                    + 39个偏向t1（偏向锁）</span><br><span class="line">                +t2 </span><br><span class="line">                    + 前19个撤销，变成轻量级锁，解锁不可偏向，（轻量级锁）</span><br><span class="line">                    + 19以后批量重偏向优化，重新偏向于t2，（偏向锁）</span><br><span class="line">                + t3</span><br><span class="line">                    + 前19个撤销，不可偏向</span><br><span class="line">                        + t3前19个已被t2设为不可偏向，为轻量级锁</span><br><span class="line">                        + t3前十九个已经被t2设置为不可偏向锁，故t3初始为不可偏向锁，加锁成为轻量级锁</span><br><span class="line">                        + T2前十九个没有重偏向，解锁后就变为不可偏向，后二十是偏向t2</span><br><span class="line">                    + 19以后，</span><br><span class="line">                        + 原本偏向t2线程</span><br><span class="line">                        + 被撤销，升级为轻量级锁</span><br><span class="line">                        + 解锁之后不可偏向</span><br><span class="line">                        + 重偏向是针对单个线程来讲的，一个线程撤销20个锁才进行重偏向，这时另一个线程还是要撤销20个</span><br><span class="line">                        + t1:全部偏向t1；t2:一半撤销t1的偏向锁，一半偏向t2；t3:一半轻量级锁，一半撤销t2的偏向锁；总共撤销了20次t1的偏向锁，20次t2的偏向锁</span><br><span class="line">                        + 批量重偏向和批量撤销是针对类的优化，和对象无关。偏向锁重偏向一次之后不可再次重偏向。当某个类已经触发批量撤销机制后，JVM会默认当前类产生了严重的问题，剥夺了该类的新实例对象使用偏向锁的权利</span><br><span class="line">        + 锁消除</span><br><span class="line">            + JIT优化</span><br><span class="line">                + 分析局部变量，synchronize中不会被共享</span><br><span class="line">                + 把synchronize优化掉</span><br></pre></td></tr></table></figure><h2 id="wait、notify"><a href="#wait、notify" class="headerlink" title="wait、notify"></a>wait、notify</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234608743.png" alt="image-20220314234608743"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+ wait、notify</span><br><span class="line">    + 为什么需要wait</span><br><span class="line">        + 进入休息室wait</span><br><span class="line">        + 烟到了notify，唤醒wait线程</span><br><span class="line">    + 工作原理</span><br><span class="line">        + owner线程发现条件不满足，放弃锁</span><br><span class="line">            + 调用wait方法进入waitset</span><br><span class="line">                + WAITING：没有时限</span><br><span class="line">        + blocked和waiting都处于阻塞</span><br><span class="line">            + 不占用cpu时间片</span><br><span class="line">        + owner调用notify或者notifyall唤醒</span><br><span class="line">            + 进入entrylist重新竞争</span><br><span class="line">    + api</span><br><span class="line">        + 都需要获得锁成为owner才能调用</span><br><span class="line">        + 同步代码块中</span><br><span class="line">        + notify挑一个唤醒</span><br><span class="line">        + 有参wait</span><br><span class="line">            + 最大时限等待</span><br><span class="line">    + sleep 和 wait</span><br><span class="line">        + sleep是thread方法，wait是object所有对象方法</span><br><span class="line">        + sleep不需要和synchronize使用，wait需要获取锁</span><br><span class="line">        + sleep睡眠不会释放锁，wait等待时会释放锁</span><br><span class="line">    + wait和notify使用</span><br><span class="line">        + wait时其他线程可以继续工作</span><br><span class="line">        + notify错误唤醒：虚假唤醒</span><br><span class="line">            + notifyall全部唤醒</span><br><span class="line">                + 指定的话，用park，unpark</span><br><span class="line">            + notifyall + while</span><br><span class="line">                + if条件改为while，</span><br><span class="line">                + 只有条件正确才能唤醒出循环</span><br><span class="line">        + 正确使用</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>保护性暂停</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234708945.png" alt="image-20220314234708945"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ 设计模式：同步模式之保护性暂停</span><br><span class="line">    + 定义</span><br><span class="line">        + 一个线程等待另一个线程执行结果</span><br><span class="line">            + 一个结果从一个线程传递到另一个线程，关联同一个GuardedObject</span><br><span class="line">            + 结果不断传输，需要消息队列（生产者、消费者）</span><br><span class="line">            + join、future实现，采用保护性暂停</span><br><span class="line">            + 等待结果，同步模式</span><br><span class="line">    + 实现</span><br><span class="line">        + guardedobject</span><br><span class="line">        + 优点</span><br><span class="line">            + 相比join，不需要等线程结束，线程还可以继续运行</span><br><span class="line">            + 等待结果变量无需设置全局，直接获取</span><br><span class="line">    + 拓展-增加超时</span><br><span class="line">        + wait time</span><br><span class="line">        + 测试</span><br><span class="line">    + join原理</span><br><span class="line">        + 记录经历时间，等待</span><br><span class="line">            + 保护性暂停</span><br><span class="line">    + 拓展-解耦等待和生产</span><br><span class="line">        + 解耦，生产者和消费者</span><br><span class="line">        + 维护一个集合，guardedobject有唯一id</span><br><span class="line">        + 实现</span><br><span class="line">            + mailbox</span><br><span class="line">                + 线程安全的map hashtable</span><br><span class="line">                + 自增id方法加锁</span><br><span class="line">                + 获取完邮件直接删除，所以remove</span><br><span class="line">            + postman、people</span><br><span class="line">                + 继承Thread</span><br><span class="line">                + people</span><br><span class="line">                + postman</span><br><span class="line">        + 测试</span><br><span class="line">            + //确保生成居民先于快递员,但是快递员发信要早于居民收信</span><br><span class="line">            + 解耦了生产者和消费者</span><br><span class="line">            + 生产者和消费者必须一一对应</span><br></pre></td></tr></table></figure><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>生产者消费者-消息队列</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234728830.png" alt="image-20220314234728830"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ 异步模式之生产者消费者</span><br><span class="line">    + 定义</span><br><span class="line">        + 不需要生产者和消费者一一对应</span><br><span class="line">        + 消息队列</span><br><span class="line">            + 有容量限制</span><br><span class="line">            + 各种阻塞队列，就是这种模式</span><br><span class="line">        + 异步模式</span><br><span class="line">            + 等待通知 同步，等待需要 通知 之后的结果</span><br><span class="line">    + 实现</span><br><span class="line">        + message</span><br><span class="line">        + messageQueue</span><br><span class="line">            + LinkedList 双向队列</span><br><span class="line">            + 获取消息</span><br><span class="line">                + 队列为空wait等待</span><br><span class="line">                + 不为空，取出队列头部消息</span><br><span class="line">                this的话锁粒度太大了，直接就相当于单线程操作了……</span><br><span class="line">                + 取完消息，notify唤醒生产者，队列不满</span><br><span class="line">            + 存入消息</span><br><span class="line">                + 判断队列否已满</span><br><span class="line">                    + 生产者wait等待</span><br><span class="line">                + 尾部加入消息</span><br><span class="line">                + notify唤醒消费者，接收消息</span><br><span class="line">    + 测试</span><br><span class="line">        + 生产者</span><br><span class="line">        + 消费者</span><br></pre></td></tr></table></figure><h2 id="Park-amp-unpark"><a href="#Park-amp-unpark" class="headerlink" title="Park&amp;unpark"></a>Park&amp;unpark</h2><p>先调用unpark原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234756570.png" alt="image-20220314234756570"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ park&amp;unpark</span><br><span class="line">    + 基本使用</span><br><span class="line">        + 暂停当前线程</span><br><span class="line">        + wait状态，无时限等待</span><br><span class="line">        + 若先调用unpark</span><br><span class="line">            + 无法park住</span><br><span class="line">        + 特点</span><br><span class="line">            + 无需配置monitor</span><br><span class="line">            + 以线程为单位阻塞、唤醒线程，精准唤醒</span><br><span class="line">            + 可以先unpark</span><br><span class="line">    + 原理</span><br><span class="line">        + 每个线程都有parker对象（背包）</span><br><span class="line">            + counter（0、1）</span><br><span class="line">                + 干粮</span><br><span class="line">            + cond</span><br><span class="line">                + 帐篷</span><br><span class="line">            + mutex</span><br><span class="line">        + unpark：令干粮充足</span><br><span class="line">        + 调用park</span><br><span class="line">        + 调用unpark</span><br><span class="line">        + 先调用unpark</span><br><span class="line">        + 说白了就是当count为0时调用park才会停</span><br><span class="line">        + 总结</span><br><span class="line">            + park消费counter</span><br><span class="line">                + 若无counter进入cond，counter为0</span><br><span class="line">                    + 若unpark，counter为1</span><br><span class="line">                        + 唤醒cond中线程，消费counter为0，继续运行 </span><br><span class="line">                + 若有counter，counter为0，继续运行</span><br></pre></td></tr></table></figure><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p>线程状态</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234813808.png" alt="image-20220314234813808"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ 线程状态转换</span><br><span class="line"></span><br><span class="line">    + new</span><br><span class="line">        + 创建java对象，还没和操作系统线程对象关联</span><br><span class="line">    + runnable</span><br><span class="line">        + 关联操作系统线程，cpu调度执行</span><br><span class="line">        + 包括是否被cpu调度</span><br><span class="line">        + 调用操作系统阻塞io相关的api，java层面都是runnable</span><br><span class="line">    + runnable和waiting</span><br><span class="line">        + 使用synchronize获取对象锁后，wait()，进入waitset</span><br><span class="line">            + notify、interrupt，进入entryset()</span><br><span class="line">                + 竞争锁成功，runnable</span><br><span class="line">                + 竞争锁失败，blocked</span><br><span class="line">        + 调用t线程的join()，当前线程变成waiting</span><br><span class="line">            + t线程结束、当前线程interrupt，变成runnable</span><br><span class="line">        + park</span><br><span class="line">            + unpark、interrupt</span><br><span class="line">    + runnable和timed_waiting（有时限waiting）</span><br><span class="line">        + 获取了synchronize对象锁之后，wait(n)</span><br><span class="line">            + 等待超时、notify、interrupt，进入entryset</span><br><span class="line">                + 竞争锁成功，runnable</span><br><span class="line">                + 竞争锁失败，blocked</span><br><span class="line">        + join(n)</span><br><span class="line">            + 等待超时、运行结束、interrupt，runnable</span><br><span class="line">        + parkNacos(n)、parkUntil(n)</span><br><span class="line">            + 超时、unpark、interrupt，runnable</span><br><span class="line">        + sleep(n)</span><br><span class="line">            + 超时，runnable</span><br><span class="line">    + runnable和blocked</span><br><span class="line">        + 竞争锁失败，blocked</span><br><span class="line">        + 竞争锁成功，runnable</span><br><span class="line">    + terminated</span><br><span class="line">        + 当前线程所有代码执行完毕</span><br></pre></td></tr></table></figure><h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p>JUC-可重入锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314234844081.png" alt="image-20220314234844081"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">+ 多把锁</span><br><span class="line">    + 一把锁，并发度低</span><br><span class="line">        + 粒度细分，准备多个对象锁</span><br><span class="line">        + 业务不能有关联</span><br><span class="line">        + 增加并发度</span><br><span class="line">        + 可能造成死锁</span><br><span class="line">    + 活跃性</span><br><span class="line">        + 死锁现象</span><br><span class="line">            + 一个线程需要同时获取多把锁</span><br><span class="line">                + 都在等待对方释放锁</span><br><span class="line">        + 定位死锁</span><br><span class="line">            + jconsole、jstack</span><br><span class="line">        + 哲学家就餐问题</span><br><span class="line">        + 活锁</span><br><span class="line">            + 两个线程互相改变，无法达到结束条件</span><br><span class="line">                + 没有阻塞</span><br><span class="line">            + 执行时间交错开，随机睡眠时间</span><br><span class="line">        + 饥饿</span><br><span class="line">            + 线程优先级太低，始终无法得到cpu调度</span><br><span class="line">            + 顺序加锁的解决方案，都按A、B顺序加锁</span><br><span class="line">                + 产生饥饿问题</span><br><span class="line">                + 在争夺左筷子（最外层锁）中，苏和阿同时争夺c1,所以概率倒数，在 第二轮争夺右筷子时，c5没有人跟赫争，故赫能吃到饭的概率最高</span><br><span class="line">    + ReentrantLock 可重入锁</span><br><span class="line">        + 特点</span><br><span class="line">            + 可中断（破坏锁）</span><br><span class="line">            + 可设置超时时间（争抢锁）</span><br><span class="line">            + 可设置为公平锁（block先进先出）</span><br><span class="line">            + 支持多个条件变量（不同条件对应多个waitset，精准唤醒）</span><br><span class="line">            + 与synchronize一样，支持可重入（同一个线程可以重复获取锁）</span><br><span class="line">        + 可重入</span><br><span class="line">            + 同一个线程获取锁后，可再次获取锁（lock多次）</span><br><span class="line">        + 可打断</span><br><span class="line">            + 等待锁过程中，可以被interrupt打断终止等待</span><br><span class="line">            + lockInterruptibly方法获取锁（lock无法打断等待）</span><br><span class="line">                + 其他线程interrupt()打断</span><br><span class="line">                + 捕捉到InterruptException异常</span><br><span class="line">                + 直接返回</span><br><span class="line">            + 被动，避免死等</span><br><span class="line">        + 锁超时</span><br><span class="line">            + 主动，设置超时避免死等</span><br><span class="line">            + trylock()，尝试获得锁，返回布尔值</span><br><span class="line">                + 获取不到锁直接返回</span><br><span class="line">                + 返回为真，获得到了锁，向下执行代码</span><br><span class="line">            + trylock()带参数</span><br><span class="line">                + 等待获取锁时间，超时返回false</span><br><span class="line">                + 可被打断，进入打断异常，直接返回</span><br><span class="line">            + 解决哲学家就餐</span><br><span class="line">                + 筷子继承可重入锁</span><br><span class="line">                + trylock()</span><br><span class="line">                + 拿不到锁就结束，释放所有锁</span><br><span class="line">                    + 左手拿不到继续获取，右手拿不到，释放左手锁</span><br><span class="line">        + 公平锁</span><br><span class="line">            + 默认不公平</span><br><span class="line">            + 公平锁：先入先得锁</span><br><span class="line">                + 为了解决饥饿问题</span><br><span class="line">                    + trylock也可以解决</span><br><span class="line">                + 没有必要，降低并发度</span><br><span class="line">            + 非公平锁：没进入等待队列也有机会获得锁</span><br><span class="line">        + 条件变量</span><br><span class="line">            + 支持多个条件变量（休息室），可以精准唤醒</span><br><span class="line">            + 操作</span><br><span class="line">                + 创建条件变量（休息室）</span><br><span class="line">                + 指定条件变量执行await，等待</span><br><span class="line">                    + 时间参数</span><br><span class="line">                + 指定条件变量执行signal，唤醒</span><br><span class="line">                    + 唤醒之后重新竞争lock锁</span><br><span class="line">            + 使用</span><br><span class="line">            + 不看源码，自己把源码敲了一遍，的确有些自己一直没注意到的地方</span><br></pre></td></tr></table></figure><h2 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ 同步模式之顺序控制（控制线程的运行顺序）</span><br><span class="line">    + 固定运行顺序（先执行2，后执行1）</span><br><span class="line">        + wait&amp;notify</span><br><span class="line">            + while条件判断 + wait、notify</span><br><span class="line">        + await&amp;signal</span><br><span class="line">        + join()</span><br><span class="line">        + park&amp;unpark</span><br><span class="line">            + 精准暂停，唤醒</span><br><span class="line">                + 背包干粮</span><br><span class="line">            + 若t2先运行，t1可正常继续执行</span><br><span class="line">    + 交替输出（按abc顺序交替输出）</span><br><span class="line">        + wait&amp;notify</span><br><span class="line">            + 等待标记：用整数1、2、3标记条件，代表某个数字允许打印</span><br><span class="line">                + 面向对象code，很强</span><br><span class="line">        + await&amp;signal</span><br><span class="line">            + 三个不同休息室（条件变量）</span><br><span class="line">                + 进入当前休息室</span><br><span class="line">                + 打印</span><br><span class="line">                + 唤醒下一间休息室</span><br><span class="line">            + 执行流程</span><br><span class="line">                + 不管谁抢到锁，都进入休息室</span><br><span class="line">                + 只有a休息室解锁，a打印，解锁b休息室</span><br><span class="line">                + 只有b会继续运行，打印，解锁c</span><br><span class="line">            + 之前已经说过了，可以先唤醒，后等待，不存在全部等待的问题</span><br><span class="line">        + park&amp;unpark</span><br><span class="line">            + 以线程为单位停止、恢复</span><br><span class="line">                + 我一直以为我很懂面向对象，写的太烂了</span><br><span class="line">            + 面向对象编程，确实牛逼</span><br><span class="line">            + 流程</span><br><span class="line">                + 无论谁抢到时间片，全部线程park</span><br><span class="line">                + 主线程唤醒t1，t1线程打印，唤醒t2</span><br><span class="line">                + t2打印，唤醒t3</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ 知识点</span><br><span class="line">    + 共享资源、临界区</span><br><span class="line">    + synchronize</span><br><span class="line">        + 保证临界区代码线程安全</span><br><span class="line">            + 原子性</span><br><span class="line">            + 不至于上下文切换产生交错</span><br><span class="line">        + 锁对象语法</span><br><span class="line">        + 成员、静态方法</span><br><span class="line">        + wait、notify同步方法</span><br><span class="line">            + 条件不满足等待，条件满足恢复运行</span><br><span class="line">    + reentrantlock</span><br><span class="line">        + 可打断、锁超时trylock、公平锁、条件变量</span><br><span class="line">    + 分析变量线程安全性，常见线程安全类</span><br><span class="line">    + 线程活跃性</span><br><span class="line">        + 死锁、活锁、饥饿</span><br><span class="line">+ 应用</span><br><span class="line">    + 互斥</span><br><span class="line">        + synchronize和lock共享资源互斥</span><br><span class="line">    + 同步</span><br><span class="line">        + wait/notify、await/signal线程间通信效果</span><br><span class="line">+ 原理</span><br><span class="line">    + monitor、synchronize、wait/notify</span><br><span class="line">    + synchronize</span><br><span class="line">        + 轻量级锁、偏向锁、重量级锁</span><br><span class="line">        + 锁膨胀、锁消除等</span><br><span class="line">    + park&amp;unpark</span><br><span class="line">    + synchronize实现monitor，JVM层面，c++</span><br><span class="line">    + lock实现monitor，java级别</span><br><span class="line">+ 设计模式</span><br><span class="line">    + 同步模式之保护性暂停</span><br><span class="line">        + 线程之间获得结果，一一对应</span><br><span class="line">    + 异步模式之生产者消费者</span><br><span class="line">        + 生产消费不是一一对应关系</span><br><span class="line">    + 同步模式之顺序控制</span><br><span class="line">        + 控制线程执行先后次序、交替运行</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与高并发——线程原理&amp;栈帧&amp;两阶段终止模式</title>
      <link href="/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86&amp;%E6%A0%88%E5%B8%A7&amp;%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86&amp;%E6%A0%88%E5%B8%A7&amp;%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 进程</span><br><span class="line">    + 加载指令、管理内存、管理io</span><br><span class="line">    + 程序的一个实例</span><br><span class="line">    + java中资源分配的最小单位</span><br><span class="line">+ 线程</span><br><span class="line">    + 一个指令流</span><br><span class="line">    + 一个进程内多个线程</span><br><span class="line">    + java中最小调度单位</span><br><span class="line">+ 对比</span><br><span class="line">    + 进程基本相互独立，线程存在于进程中</span><br><span class="line">    + 进程通信复杂</span><br><span class="line">        + 不同计算机进程通信，http协议等</span><br><span class="line">    + 线程通信简单</span><br><span class="line">        + 共享进程内的内存，数据</span><br><span class="line">    + 线程上下文切换成本低</span><br></pre></td></tr></table></figure><h2 id="并行并发的概念"><a href="#并行并发的概念" class="headerlink" title="并行并发的概念"></a>并行并发的概念</h2><p>并发</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230324615.png" alt="并发"></p><p>并行</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230509268.png" alt="并行"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)</span><br><span class="line">并行： 单位时间内，多个任务同时执行</span><br><span class="line">+ 并发</span><br><span class="line">    + 同一时间线程轮流使用cpu</span><br><span class="line">        + concurrent</span><br><span class="line">    + 单核cpu下</span><br><span class="line">        + 实际串行执行</span><br><span class="line">        + cpu时间片轮流执行</span><br><span class="line">        + 宏观上并行</span><br><span class="line">+ 并行</span><br><span class="line">    + 多核cpu下</span><br><span class="line">        + 每个核同时调度运行线程</span><br><span class="line">+ 并发和并行都有</span><br><span class="line">    + 并发：同一时间应对多件事</span><br><span class="line">    + 并行：同一时间动手做多件事</span><br></pre></td></tr></table></figure><h2 id="线程应用"><a href="#线程应用" class="headerlink" title="线程应用"></a>线程应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 异步async</span><br><span class="line">    + 不需要等待结果返回，继续运行</span><br><span class="line">    + 特点</span><br><span class="line">    + 线程不同</span><br><span class="line">        + 避免阻塞主线程</span><br><span class="line">        + 提高吞吐量</span><br><span class="line">+ 提高效率</span><br><span class="line">+ 分布式的远程调用一般都是异步调，节省总响应时间</span><br><span class="line">    + 取决最长时间</span><br><span class="line">    + 多核下</span><br><span class="line">        + 任务拆分、并行执行</span><br><span class="line">    + 非阻塞io和异步io优化</span><br></pre></td></tr></table></figure><h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 创建和运行线程</span><br><span class="line">+ 1、直接使用Thread</span><br><span class="line">    + 2、使用Runnable配合Thread</span><br><span class="line">        + 把线程和任务分</span><br><span class="line">    + lambda简化</span><br><span class="line">        + idea智能替换</span><br><span class="line">            + 能简化的，idea会有灰色提示</span><br><span class="line">    + 方法1、2</span><br><span class="line">        + 走的都是run()方法</span><br><span class="line">        + runnable与线程池等配合</span><br><span class="line">        + 脱离任务和线程继承体系</span><br><span class="line">    + 3、FutureTask配合Thread</span><br><span class="line">        + 可以返回任务执行结果</span><br><span class="line">            + return + get</span><br><span class="line">        + 参数：泛型 + callable接口</span><br><span class="line">        + get()</span><br><span class="line">            + 阻塞等待结果返回</span><br></pre></td></tr></table></figure><h2 id="线程运行"><a href="#线程运行" class="headerlink" title="线程运行"></a>线程运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 线程运行</span><br><span class="line">    + 现象</span><br><span class="line">+ 查看和杀死</span><br><span class="line">        + windows</span><br><span class="line">        + linux</span><br><span class="line">        + jconsole</span><br></pre></td></tr></table></figure><h2 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h2><p>栈帧图解</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230549515.png" alt="栈帧原理"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ 线程运行原理</span><br><span class="line">    + 栈与栈帧</span><br><span class="line">        + 栈帧Frame</span><br><span class="line">            + 线程中方法的调用</span><br><span class="line">        + 栈帧图解</span><br><span class="line">            + 程序运行</span><br><span class="line">                + 类加载</span><br><span class="line">                + 启动主线程，栈内存</span><br><span class="line">                    + 执行main方法，分配栈帧内存</span><br><span class="line">                        + 局部变量表（args、变量）</span><br><span class="line">                        + 返回地址</span><br><span class="line">                    + 执行method1，分配栈帧内存</span><br><span class="line">                    + 执行method2，分配栈帧内存 </span><br><span class="line">                        + 堆中创建对象</span><br><span class="line">                    + 执行完毕，释放栈帧内存</span><br><span class="line">        + 多线程情况</span><br><span class="line">            + 断点模式</span><br><span class="line">                + 可以控制每个线程前进</span><br><span class="line">            + 线程栈之间独立，独立的栈内存</span><br><span class="line">    + 线程上下文切换</span><br><span class="line">        + cpu转去执行另一个线程</span><br><span class="line">        + 切换产生原因</span><br><span class="line">            + cpu时间片用完</span><br><span class="line">            + 垃圾回收</span><br><span class="line">            + 更高优先级线程</span><br><span class="line">            + 线程调用一些方法</span><br><span class="line">        + 记录当前线程状态</span><br><span class="line">            + 程序计数器</span><br><span class="line">            + 栈帧信息、局部变量、返回地址等</span><br><span class="line">        + 频繁上下文切换影响性能</span><br></pre></td></tr></table></figure><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+ 线程常见方法</span><br><span class="line">    + start()</span><br><span class="line">        + 线程进入就绪状态</span><br><span class="line">    + run()</span><br><span class="line">        + 线程启动后调用</span><br><span class="line">    + join()</span><br><span class="line">        + 等待线程运行结束</span><br><span class="line">        + 超时时间</span><br><span class="line">    ...</span><br><span class="line">+ start 和 run</span><br><span class="line">    + 调用run()只是普通调用方法</span><br><span class="line">    + 未创建线程</span><br><span class="line">    + 而run真正的意义是当线程start进入就绪态后被调度获得时间片时执行run方法由就绪态进入运行态</span><br><span class="line">    + 这里感觉t1.start()方法后加个t1.join（）保证t1线程执行完才打印更合理些，而且状态是TERMINATED。而运行时状态应该在run（）方法中打印</span><br><span class="line">    + start不能多次调用</span><br><span class="line">        + 变成runnable就不能调用start</span><br><span class="line">+ sleep()与yield</span><br><span class="line">    + sleep()</span><br><span class="line">        + running状态变成TIMED_WAITING：阻塞</span><br><span class="line">        + interrupt打断睡眠</span><br><span class="line">            + 睡眠线程抛出异常执行catch</span><br><span class="line">        + 睡眠结束未必立即执行，需要cpu使用权</span><br><span class="line">        + 可读性</span><br><span class="line">            + TimeUnit的sleep，附带时间单位</span><br><span class="line">    + yield()</span><br><span class="line">        + 从running变成runnable就绪</span><br><span class="line">        + 让出cpu使用权，有机会立即获得时间片</span><br><span class="line">+ 线程优先级</span><br><span class="line">    + setPriority()</span><br><span class="line">+ sleep应用</span><br><span class="line">    + while(true)</span><br><span class="line">    + 加上sleep</span><br><span class="line">        + 避免空转占满cpu</span><br><span class="line">+ join()</span><br><span class="line">    + 线程.join()</span><br><span class="line">        + 等待某线程运行结束</span><br><span class="line">    + 同步应用</span><br><span class="line">        + 同步：需要等待返回结果</span><br><span class="line">    + 限时同步：参数</span><br><span class="line">        + 最长等待时间</span><br><span class="line">+ interrupt()</span><br><span class="line">    + 打断阻塞线程：sleep、wait、join</span><br><span class="line">        + 抛出Interrupted异常</span><br><span class="line">        + 打断标记设为false</span><br><span class="line">    + 打断正常</span><br><span class="line">        + 打断标记为true</span><br><span class="line">            + 程序不结束</span><br><span class="line">            + 根据打断标记可以主动结束线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 过时方法</span><br><span class="line">    + 造成死锁</span><br><span class="line">+ 守护线程</span><br><span class="line">    + 当非守护线程都结束，守护线程强制结束</span><br><span class="line">    + 垃圾回收线程</span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>interrupt实现</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230843538.png" alt="image-20220314230843538"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ 两阶段终止模式</span><br><span class="line">    + 错误思路</span><br><span class="line">        + stop()</span><br><span class="line">            + 强制杀死，锁资源无法释放</span><br><span class="line">    + interrupt实现</span><br><span class="line">        + sleep中被打断</span><br><span class="line">            + 抛出异常，执行catch语句，继续运行</span><br><span class="line">                + 手动打断，设置打断标记为真</span><br><span class="line">            + 这里为什么还能进入下一次循环？是因为catch这里会处理异常，而不是抛出异常，抛出异常才会导致线程终止！这里打印红色异常信息不会导致线程终止</span><br><span class="line">        + 非sleep时被打断，设置打断标记未真</span><br><span class="line">            + 结束循环</span><br><span class="line">    + interrupt细节</span><br><span class="line">        + interrupted()会清除打断标记</span><br><span class="line">+ interrupt打断park线程 </span><br><span class="line">    + park暂停</span><br><span class="line">        + 打断标记为false时暂停</span><br><span class="line">        + interrupt可打断park线程</span><br></pre></td></tr></table></figure><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程状态</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220314230908950.png" alt="image-20220314230908950"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ 五种状态</span><br><span class="line">    + 初始状态</span><br><span class="line">        + 创建线程对象</span><br><span class="line">+ 可运行状态    </span><br><span class="line">        + 线程已被创建，可调度执行</span><br><span class="line">    + 运行状态</span><br><span class="line">        + 获取cpu时间片</span><br><span class="line">    + 阻塞状态</span><br><span class="line">        + 调用阻塞API</span><br><span class="line">    + 终止状态</span><br><span class="line">        + 线程执行完毕</span><br><span class="line">+ 六种状态：根据Thread.State</span><br><span class="line">    + new</span><br><span class="line">        + 创建对象</span><br><span class="line">    + runnable</span><br><span class="line">        + 包括可运行、运行、阻塞状态</span><br><span class="line">    + terminated</span><br><span class="line">        + 终止状态</span><br><span class="line">    + java API层面的阻塞</span><br><span class="line">        + blocked</span><br><span class="line">            + 拿不到锁</span><br><span class="line">        + waiting</span><br><span class="line">            + join()</span><br><span class="line">        + timed waiting</span><br><span class="line">            + sleep()</span><br><span class="line">+ 六种状态演示</span><br><span class="line">    + sleep不会释放锁，只会释放cpu资源；wait既会释放CPU又会释放锁资源</span><br><span class="line">    + 拿不到锁，blocked</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ 小结</span><br><span class="line">    + 线程创建</span><br><span class="line">        + 3种</span><br><span class="line">    + api</span><br><span class="line">        + join</span><br><span class="line">        + interrupt</span><br><span class="line">    + 线程状态</span><br><span class="line">        + 五种</span><br><span class="line">        + 六种</span><br><span class="line">    + 应用</span><br><span class="line">        + 异步调用</span><br><span class="line">        + 同步等待join</span><br><span class="line">        + 异步编排</span><br><span class="line">    + 原理</span><br><span class="line">        + 运行流程</span><br><span class="line">            + 栈、栈帧</span><br><span class="line">            + 上下文切换</span><br><span class="line">            + 程序计数器</span><br><span class="line">        + 创建源码</span><br><span class="line">    + 设计模式</span><br><span class="line">        + 两阶段终止interrupt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程与高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程与高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生实战</title>
      <link href="/2022/03/12/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%9E%E6%88%98/"/>
      <url>/2022/03/12/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312161918939.png" alt="image-20220312161918939"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312161936438.png" alt="image-20220312161936438"></p><ul><li><p>容器化相比虚拟化</p><ul><li><p>同一标准</p><ul><li><p>应用无论什么语言同一构建成镜像</p></li><li><p>镜像分享仓库</p></li><li><p>容器化时代</p><ul><li>虚拟化技术</li><li>容器化技术</li></ul></li></ul></li><li><p>资源隔离</p><ul><li>资源隔离</li><li>访问设备隔离</li><li>网络隔离</li><li>用户隔离</li></ul></li></ul></li></ul><ul><li><p>docker架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1624937894925-f437bd98-94e2-4334-9657-afa69bb52179.svg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1625373590853-2aaaa76e-d5b5-446b-850a-f6cfa26ac70a.png" alt="image.png"></p></li><li><p>操作</p></li></ul><ul><li><p>镜像操作</p><ul><li>docker hub仓库</li></ul></li><li><p>容器操作</p><ul><li><p>外部操作</p></li><li><p>内部操作</p><ul><li>看镜像仓库官网</li></ul></li></ul></li><li><p>打包镜像变化</p><ul><li>docker commit</li></ul></li><li><p>镜像保存</p><ul><li>docker save</li><li>保存为压缩包文件</li></ul></li><li><p>镜像加载</p><ul><li>docker load</li><li>读取压缩包为镜像</li></ul></li><li><p>镜像推送</p><ul><li>login：登录仓库</li><li>tag：改名，带上自己的仓库名</li><li>push：推送镜像</li></ul></li><li><p>挂载</p><ul><li>保证外部有配置文件</li><li>提前cp出来文件</li></ul></li><li><p>其他命令</p><ul><li><p>docker logs 容器</p><ul><li>容器日志</li></ul></li><li><p>docker cp</p><ul><li>容器复制到本地</li><li>本地复制到容器</li></ul></li></ul></li><li><p>构建应用</p></li></ul><ul><li><p>以前</p><ul><li>springboot打包</li><li>jar包上传服务器（环境）</li><li>运行jar包</li></ul></li><li><p>现在</p><ul><li><p>打包镜像，启动即用</p></li><li><p>编写docker file（如何打包）</p><ul><li><p>from：基础镜像</p><ul><li>运行环境</li></ul></li><li><p>label：作者</p></li><li><p>copy：把jar包复制到容器中位置</p></li><li><p>entrypoint：启动命令</p><ul><li>java -jar xx</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312162555498.png" alt="image-20220312162555498"></p></li></ul></li><li><p>上传到linux运行打包</p><ul><li>docker file + jar包</li><li>docker build<ul><li>tag：镜像名</li><li>当前目录工作</li></ul></li></ul></li><li><p>启动容器应用</p></li><li><p>docker logs xx 查看日志</p></li></ul></li><li><p>应用分享与启动</p><ul><li>tag</li><li>push</li><li>pull</li></ul></li></ul><h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><ul><li><p>组织架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1625452728905-e72041a2-cf1b-4b24-a327-7f0c3974a931.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163709410.png" alt="image-20220312163709410"></p></li><li><p>k8s集群部署</p><ul><li>三个服务器</li><li>安装docker容器环境</li><li>k8s<ul><li>kubelet、kubeadm、kubectl</li></ul></li><li>kubeadm启动集群<ul><li>master</li><li>worker</li><li>dashboard页面</li></ul></li></ul></li><li><p>核心实战</p><ul><li><p>namespace</p><ul><li>隔离资源</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163739852.png" alt="image-20220312163739852"></p></li><li><p>pod</p><ul><li><p>一组容器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163750025.png" alt="image-20220312163750025"></p></li><li><p>创建pod</p><ul><li>命令行</li><li>配置文件<ul><li>apply -f</li></ul></li></ul></li></ul></li><li><p>pod网络ip</p><ul><li>集群内公共访问</li></ul></li><li><p>多容器pod</p><ul><li>共享pod网络</li><li>端口不同即可部署多个相同应用</li></ul></li><li><p>deployment部署</p><ul><li><p>控制pod</p><ul><li>自愈</li><li>多副本</li></ul></li><li><p>扩缩容</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163803222.png" alt="image-20220312163803222"></p></li><li><p>自愈&amp;故障转移</p></li><li><p>阈值设置</p></li><li><p>滚动更新</p><ul><li>set新镜像自动滚动更新</li><li>不停机更新</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163809935.png" alt="image-20220312163809935"></p></li><li><p>版本回退</p><ul><li>rollout<ul><li>history<ul><li>查看历史部署</li></ul></li><li>undo<ul><li>回退</li></ul></li></ul></li></ul></li><li><p>工作负载：控制pod</p><ul><li>有状态、无状态</li><li>守护进程</li><li>任务等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163840752.png" alt="image-20220312163840752"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163820457.png" alt="image-20220312163820457"></p></li></ul></li></ul></li><li><p>服务网格</p><ul><li><p>service</p><ul><li>暴露：将一组pod公开为网络服务</li><li>自带负载均衡</li><li>集群内ip、域名访问</li><li>服务暴露<ul><li>clusterIP<ul><li>只能集群内访问</li></ul></li><li>NodePort<ul><li>集群外也可以访问（每个节点）</li><li>随机分配端口（3万以上）</li><li>nodeport——targetport——containerport</li></ul></li></ul></li></ul></li><li><p>ingress</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163902230.png" alt="image-20220312163902230"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163909266.png" alt="image-20220312163909266"></p><ul><li><p>集群统一网关入口</p></li><li><p>ingress网络模型</p><ul><li>底层nginx</li><li>ingress接收请求转发到不同service<ul><li>每个模块服务抽取为service<ul><li>service层网络</li></ul></li></ul></li></ul></li><li><p>路径重写</p></li><li><p>限流</p></li></ul></li><li><p>网络模型总结</p><ul><li>pod层，组合容器</li><li>service层，负载均衡pod</li><li>ingress层，路由service</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163919837.png" alt="image-20220312163919837"></p></li></ul></li><li><p>存储抽象</p><ul><li><p>数据挂载层同一管理为存储层</p><ul><li><p>多种存储框架</p><ul><li><p>NFS</p><ul><li><p>client节点同步server节点数据</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163928292.png" alt="image-20220312163928292"></p></li></ul></li></ul></li><li><p>搭建NFS环境</p></li><li><p>deploy数据卷挂载</p><ul><li><p>原生方式</p><ul><li>创建文件夹</li><li>配置deploy文件</li></ul></li><li><p>PV与PVC</p><ul><li><p>PV持久卷：指定保存位置</p></li><li><p>PVC持久卷规格声明：容量等</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163942434.png" alt="image-20220312163942434"></p></li><li><p>pvc配置文件</p></li></ul></li></ul></li><li><p>configmap抽取配置</p><ul><li><p>configmap便于镜像和配置文件的解耦</p></li><li><p>编写配置文件，创建为配置集</p><ul><li>保存在etcd</li></ul></li><li><p>启动pod，配置文件挂载configmap</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163949059.png" alt="image-20220312163949059"></p></li></ul></li><li><p>secret秘钥令牌</p><ul><li><p>创建serect</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312163958664.png" alt="image-20220312163958664"></p></li><li><p>base64编码</p><ul><li>docker仓库第三方需解密</li><li>可破解</li></ul></li></ul></li></ul></li></ul></li><li><p>小结</p><ul><li>deployment</li><li>其他工作负载</li><li>pod</li><li>service</li><li>ingress</li><li>pvc</li><li>configmap</li><li>serect</li></ul></li></ul><h1 id="kubeSphere"><a href="#kubeSphere" class="headerlink" title="kubeSphere"></a>kubeSphere</h1><ul><li><p>kubesphere</p><ul><li><p>简介</p><ul><li>可视化界面</li><li>多租户</li><li>多k8s集群管理</li><li>CI/CD</li><li>微服务治理：服务网格</li><li>应用管理</li></ul></li><li><p>安装</p><ul><li><p>k8s安装</p><ul><li>默认存储类型nfs</li><li>metrics-server</li><li>全功能安装</li></ul></li><li><p>linux安装</p><ul><li><p>单节点一键安装</p><ul><li>kubekey</li></ul></li><li><p>多节点安装</p><ul><li>kubekey</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164547433.png" alt="image-20220312164547433"></p></li></ul></li></ul></li><li><p>多租户管理</p></li><li><p>中间件部署</p><ul><li><p>手动部署</p><ul><li>依据docker hub文档</li><li>configmap</li><li>pvc</li><li>部署工作负载<ul><li>镜像、资源、端口</li><li>环境变量、配置、挂载文件</li></ul></li><li>部署服务<ul><li>暴露<ul><li>集群内部通过域名访问（自动）</li><li>集群外部<ul><li>指定工作负载，集群外访问</li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164602153.png" alt="image-20220312164602153"></p></li><li><p>直接部署应用（从应用商店）</p><ul><li>要自己打开clusterConfiguration</li></ul></li><li><p>应用仓库</p><ul><li>helm-k8s包管理仓库</li><li>添加应用仓库</li></ul></li></ul></li><li><p>应用部署cloud</p><ul><li><p>数据层</p></li><li><p>微服务治理层</p></li><li><p>微服务层</p><p>​            <img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164622245.png" alt="image-20220312164622245"></p><ul><li>制作镜像<ul><li>docker file</li><li>maven打包</li></ul></li><li>推送镜像<ul><li>阿里云镜像仓库</li><li>应用部署</li></ul></li></ul></li><li><p>前端层</p><ul><li><p>基础镜像nginx</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164642652.png" alt="image-20220312164642652"></p></li><li><p>构建镜像</p></li><li><p>部署</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164652308.png" alt="image-20220312164652308"></p></li><li><p>存活检查：探针</p></li></ul></li><li><p>devops</p><ul><li><p>敏捷开发</p></li><li><p>全链路自动化</p></li><li><p>cloud应用上云</p><ul><li><p>中间件层</p><ul><li>手动构建服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164744707.png" alt="image-20220312164744707"></p></li><li><p>微服务层</p><ul><li>生产环境配置抽取</li><li>nacos配置中心<ul><li>域名地址配置中间件</li></ul></li></ul></li><li><p>流水线</p><ul><li><p>流水线模板</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164758372.png" alt="image-20220312164758372"></p></li><li><p>第一步-拉取代码</p></li><li><p>第二步-项目编译</p><ul><li>配置maven阿里云镜像<ul><li>修改ks-devops-agent配置</li></ul></li></ul></li><li><p>第三步-构建镜像</p><ul><li><p>基础操作</p></li><li><p>并发构建</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164807965.png" alt="image-20220312164807965"></p></li></ul></li><li><p>第四步-推送镜像</p><ul><li><p>基础操作</p><ul><li>镜像仓库凭证</li></ul></li><li><p>并发推送</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164813947.png" alt="image-20220312164813947"></p></li></ul></li><li><p>第五步-部署到dev环境</p><ul><li><p>微服务准备deploy.yaml部署文件</p></li><li><p>镜像凭证</p><ul><li>阿里云仓库密钥</li></ul></li><li><p>并行部署</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164820639.png" alt="image-20220312164820639"></p></li><li><p>就绪探针</p></li></ul></li><li><p>第六步-系统邮件</p></li></ul></li><li><p>前端项目</p><ul><li><p>流水线</p><ul><li>基础环境nodejs</li><li>拉取代码</li><li>项目安装依赖、编译</li><li>构建镜像<ul><li>docker file</li></ul></li></ul></li><li><p>推送镜像</p></li><li><p>部署到dev环境</p><ul><li>deploy.yaml</li></ul></li><li><p>发送确认邮件</p></li></ul></li><li><p>部署nust-site前端项目</p><ul><li><p>基于nust服务端渲染</p></li><li><p>打包镜像</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164832626.png" alt="image-20220312164832626"></p></li><li><p>可以请求一切走集群内网（服务端渲染）</p></li></ul></li><li><p>webhook自动启动流水线</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312164847450.png" alt="image-20220312164847450"></p><ul><li><p>写完代码提交</p></li><li><p>给指定地方发请求</p></li><li><p>流水线自动运行</p></li><li><p>创建webhook：gitee配置</p></li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt"><a href="#kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt" class="headerlink" title="kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt"></a>kubekey、devops深入、应用管理、服务网格istio、k8s可观测性、kubevirt</h1><ul><li><p>kubekey运维高可用集群</p><ul><li><p>Kubekey介绍</p><ul><li>kubeadm、kops、kubespray方式<ul><li>容器环境、管理证书</li><li>apiserver负载均衡器</li><li>etcd等</li></ul></li><li>kubekey方式<ul><li>部署k8s、k3s</li></ul></li></ul></li><li><p>部署高可用k8s集群</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165738542.png" alt="image-20220312165738542"></p><ul><li><p>外部负载均衡</p></li><li><p>内部负载均衡</p></li><li><p>kubekey部署高可用集群</p></li></ul></li><li><p>kubekey集群配置文件</p><ul><li>hosts：ip、user</li></ul></li><li><p>k8s增删集群节点</p></li><li><p>集群证书管理</p></li><li><p>kubesphere启用可插拔组件</p></li><li><p>节点管理</p></li></ul></li><li><p>devops深入</p><ul><li><p>devops元素周期表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165317185.png" alt="image-20220312165317185"></p></li><li><p>devops流程</p></li><li><p>devops生命周期</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165751201.png" alt="image-20220312165751201"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165800148.png" alt="image-20220312165800148"></p></li><li><p>devops流水线</p></li><li><p>质量扫描&amp;单元测试&amp;制品管理</p></li><li><p>自动部署构建</p></li><li><p>devops自动部署</p></li><li><p>source to images 发布应用</p><ul><li>无需dockerfile</li><li>通过github代码地址</li></ul></li><li><p>binary to image发布应用</p><ul><li>通过jar包</li></ul></li><li><p>Jenkinsfile部署流水线</p></li></ul></li><li><p>kubesphere备份与恢复</p><ul><li>多节点模式</li><li>master节点启停</li><li>woker节点启停</li><li>集群启停</li></ul></li><li><p>云原生应用管理</p><ul><li>调试应用</li><li>应用调度</li><li>helm<ul><li>helm及应用仓库</li><li>开发helm</li><li>k8s应用声明周期</li><li>应用仓库管理</li><li>应用管理场景</li></ul></li></ul></li><li><p>kubernetes federation</p></li><li><p>服务网格架构</p><ul><li><p>微服务</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165816353.png" alt="image-20220312165816353"></p><ul><li><p>微服务框架挑战</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165824002.png" alt="image-20220312165824002"></p><ul><li>过于绑定技术栈</li><li>多语言受限</li><li>代码侵入度过高</li></ul></li></ul></li><li><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165831921.png" alt="image-20220312165831921"></p><ul><li><p>side car</p></li><li><p>服务网格</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165836512.png" alt="image-20220312165836512"></p><ul><li>一组轻量级网络代理实现</li></ul></li></ul></li><li><p>istio</p><ul><li><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165844680.png" alt="image-20220312165844680"></p></li><li><p>安装部署</p></li><li><p>测试项目部署</p></li><li><p>isito核心概念</p><ul><li>虚拟服务</li><li>目标规则</li></ul></li><li><p>kubesphere启用服务治理</p><ul><li><p>启用istio</p></li><li><p>创建服务</p></li><li><p>服务治理</p><ul><li><p>链路追踪</p></li><li><p>流量监控</p></li><li><p>灰度发布</p><ul><li><p>金丝雀发布</p><ul><li>流量手动分配</li></ul></li><li><p>达到足够上线条件</p><ul><li>接管</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><p>k8s可观测性</p><ul><li>日志系统</li><li>日志安装<ul><li>kubesphere可插拔式安装</li><li>cluster configuration<ul><li>logging<ul><li>集合fluent bit</li></ul></li></ul></li></ul></li></ul></li><li><p>日志查看</p><ul><li><p>容器日志查询</p></li><li><p>日志检索与落盘日志收集</p><ul><li>开启日志收集</li><li>创建工作负载<ul><li>alpine镜像<ul><li>启动命令</li></ul></li><li>挂载pvc</li></ul></li></ul></li><li><p>常见问题</p><ul><li>存储外部es，关闭内部es</li><li>日志保留日期</li></ul></li></ul></li><li><p>监控与预警</p><ul><li><p>Prometheus</p><ul><li><p>安装node explorer</p></li><li><p>promQL</p></li><li><p>告警处理</p><ul><li>告警规则</li></ul></li><li><p>operator</p><ul><li>控制中心</li></ul></li></ul></li><li><p>kubesphere监控</p><ul><li>基于Prometheus</li></ul></li><li><p>费率统计</p></li></ul></li><li><p>kubevirt虚拟机管理</p><ul><li><p>虚拟化技术</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312165923874.png" alt="image-20220312165923874"></p></li><li><p>kubevirt</p></li><li><p>KSV平台</p></li></ul></li><li><p>CKA、CKS</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220312170342258.png" alt="image-20220312170342258"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——k8s-DevOps-CI/CD&amp;最终部署</title>
      <link href="/2022/03/11/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-k8s-%E8%87%AA%E5%8A%A8%E5%8C%96cicd&amp;%E6%9C%80%E7%BB%88%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/03/11/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-k8s-%E8%87%AA%E5%8A%A8%E5%8C%96cicd&amp;%E6%9C%80%E7%BB%88%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps: Development 和 Operations 的组合</p><ul><li>DevOps 看作开发（软件工程）、技术运营和质量保障（QA）三者的交集。</li><li>突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、 发布更加快捷、频繁和可靠。</li><li>DevOps 希望做到的是软件产品交付过程中 <strong>IT 工具链的打通</strong>，使得各个团队减少时间损耗，更加高效地协同工作。DevOps 能力图如下，良好的闭环可以大大增加整体的产出。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311121142708.png" alt="image-20220311121142708"></p><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h2><p>1、持续集成（Continuous Integration） </p><p>持续集成是指软件个人研发的部分向软件整体部分交付，频繁进行集成以便更快地发现 其中的错误。“持续集成”源自于极限编程（XP），是 XP 最初的 12 种实践之一。</p><p>CI 需要具备这些：</p><ul><li><strong>全面的自动化测试。</strong>这是实践持续集成&amp;持续部署的基础，同时，选择合适的自动化测试工具也极其重要</li><li><strong>灵活的基础设施。容器，虚拟机</strong>的存在让开发人员和 QA 人员不必再大费周折</li><li><strong>版本控制工具。</strong>如 <strong>Git</strong>，CVS，SVN 等</li><li><strong>自动化的构建和软件发布流程的工具</strong>，如 <strong>Jenkins</strong>，flow.ci</li><li><strong>反馈机制。</strong>如构建/测试的失败，可以快速地反馈到相关负责人，以尽快解决达到一个更稳定的版本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311121324347.png" alt="image-20220311121324347"></p><p>2、持续交付（Continuous Delivery） </p><p>持续交付在持续集成的基础上，将集成后的代码部署到<strong>更贴近真实运行环境的</strong>「类生产环境」 （production-like environments）中。持续交付优先于整个产品生命周期的软件部署，建立在高水平自动化持续集成之上。</p><p>灰度发布。 </p><p>持续交付和持续集成的优点非常相似：</p><ul><li><strong>快速发布。</strong>能够应对业务需求，并更快地实现软件价值</li><li><strong>编码-&gt;测试-&gt;上线-&gt;交付</strong>的频繁迭代周期缩短，同时获得迅速反馈</li><li><strong>高质量的软件发布标准</strong>。整个交付过程标准化、可重复、可靠</li><li><strong>整个交付过程进度可视化，</strong>方便团队人员了解项目成熟度</li><li><strong>更先进的团队协作方式。</strong>从需求分析、产品的用户体验到交互 设计、开发、测试、运维等角色密切协作，相比于传统的瀑布式软件团队，更少浪费</li></ul><p>3、持续部署（Continuous Deployment）</p><p><strong>持续部署</strong>是指当交付的代码通过评审之后，<strong>自动部署到生产环境中</strong>。持续部署是持续交付的最高阶段。这意味着，所有通过了一系列的自动化测试的改动都将自动部署到生产环境。它也可以被称为“Continuous Release”。</p><p>“开发人员提交代码，持续集成服务器获取代码，执行单元测试，根据测试结果决定是否部署到预演环境，如果成功部署到预演环境，进行整体验收测试，如果测试通过，自动部署到产品环境，全程自动化高效运转。”</p><p>持续部署主要好处是，可以相对独立地部署新的功能，并能快速地收集真实用户的反馈。 </p><p>下图是由 Jams Bowman 绘制的持续交付工具链图</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/cicd-tools-fullsize.jpeg" alt="cicd-tools-fullsize"></p><h1 id="最终部署"><a href="#最终部署" class="headerlink" title="最终部署"></a>最终部署</h1><p>kubesphere架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/architecture.png" alt="architecture"></p><h2 id="有状态服务部署"><a href="#有状态服务部署" class="headerlink" title="有状态服务部署"></a>有状态服务部署</h2><p>1、有状态服务抽取配置为 ConfigMap</p><p>2、有状态服务必须使用 pvc 持久化数据</p><p>3、服务集群内访问使用 DNS 提供的稳定域名</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311125735647.png" alt="image-20220311125735647"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311131906123.png" alt="image-20220311131906123"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311131257276.png" alt="image-20220311131257276"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 部署流程</span><br><span class="line">    + configMap</span><br><span class="line">    + pvc</span><br><span class="line">    + 镜像</span><br><span class="line">    + 资源限制</span><br><span class="line">    + 环境变量</span><br><span class="line">    + 挂载pvc</span><br><span class="line">    + 外网访问、集群内访问等</span><br></pre></td></tr></table></figure><p>依次部署集群：</p><p>MySQL、Redis、RabbitMQ、Elasticsearch、Kibana</p><p>Nacos、Zipkin、Nginx、Sentinel</p><h2 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1、dockerfile</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311132713759.png" alt="image-20220311132713759"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 创建项目 dockerfile2、上传项目到服务器。 </span><br><span class="line">+ 进入项目，构建镜像到本地仓库； </span><br><span class="line">+ docker build -t nginx:GA-1.0 -f ./Dockerfile . </span><br><span class="line">+ docker images </span><br><span class="line">+ docker exec -it 容器 id /bin/bash；进入容器，修改容器 </span><br><span class="line">+ docker commit -a “leifengyang” -m “nginxxx” 容器 id </span><br><span class="line">+  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] </span><br><span class="line">+  OPTIONS 说明： </span><br><span class="line">+ -a :提交的镜像作者； </span><br><span class="line">+ -c :使用 Dockerfile 指令来创建镜像； </span><br><span class="line">+ -m :提交时的说明文字； </span><br><span class="line">+ -p :在 commit 时，将容器暂停。 </span><br><span class="line">+ docker login : 登陆到一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub </span><br><span class="line">+ docker login -u 用户名 -p 密码 </span><br><span class="line">+ docker logout : 登出一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub </span><br><span class="line">+ 推送镜像到 docker hub </span><br><span class="line">+ 标记镜像，docker tag local-image:tagname username/new-repo:tagname </span><br><span class="line">+ 上传镜像，docker push username/new-repo:tagname </span><br><span class="line">+ 保存镜像，加载镜像 </span><br><span class="line">+ 可以保存镜像为 tar，使用 u 盘等设备复制到任意 docker 主机，再次加载镜像 </span><br><span class="line">+ 保存：docker save spring-boot-docker -o /home/spring-boot-docker.tar </span><br><span class="line">+ 加载：docker load -i spring-boot-docker.tar </span><br><span class="line">+ 阿里云操作 </span><br><span class="line">+ 登录阿里云，密码就是开通镜像仓库时的密码 docker login --username=qwertyuiopasdf_aa registry.cn-hangzhou.aliyuncs.com </span><br><span class="line">+ 拉取镜像 docker pull registry.cn-hangzhou.aliyuncs.com/atguigumall/gulimall-nginx:v1.0 </span><br><span class="line">+ 推送镜像 docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/atguigumall/gulimall-nginx:v1 </span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/atguigumall/gulimall-nginx:v1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM java:openjdk-8-jre-alpine</span><br><span class="line">WORKDIR /home</span><br><span class="line">COPY target/*.jar /home</span><br><span class="line">ENTRYPOINT java -jar *.jar</span><br></pre></td></tr></table></figure><p>2、k8s部署描述文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubesphere</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">ks-sample</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ks-sample</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubesphere-sample-prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubesphere</span></span><br><span class="line">      <span class="attr">component:</span> <span class="string">ks-sample</span></span><br><span class="line">      <span class="attr">tier:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubesphere</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">ks-sample</span></span><br><span class="line">        <span class="attr">tier:</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CACHE_IGNORE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">js|html</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CACHE_PUBLIC_EXPIRATION</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">3d</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">$REGISTRY/$HARBOR_NAMESPACE/$APP_NAME:$TAG_NAME</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">ks</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">300m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">600Mi</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">          <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">          <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311150912792.png" alt="image-20220311150912792"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ Containerport：容器内服务端口</span><br><span class="line">+ TargetPort</span><br><span class="line">+ pod访问container</span><br><span class="line">+ Port：集群内service端口，域名、ip端口号</span><br><span class="line">+ Nodeport：外部访问集群service</span><br><span class="line">+ 特点</span><br><span class="line">+ Targetport、serviceport端口可以一样</span><br><span class="line">+ 每个service、pod地址都不一样，都是集群内虚拟的</span><br><span class="line">+ Nodeport不能一样，暴露外部端口</span><br></pre></td></tr></table></figure><p>3、Jenkinsfile流水线文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pipeline</span> &#123;</span><br><span class="line">  <span class="string">agent</span> &#123;</span><br><span class="line">    <span class="string">node</span> &#123;</span><br><span class="line">      <span class="string">label</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">parameters</span> &#123;</span><br><span class="line">        <span class="string">string(name:&#x27;TAG_NAME&#x27;</span>,<span class="attr">defaultValue:</span> <span class="string">&#x27;&#x27;</span>,<span class="string">description:&#x27;&#x27;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">environment</span> &#123;</span><br><span class="line">        <span class="string">DOCKER_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;dockerhub-id&#x27;</span></span><br><span class="line">        <span class="string">GITHUB_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;github-id&#x27;</span></span><br><span class="line">        <span class="string">KUBECONFIG_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;demo-kubeconfig&#x27;</span></span><br><span class="line">        <span class="string">REGISTRY</span> <span class="string">=</span> <span class="string">&#x27;docker.io&#x27;</span></span><br><span class="line">        <span class="string">DOCKERHUB_NAMESPACE</span> <span class="string">=</span> <span class="string">&#x27;1637872839&#x27;</span></span><br><span class="line">        <span class="string">GITHUB_ACCOUNT</span> <span class="string">=</span> <span class="string">&#x27;1637872839&#x27;</span></span><br><span class="line">        <span class="string">APP_NAME</span> <span class="string">=</span> <span class="string">&#x27;devops-java-sample&#x27;</span></span><br><span class="line">        <span class="string">SONAR_CREDENTIAL_ID</span> <span class="string">=</span> <span class="string">&#x27;sonar-qube&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">stages</span> &#123;</span><br><span class="line">        <span class="string">stage</span> <span class="string">(&#x27;checkout</span> <span class="string">scm&#x27;)</span> &#123;</span><br><span class="line">            <span class="string">steps</span> &#123;</span><br><span class="line">                <span class="string">checkout(scm)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">stage</span> <span class="string">(&#x27;unit</span> <span class="string">test&#x27;)</span> &#123;</span><br><span class="line">            <span class="string">steps</span> &#123;</span><br><span class="line">                <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;mvn clean  -gs `pwd`/configuration/settings.xml test&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="string">stage</span> <span class="string">(&#x27;build</span> <span class="string">&amp;</span> <span class="string">push&#x27;)</span> &#123;</span><br><span class="line">            <span class="string">steps</span> &#123;</span><br><span class="line">                <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;mvn  -Dmaven.test.skip=true -gs `pwd`/configuration/settings.xml clean package&#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;docker build -f Dockerfile-online -t $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER .&#x27;</span></span><br><span class="line">                    <span class="string">withCredentials(</span>[<span class="string">usernamePassword(passwordVariable</span> <span class="string">:</span> <span class="string">&#x27;DOCKER_PASSWORD&#x27;</span> ,<span class="attr">usernameVariable :</span> <span class="string">&#x27;DOCKER_USERNAME&#x27;</span> ,<span class="attr">credentialsId :</span> <span class="string">&quot;$DOCKER_CREDENTIAL_ID&quot;</span> ,<span class="string">)</span>]<span class="string">)</span> &#123;</span><br><span class="line">                        <span class="string">sh</span> <span class="string">&#x27;echo &quot;$DOCKER_PASSWORD&quot; | docker login $REGISTRY -u &quot;$DOCKER_USERNAME&quot; --password-stdin&#x27;</span></span><br><span class="line">                        <span class="string">sh</span> <span class="string">&#x27;docker push  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">stage(&#x27;push</span> <span class="string">latest&#x27;)</span>&#123;</span><br><span class="line">           <span class="string">when</span>&#123;</span><br><span class="line">             <span class="string">branch</span> <span class="string">&#x27;master&#x27;</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="string">steps</span>&#123;</span><br><span class="line">                <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                  <span class="string">sh</span> <span class="string">&#x27;docker tag  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:latest &#x27;</span></span><br><span class="line">                  <span class="string">sh</span> <span class="string">&#x27;docker push  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:latest &#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">stage(&#x27;deploy</span> <span class="string">to</span> <span class="string">dev&#x27;)</span> &#123;</span><br><span class="line">          <span class="string">when</span>&#123;</span><br><span class="line">            <span class="string">branch</span> <span class="string">&#x27;master&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="string">steps</span> &#123;</span><br><span class="line">            <span class="string">input(id:</span> <span class="string">&#x27;deploy-to-dev&#x27;</span>, <span class="attr">message:</span> <span class="string">&#x27;deploy to dev?&#x27;</span><span class="string">)</span></span><br><span class="line">            <span class="string">kubernetesDeploy(configs:</span> <span class="string">&#x27;deploy/dev-ol/**&#x27;</span>, <span class="attr">enableConfigSubstitution:</span> <span class="literal">true</span>, <span class="attr">kubeconfigId:</span> <span class="string">&quot;$KUBECONFIG_CREDENTIAL_ID&quot;</span><span class="string">)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">stage(&#x27;push</span> <span class="string">with</span> <span class="string">tag&#x27;)</span>&#123;</span><br><span class="line">          <span class="string">when</span>&#123;</span><br><span class="line">            <span class="string">expression</span>&#123;</span><br><span class="line">              <span class="string">return</span> <span class="string">params.TAG_NAME</span> <span class="string">=~</span> <span class="string">/v.*/</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="string">steps</span> &#123;</span><br><span class="line">              <span class="string">container</span> <span class="string">(&#x27;maven&#x27;)</span> &#123;</span><br><span class="line">                <span class="string">input(id:</span> <span class="string">&#x27;release-image-with-tag&#x27;</span>, <span class="attr">message:</span> <span class="string">&#x27;release image with tag?&#x27;</span><span class="string">)</span></span><br><span class="line">                  <span class="string">withCredentials(</span>[<span class="string">usernamePassword(credentialsId:</span> <span class="string">&quot;$GITHUB_CREDENTIAL_ID&quot;</span>, <span class="attr">passwordVariable:</span> <span class="string">&#x27;GIT_PASSWORD&#x27;</span>, <span class="attr">usernameVariable:</span> <span class="string">&#x27;GIT_USERNAME&#x27;</span><span class="string">)</span>]<span class="string">)</span> &#123;</span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git config --global user.email &quot;kubesphere@yunify.com&quot; &#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git config --global user.name &quot;kubesphere&quot; &#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git tag -a $TAG_NAME -m &quot;$TAG_NAME&quot; &#x27;</span></span><br><span class="line">                    <span class="string">sh</span> <span class="string">&#x27;git push http://$GIT_USERNAME:$GIT_PASSWORD@github.com/$GITHUB_ACCOUNT/devops-java-sample.git --tags --ipv4&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="string">sh</span> <span class="string">&#x27;docker tag  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:SNAPSHOT-$BRANCH_NAME-$BUILD_NUMBER $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:$TAG_NAME &#x27;</span></span><br><span class="line">                <span class="string">sh</span> <span class="string">&#x27;docker push  $REGISTRY/$DOCKERHUB_NAMESPACE/$APP_NAME:$TAG_NAME &#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">stage(&#x27;deploy</span> <span class="string">to</span> <span class="string">production&#x27;)</span> &#123;</span><br><span class="line">          <span class="string">when</span>&#123;</span><br><span class="line">            <span class="string">expression</span>&#123;</span><br><span class="line">              <span class="string">return</span> <span class="string">params.TAG_NAME</span> <span class="string">=~</span> <span class="string">/v.*/</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="string">steps</span> &#123;</span><br><span class="line">            <span class="string">input(id:</span> <span class="string">&#x27;deploy-to-production&#x27;</span>, <span class="attr">message:</span> <span class="string">&#x27;deploy to production?&#x27;</span><span class="string">)</span></span><br><span class="line">            <span class="string">kubernetesDeploy(configs:</span> <span class="string">&#x27;deploy/prod-ol/**&#x27;</span>, <span class="attr">enableConfigSubstitution:</span> <span class="literal">true</span>, <span class="attr">kubeconfigId:</span> <span class="string">&quot;$KUBECONFIG_CREDENTIAL_ID&quot;</span><span class="string">)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、阿里云镜像仓库</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311152111010.png" alt="image-20220311152111010"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 创建镜像仓库</span><br><span class="line">    + 登录仓库</span><br><span class="line">    + 拉取镜像</span><br><span class="line">    + 推送镜像</span><br></pre></td></tr></table></figure><h3 id="DevOps部署流水线"><a href="#DevOps部署流水线" class="headerlink" title="DevOps部署流水线"></a>DevOps部署流水线</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311150756780.png" alt="image-20220311150756780"></p><p>1、拉取gitee代码&amp;参数化构建&amp;环境变量</p><ul><li>配置凭证</li><li>配置构建微服务参数</li><li>配置运行参数等</li></ul><p>2、Sonar代码质量分析</p><ul><li>配置阿里云镜像</li><li>进入sonar查看分析报告</li><li>bug修改等</li></ul><p>3、构建&amp;推送镜像</p><ul><li>配置阿里云私有镜像仓库</li><li>根据dockerfile 打包镜像</li><li>推送镜像</li></ul><p>4、部署到k8s生产环境</p><p>5、发布</p><ul><li><p>gitee仓库地址</p></li><li><p>tag信息</p></li></ul><h2 id="全链路最终部署"><a href="#全链路最终部署" class="headerlink" title="全链路最终部署"></a>全链路最终部署</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311151019195.png" alt="image-20220311151019195"></p><p>1、数据服务集群</p><p>2、微服务集群</p><p>3、gateway网关集群</p><p>4、nginx集群</p><p>5、vue后台</p><p>6、ingress controller网关路由</p><p>地址——&gt;ingress controller——&gt;动静分离nginx——&gt;gateway——&gt;微服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 部署方式</span><br><span class="line">+ Jenkins流水线</span><br><span class="line">+ 自己打包部署k8s服务</span><br><span class="line">+ 拉取镜像自己运行</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><p>动态扩容节点</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311132218996.png" alt="image-20220311132142809"></p><p>预警信息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311152935372.png" alt="image-20220311152935372"></p><p>监控信息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311132353545.png" alt="image-20220311132353545"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ k8s概念</span><br><span class="line">    + pod、server</span><br><span class="line">    + nodeport等</span><br><span class="line">+ 应用路由</span><br><span class="line">    + ingress controller</span><br><span class="line">+ 配置中心</span><br><span class="line">    + configMap</span><br><span class="line">+ Devops</span><br><span class="line">    + 自动化流水线</span><br><span class="line">        + 修改推送代码</span><br><span class="line">        + 运行流水线构建</span><br><span class="line">+ 监控资源</span><br><span class="line">+ 集群技术</span><br><span class="line">    + 主从、分片、选领导</span><br><span class="line">    + 各种集群</span><br><span class="line">+ Jenkins file</span><br><span class="line">+ Docker file</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——云原生Pass-Kubesphere&amp;集群搭建</title>
      <link href="/2022/03/08/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9FPaaS%E5%B9%B3%E5%8F%B0Kubesphere/"/>
      <url>/2022/03/08/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9FPaaS%E5%B9%B3%E5%8F%B0Kubesphere/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubesphere"><a href="#Kubesphere" class="headerlink" title="Kubesphere"></a>Kubesphere</h1><p>Kubesphere官网：<a href="https://kubesphere.io/zh/">https://kubesphere.io/zh/</a></p><p>KubeSphere 是一款面向云原生设计的开源项目，在目前主流容器调度平台 Kubernetes 之上构建的分布式多租户容器管理平台，提供简单易用的操作界面以及向导式操作方式，在降低用户使用容器调度平台学习成本的同时，极大降低开发、测试、运维的日常工作的复杂度。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>1、安装helm（master节点）</p><p>2、安装 Tiller（master 执行） </p><p>3、安装 OpenEBS（master 执行）</p><p>4、最小化、完整化安装Kubesphere</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308144343351.png" alt="image-20220308144343351"></p><h2 id="多租户管理"><a href="#多租户管理" class="headerlink" title="多租户管理"></a>多租户管理</h2><p>包括集群(Cluster)、企业空间(Workspace)、项目(Project)和DevOps Project(DevOps 工程)的层级关系</p><p><img src="https://www.icode9.com/i/ll/?i=20210712161032787.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zMjE5Njg5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220311104750797.png" alt="image-20220311104750797"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1776090-20210826172258323-530376724.png" alt="img"></p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>集群的目标</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309074801138.png" alt="image-20220309074801138"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 集群目标</span><br><span class="line">    + 高可用HA</span><br><span class="line">    + 突破数据量限制</span><br><span class="line">    + 多节点存储</span><br><span class="line">    + 多节点备份</span><br><span class="line">    + 数据备份容灾</span><br><span class="line">    + 压力分担</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309074812891.png" alt="image-20220309074812891"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 基础形式</span><br><span class="line">+ 主从</span><br><span class="line">+ 同步：主从复制</span><br><span class="line">        + 主从调度</span><br><span class="line">    + 分片</span><br><span class="line">    + 分片存储</span><br><span class="line">    + 分片备份</span><br><span class="line">   + 选主</span><br><span class="line">   + 选主容灾</span><br><span class="line">   + 选主调度</span><br></pre></td></tr></table></figure><h2 id="MySQL集群"><a href="#MySQL集群" class="headerlink" title="MySQL集群"></a>MySQL集群</h2><p>集群原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308233055567.png" alt="image-20220308233055567"></p><p>企业中常用的数据库解决方案</p><h3 id="集群方式"><a href="#集群方式" class="headerlink" title="集群方式"></a>集群方式</h3><p>1、MMM</p><p>MySQL-MMM 是 Master-Master Replication Manager for MySQL（mysql 主主复制管理器）的简称，是 Google 的开源项目（Perl 脚本）。MMM 基于 MySQLReplication 做的扩展架构，主要用来监控 mysql 主主复制并做失败转移。其原理是将真实数据库节点的IP（RIP）映射为虚拟 IP（VIP）集。mysql-mmm 的监管端会提供多个虚拟 IP（VIP），包括一个可写 VIP，多个可读 VIP，通过监管的管理，这些 IP 会绑定在可用 mysql 之上，当某一台 mysql 宕机时，监管会将 VIP迁移至其他 mysql。在整个监管过程中，需要在 mysql 中添加相关授权用户，以便让 mysql 可以支持监理机的维护。授权的用户包括一个mmm_monitor 用户和一个 mmm_agent 用户，如果想使用 mmm 的备份工具则还要添加一个 mmm_tools 用户。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308233254614.png" alt="image-20220308233254614"></p><p>2、MHA</p><p>MHA（Master High Availability）目前在 MySQL 高可用方面是一个相对成熟的解决方案, 由日本 DeNA 公司 youshimaton（现就职于 Facebook 公司）开发，是一套优秀的作为 MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中， MHA 能做到在 0~30 秒之内自动完成数据库的故障切换操作（以 2019 年的眼光来说太 慢了），并且在进行故障切换的过程中，MHA 能在最大程度上保证数据的一致性，以 达到真正意义上的高可用。</p><p>3、InnoDB Cluster</p><p>InnoDB Cluster 支持自动 Failover、强一致性、读写分离、读库高可用、读请求负载均衡，横向扩展的特性，是比较完备的一套方案。但是部署起来复杂，想要解决 router单点问题好需要新增组件，如没有其他更好的方案可考虑该方案。 InnoDB Cluster 主要由 MySQL Shell、MySQL Router 和 MySQL 服务器集群组成，三者协同工作，共同为MySQL 提供完整的高可用性解决方案。MySQL Shell 对管理人员提供管理接口，可以很方便的对集群进行配置和管理,MySQL Router 可以根据部署的集群状况自动的初始化，是客户端连接实例。如果有节点 down 机，集群会自动更新配置。集群包含单点写入和多点写入两种模式。在单主模式下，如果主节点 down 掉，从节点自动替换上来，MySQL Router 会自动探测，并将客户端连接到新节点。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220308233434429.png" alt="image-20220308233434429"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ MMM</span><br><span class="line">+ MHA</span><br><span class="line">+ InnoDB Cluster</span><br><span class="line">+ 自动故障转移</span><br><span class="line">+ 强一致性</span><br><span class="line">+ 读写分离</span><br><span class="line">+ 高可用</span><br><span class="line">+ 负载均衡</span><br><span class="line">+ 横向拓展</span><br></pre></td></tr></table></figure><h3 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">master：</span><br><span class="line">docker run -p 3307:3306 --name mysql-master \ </span><br><span class="line">-v /mydata/mysql/master/log:/var/log/mysql \ </span><br><span class="line">-v /mydata/mysql/master/data:/var/lib/mysql \ </span><br><span class="line">-v /mydata/mysql/master/conf:/etc/mysql \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \ -d mysql:5.7 </span><br><span class="line">参数说明</span><br><span class="line">-p 3307:3306：将容器的 3306 端口映射到主机的 3307 端口 </span><br><span class="line">-v /mydata/mysql/master/conf:/etc/mysql：将配置文件夹挂在到主机 -v /mydata/mysql/master/log:/var/log/mysql：将日志文件夹挂载到主机 </span><br><span class="line">-v /mydata/mysql/master/data:/var/lib/mysql/：将配置文件夹挂载到主机 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码</span><br><span class="line">slaver：</span><br><span class="line">docker run -p 3317:3306 --name mysql-slaver-01 \ </span><br><span class="line">-v /mydata/mysql/slaver/log:/var/log/mysql \ </span><br><span class="line">-v /mydata/mysql/slaver/data:/var/lib/mysql \ </span><br><span class="line">-v /mydata/mysql/slaver/conf:/etc/mysql \ </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \ -d mysql:5.7</span><br><span class="line"></span><br><span class="line">修改配置Master、slaver</span><br><span class="line">[client] </span><br><span class="line">default-character-set=utf8 </span><br><span class="line"></span><br><span class="line">[mysql] </span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld] </span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27; </span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27; </span><br><span class="line">character-set-server=utf8 </span><br><span class="line">collation-server=utf8_unicode_ci </span><br><span class="line">skip-character-set-client-handshake </span><br><span class="line">skip-name-resolve</span><br><span class="line"></span><br><span class="line">添加 master 主从复制部分配置 </span><br><span class="line">server_id=1 </span><br><span class="line">log-bin=mysql-bin </span><br><span class="line">read-only=0 </span><br><span class="line">binlog-do-db=gulimall_ums </span><br><span class="line">binlog-do-db=gulimall_pms</span><br><span class="line">binlog-do-db=gulimall_oms </span><br><span class="line">binlog-do-db=gulimall_sms </span><br><span class="line">binlog-do-db=gulimall_wms </span><br><span class="line">binlog-do-db=gulimall_admin </span><br><span class="line">replicate-ignore-db=mysql </span><br><span class="line">replicate-ignore-db=sys </span><br><span class="line">replicate-ignore-db=information_schema </span><br><span class="line">replicate-ignore-db=performance_schema</span><br><span class="line"></span><br><span class="line">添加 slaver主从复制部分配置 </span><br><span class="line">server_id=2 </span><br><span class="line">log-bin=mysql-bin </span><br><span class="line">read-only=1binlog-do-db=gulimall_ums </span><br><span class="line">binlog-do-db=gulimall_pms </span><br><span class="line">binlog-do-db=gulimall_oms </span><br><span class="line">binlog-do-db=gulimall_sms </span><br><span class="line">binlog-do-db=gulimall_wms </span><br><span class="line">binlog-do-db=gulimall_admin </span><br><span class="line">replicate-ignore-db=mysql </span><br><span class="line">replicate-ignore-db=sys </span><br><span class="line">replicate-ignore-db=information_schema </span><br><span class="line">replicate-ignore-db=performance_schema</span><br><span class="line"></span><br><span class="line">Master授权用户</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* to &#x27;backup&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;; </span><br><span class="line"></span><br><span class="line">Master授权用户</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* to &#x27;backup&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;; </span><br><span class="line"></span><br><span class="line">Slaver设置主库连接</span><br><span class="line">change master to </span><br><span class="line">master_host=&#x27;192.168.124.135&#x27;,master_user=&#x27;backup&#x27;,master_password=&#x27;123456&#x27;,mas </span><br><span class="line">ter_log_file=&#x27;mysql-bin.000001&#x27;,master_log_pos=0,master_port=3307;</span><br></pre></td></tr></table></figure><p>1）、主从数据库在自己配置文件中声明需要同步哪个数据库，忽略哪个数据库等信息。并且 server-id 不能一样 </p><p>2）、主库授权某个账号密码来同步自己的数据 </p><p>3）、从库使用这个账号密码连接主库来同步数据</p><h2 id="ShardingSphere"><a href="#ShardingSphere" class="headerlink" title="ShardingSphere"></a>ShardingSphere</h2><p>ShardingSphere-Proxy</p><p><img src="https://shardingsphere.apache.org/document/current/img/shardingsphere-proxy_v2.png" alt="ShardingSphere-Proxy Architecture"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">docker：</span><br><span class="line">docker run -d </span><br><span class="line">-v /mydata/sharding-proxy/conf:/opt/sharding-proxy/conf </span><br><span class="line">-v /mydata/sharding-proxy/lib:/opt/sharding-proxy/lib </span><br><span class="line">--env PORT=3308 </span><br><span class="line">-p13308:3308 apache/sharding-proxy:latest</span><br><span class="line">配置数据分片+读写分离:</span><br><span class="line">schemaName: sharding_db_0</span><br><span class="line">dataSources:</span><br><span class="line">  write_0_ds:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3307/demo_ds_0?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br><span class="line">  read_ds_0:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3317/demo_ds_0?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash">schemaName: sharding_db_1</span></span><br><span class="line">dataSources:</span><br><span class="line">  write_1_ds:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3307/demo_ds_1?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br><span class="line">  read_ds_1:</span><br><span class="line">    url: jdbc:mysql://192.168.124.135:3317/demo_ds_1?serverTimezone=UTC&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    connectionTimeoutMilliseconds: 30000</span><br><span class="line">    idleTimeoutMilliseconds: 60000</span><br><span class="line">    maxLifetimeMilliseconds: 1800000</span><br><span class="line">    maxPoolSize: 50</span><br><span class="line">    minPoolSize: 1</span><br></pre></td></tr></table></figure><p>分库分表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309075942273.png" alt="image-20220309075942273"></p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h3><p>1、客户端分区</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131147587.png" alt="image-20220309131147587"></p><p>客户端分区方案 的代表为 Redis Sharding，Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的 Redis 多实例集群 方法。Java 的 Redis 客户端驱动库 Jedis，支持 Redis Sharding 功能，即 ShardedJedis 以及 结合缓存池 的 ShardedJedisPool。 </p><p>优点：不使用 第三方中间件，分区逻辑可控，配置 简单，节点之间无关联，容易 线性扩展，灵活性强。 </p><p>缺点：客户端无法动态增删服务节点，客户端需要自行维护分发逻辑，客户端之间 无连接共享，会造成连接浪费。</p><p>2、代理分区</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131230974.png" alt="image-20220309131230974"></p><p>代理分区常用方案有 Twemproxy 和 Codis。</p><p>3、redis-cluster</p><p>redis官方推荐</p><h3 id="高可用方式"><a href="#高可用方式" class="headerlink" title="高可用方式"></a>高可用方式</h3><p>1、Sentinel（ 哨兵机制）支持高可用</p><p>前面介绍了主从机制，但是从运维角度来看，主节点出现了问题我们还需要通过人工干预的方式把从节点设为主节点，还要通知应用程序更新主节点地址，这种方式非常繁琐笨重， 而 且主节点的读写能力都十分有限，有没有较好的办法解决这两个问题，哨兵机制就是针对第 一个问题的有效解决方案，第二个问题则有赖于集群！哨兵的作用就是监控 Redis 系统的运行状况，其功能主要是包括以下三个：</p><ul><li><p>监控(Monitoring): 哨兵(sentinel) 会不断地检查你的 Master 和 Slave 是否运作常。 </p></li><li><p>提醒(Notification): 当被监控的某个 Redis 出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。 </p></li><li><p>自动故障迁移(Automatic failover): 当主数据库出现故障时自动将从数据库转换为主数 据库。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131342915.png" alt="image-20220309131342915"></p><p><strong>哨兵的原理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ Redis Sentinel</span><br><span class="line">+ 三个定时监控任务</span><br><span class="line">+ 向主节点发送请求获取最新拓扑结构</span><br><span class="line">+ 向redis节点的哨兵频道发送故障判断及自身节点信息</span><br><span class="line">+ 哨兵之间订阅哨兵频道，了解集群信息</span><br><span class="line">+ 向全部节点（包括哨兵）发送心跳检测</span><br><span class="line">+ 心跳检测异常，判断下线</span><br><span class="line">+ 主节点判断下线</span><br><span class="line">+ 需要多个哨兵检测下线票数</span><br><span class="line">+ 故障检测和leader选举</span><br><span class="line">+ 主节点判断下线</span><br><span class="line">+ 采用Raft算法选举leader（详见前几次博客：Raft原理）</span><br></pre></td></tr></table></figure><p>2、redis-cluster</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ Redis Cluster</span><br><span class="line">+ 3主3从</span><br><span class="line">+ 故障转移</span><br><span class="line">+ 选举从节点上位</span><br><span class="line">+ key路由</span><br><span class="line">+ 哈希槽分区：16384槽位</span><br><span class="line">+ 数据迁移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131556005.png" alt="image-20220309131556005"></p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>1、哈希槽分区（CRC16校验算法）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309131813090.png" alt="image-20220309131813090"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 哈希槽分区</span><br><span class="line">+ 问题限制</span><br><span class="line">+ key批量操作</span><br><span class="line">+ mset、mget只支持相同slot值的key批量操作</span><br><span class="line">+ 映射为不同slot分布在不同节点</span><br><span class="line">+ key事务操作</span><br><span class="line">+ 只支持key在同一节点事务</span><br><span class="line">+ key作为分区最小粒度</span><br><span class="line">+ 不能将大的键值对象，如hash、list映射不同节点</span><br><span class="line">+ 不支持多数据库空间</span><br><span class="line">+ 集群模式只有一个数据库db0</span><br><span class="line">+ 复制结构只支持一层</span><br><span class="line">+ 从节点 只能复制 主节点，不支持 嵌套树状复制 结构</span><br><span class="line">+ 命令大多会重定向，耗时多</span><br><span class="line">+ 非本节点数据</span><br></pre></td></tr></table></figure><p>2、一致性哈希</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220309132413181.png" alt="image-20220309132413181"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 一致性哈希</span><br><span class="line">+ 稳定性</span><br><span class="line">+ 哈希倾斜问题</span><br><span class="line">+ 引入虚拟节点</span><br><span class="line">+ 将虚拟节点数据划分到其真实数据节点，保证负载均衡</span><br></pre></td></tr></table></figure><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for port in $(seq 7001 7006); \ </span><br><span class="line">do \ </span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf </span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf </span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf </span><br><span class="line">port $&#123;port&#125; </span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-config-file nodes.conf </span><br><span class="line">cluster-node-timeout 5000 </span><br><span class="line">cluster-announce-ip 192.168.56.10cluster-announce-port $&#123;port&#125; </span><br><span class="line">cluster-announce-bus-port 1$&#123;port&#125; </span><br><span class="line">appendonly yes </span><br><span class="line">EOF </span><br><span class="line">docker run -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; --name redis-$&#123;port&#125; \ </span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/data:/data \ </span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \ </span><br><span class="line">-d redis:5.0.7 redis-server /etc/redis/redis.conf; \ </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">docker exec -it redis-7001 bash redis-cli --cluster create 192.168.56.10:7001 192.168.56.10:7002 192.168.56.10:7003 192.168.56.10:7004 192.168.56.10:7005 192.168.56.10:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure><h2 id="Elasticsearch集群"><a href="#Elasticsearch集群" class="headerlink" title="Elasticsearch集群"></a>Elasticsearch集群</h2><p>elasticsearch 是<strong>天生支持集群</strong>的，他不需要依赖其他的服务发现和注册的组件，如 zookeeper 这些，因为他内置了一个名字叫 ZenDiscovery 的模块，是 elasticsearch 自己实现的一套用于节点发现和选主等功能的组件，所以 elasticsearch 做起集群来非常简单，不需要太多额外的配置和安装额外的第三方组件。</p><h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">+ 节点</span><br><span class="line">+ 主节点</span><br><span class="line">+ 管理集群变更</span><br><span class="line">+ 任意节点知道任意文档位置</span><br><span class="line">+ 请求转发到存储文档的节点</span><br><span class="line">+ 集群健康</span><br><span class="line">+ yellow</span><br><span class="line">+ 主分片正常运行，副本分片不正常</span><br><span class="line">+ green</span><br><span class="line">+ red</span><br><span class="line">+ 分片</span><br><span class="line">+ 全部数据的一部分</span><br><span class="line">+ 主分片</span><br><span class="line">+ 决定索引保存的最大数据量</span><br><span class="line">+ 副本分片</span><br><span class="line">+ 随时可以修改</span><br><span class="line">+ 索引建立时确定主分片、副本分片数量</span><br><span class="line">+ 新增节点</span><br><span class="line">+ 自动发现、加入集群</span><br><span class="line">        + 节点相同clustre.name</span><br><span class="line">        + 配置可连接到的主机列表</span><br><span class="line">+ 水平扩容</span><br><span class="line">+ 自动迁移分片</span><br><span class="line">+ 动态扩大副本数量</span><br><span class="line">+ 提高集群搜索性能</span><br><span class="line">+ 应对故障</span><br><span class="line">+ 节点宕机</span><br><span class="line">+ 集群选主</span><br><span class="line">+ 副本分片提升为主分片</span><br><span class="line">+ 节点恢复</span><br><span class="line">+ 缺失副本分片重新分配</span><br><span class="line">+ 问题与解决</span><br><span class="line">+ 主节点</span><br><span class="line">+ 创建索引、删除索引、分配分片、追踪集群状态</span><br><span class="line">+ 负责分发和返回结果</span><br><span class="line">+ 首先成为候选主节点</span><br><span class="line">+ 候选主节点</span><br><span class="line">+ 选举其中一个作为主节点</span><br><span class="line">+ 问题</span><br><span class="line">+ master选择分歧，导致主分片、副本分歧</span><br><span class="line">+ 数据节点</span><br><span class="line">+ 负责数据存储、聚合等</span><br><span class="line">+ 集群需要设置专用候选主节点和数据节点</span><br><span class="line">+ 避免因数据节点负载重导 致主节点不响应</span><br><span class="line">+ 客户端节点</span><br><span class="line">+ 非主节点、数据节点</span><br><span class="line">+ 只负责请求的分发、汇总</span><br><span class="line">+ 为了负载均衡</span><br><span class="line">+ 脑裂问题可能的原因</span><br><span class="line">+ 网络问题</span><br><span class="line">+ 一些节点访问不到master</span><br><span class="line">+ 选举新master</span><br><span class="line">+ 节点负载</span><br><span class="line">+ 主节点既为master又为data</span><br><span class="line">+ 访问过大，es延迟响应等</span><br><span class="line">+ 其他节点选举新master</span><br><span class="line">+ 内存回收</span><br><span class="line">+ data节点占用内存较大</span><br><span class="line">+ JVM大规模内存回收</span><br><span class="line">+ es失去响应</span><br><span class="line">+ 脑裂问题解决方案</span><br><span class="line">+ 角色分离</span><br><span class="line">+ master节点与data节点分离，限制角色</span><br><span class="line">+ 减少master节点工作压力</span><br><span class="line">+ 减少误判</span><br><span class="line">+ 配置主节点响应时间延长</span><br><span class="line">+ 减少宕机误判</span><br><span class="line">+ 选举触发</span><br><span class="line">+ 设置选举触发资格</span><br><span class="line">+ 集群大于一半的节点相互连接才能进行选举</span><br><span class="line">+ 防止少部分节点失联独自选举</span><br></pre></td></tr></table></figure><h3 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h3><p>  以三台物理机为例。在这三台物理机上，搭建了 6 个 ES 的节点，三个 data 节点，三个 master 节点（每台物理机分别起了一个 data 和一个 master），3 个 master 节点，目的是达到（n/2） +1 等于 2 的要求，这样挂掉一台 master 后（不考虑 data），n 等于 2，满足参数，其他两个 master 节点都认为 master 挂掉之后开始重新选举</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310232611812.png" alt="image-20220310232611812"></p><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">1、防止 JVM 报错</span><br><span class="line">echo vm.max_map_count=262144 &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line">2、准备docker网络（创建自己的 bridge 网络）</span><br><span class="line">docker network create --driver bridge --subnet=172.18.12.0/16 --gateway=172.18.1.1 mynet</span><br><span class="line">3、master*3节点创建</span><br><span class="line">for port in $(seq 1 3); \ </span><br><span class="line">do \ </span><br><span class="line">mkdir -p /mydata/elasticsearch/master-$&#123;port&#125;/config </span><br><span class="line">mkdir -p /mydata/elasticsearch/master-$&#123;port&#125;/data </span><br><span class="line">chmod -R 777 /mydata/elasticsearch/master-$&#123;port&#125; </span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/elasticsearch/master-$&#123;port&#125;/config/elasticsearch.yml </span><br><span class="line">cluster.name: my-es #集群的名称，同一个集群该值必须设置成相同的 </span><br><span class="line">node.name: es-master-$&#123;port&#125; #该节点的名字 </span><br><span class="line">node.master: true #该节点有机会成为 master 节点 </span><br><span class="line">node.data: false #该节点可以存储数据 </span><br><span class="line">network.host: 0.0.0.0 </span><br><span class="line">http.host: 0.0.0.0 #所有 http 均可访问 </span><br><span class="line">http.port: 920$&#123;port&#125; </span><br><span class="line">transport.tcp.port: 930$&#123;port&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.minimum_master_nodes: 2 <span class="comment">#设置这个参数来保证集群中的节点可以知道其</span></span> </span><br><span class="line">它 N 个有 master 资格的节点。官方推荐（N/2）+1 </span><br><span class="line">discovery.zen.ping_timeout: 10s #设置集群中自动发现其他节点时 ping 连接的超时时间 </span><br><span class="line">discovery.seed_hosts: [&quot;172.18.12.21:9301&quot;, &quot;172.18.12.22:9302&quot;, &quot;172.18.12.23:9303&quot;] #设置集 </span><br><span class="line">群中的 Master 节点的初始列表，可以通过这些节点来自动发现其他新加入集群的节点，es7 </span><br><span class="line">的新增配置 </span><br><span class="line">cluster.initial_master_nodes: [&quot;172.18.12.21&quot;] #新集群初始时的候选主节点，es7 的新增配置 </span><br><span class="line">EOF </span><br><span class="line">docker run --name elasticsearch-node-$&#123;port&#125; \ </span><br><span class="line">-p 920$&#123;port&#125;:920$&#123;port&#125; -p 930$&#123;port&#125;:930$&#123;port&#125; \ </span><br><span class="line">--network=mynet --ip 172.18.12.2$&#123;port&#125; \-e ES_JAVA_OPTS=&quot;-Xms300m -Xmx300m&quot; \ </span><br><span class="line">-v</span><br><span class="line"><span class="meta">/mydata/elasticsearch/master-$</span><span class="bash">&#123;port&#125;/config/elasticsearch.yml:/usr/share/elasticsearch/config/el</span> </span><br><span class="line">asticsearch.yml \ </span><br><span class="line">-v /mydata/elasticsearch/master-$&#123;port&#125;/data:/usr/share/elasticsearch/data \ </span><br><span class="line">-v /mydata/elasticsearch/master-$&#123;port&#125;/plugins:/usr/share/elasticsearch/plugins \ </span><br><span class="line">-d elasticsearch:7.4.2 </span><br><span class="line">done </span><br><span class="line">4、data-node*3节点创建</span><br><span class="line">for port in $(seq 4 6); \ </span><br><span class="line">do \ </span><br><span class="line">mkdir -p /mydata/elasticsearch/node-$&#123;port&#125;/config </span><br><span class="line">mkdir -p /mydata/elasticsearch/node-$&#123;port&#125;/data </span><br><span class="line">chmod -R 777 /mydata/elasticsearch/node-$&#123;port&#125; </span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/elasticsearch/node-$&#123;port&#125;/config/elasticsearch.yml </span><br><span class="line">cluster.name: my-es #集群的名称，同一个集群该值必须设置成相同的 </span><br><span class="line">node.name: es-node-$&#123;port&#125; #该节点的名字 </span><br><span class="line">node.master: false #该节点有机会成为 master 节点 </span><br><span class="line">node.data: true #该节点可以存储数据 </span><br><span class="line">network.host: 0.0.0.0 </span><br><span class="line"><span class="meta">#</span><span class="bash">network.publish_host: 192.168.56.10 <span class="comment">#互相通信 ip，要设置为本机可被外界访问的 ip，否则</span></span> </span><br><span class="line">无法通信 </span><br><span class="line">http.host: 0.0.0.0 #所有 http 均可访问 </span><br><span class="line">http.port: 920$&#123;port&#125; </span><br><span class="line">transport.tcp.port: 930$&#123;port&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.minimum_master_nodes: 2 <span class="comment">#设置这个参数来保证集群中的节点可以知道其</span></span> </span><br><span class="line">它 N 个有 master 资格的节点。官方推荐（N/2）+1 </span><br><span class="line">discovery.zen.ping_timeout: 10s #设置集群中自动发现其他节点时 ping 连接的超时时间 </span><br><span class="line">discovery.seed_hosts: [&quot;172.18.12.21:9301&quot;, &quot;172.18.12.22:9302&quot;, &quot;172.18.12.23:9303&quot;] #设置集 </span><br><span class="line">群中的 Master 节点的初始列表，可以通过这些节点来自动发现其他新加入集群的节点，es7 </span><br><span class="line">的新增配置 </span><br><span class="line">cluster.initial_master_nodes: [&quot;172.18.12.21&quot;] #新集群初始时的候选主节点，es7 的新增配置 </span><br><span class="line">EOF </span><br><span class="line">docker run --name elasticsearch-node-$&#123;port&#125; \ </span><br><span class="line">-p 920$&#123;port&#125;:920$&#123;port&#125; -p 930$&#123;port&#125;:930$&#123;port&#125; \ </span><br><span class="line">--network=mynet --ip 172.18.12.2$&#123;port&#125; \ </span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms300m -Xmx300m&quot; \ </span><br><span class="line"><span class="meta">-v/mydata/elasticsearch/node-$</span><span class="bash">&#123;port&#125;/config/elasticsearch.yml:/usr/share/elasticsearch/config/ela</span> </span><br><span class="line">sticsearch.yml \ </span><br><span class="line">-v /mydata/elasticsearch/node-$&#123;port&#125;/data:/usr/share/elasticsearch/data \ </span><br><span class="line">-v /mydata/elasticsearch/node-$&#123;port&#125;/plugins:/usr/share/elasticsearch/plugins \ </span><br><span class="line">-d elasticsearch:7.4.2 </span><br><span class="line">done </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310234921706.png" alt="image-20220310234921706"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310234912741.png" alt="image-20220310234912741"></p><h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><p>RabbiMQ 是用 Erlang 开发的，集群非常方便，因为 Erlang 天生就是一门分布式语言，但其本身并不支持负载均衡。 </p><p>RabbitMQ 集群中节点包括**内存节点(RAM)<strong>、</strong>磁盘节点(Disk，消息持久化)**，集群中至少有 一个 Disk 节点。</p><h3 id="集群原理-1"><a href="#集群原理-1" class="headerlink" title="集群原理"></a>集群原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ 集群形式</span><br><span class="line">+ 普通模式</span><br><span class="line">+ 集群特点</span><br><span class="line">            + 各节点相同队列结构</span><br><span class="line">            + 消息只存在于一个节点</span><br><span class="line">            + 消费者消费，需要通过节点直接转发</span><br><span class="line">+ 应用场景</span><br><span class="line">+ 适合消息无需持久化场景，日志队列等</span><br><span class="line">+ 宕机时可直接连接其他节点，只需重新创建队列</span><br><span class="line">+ 镜像模式</span><br><span class="line">+ 集群特点</span><br><span class="line">            + 消息实体会主动在镜像节点间同步（消息到队列时）</span><br><span class="line">            + mirror queue选举算法</span><br><span class="line">                + 1个master，n个slaver</span><br><span class="line">                + 生产者、消费者请求转至master</span><br><span class="line">+ 镜像集群基于普通集群</span><br><span class="line">+ 先搭建普通集群，再设置镜像队列</span><br><span class="line">+ 缺点</span><br><span class="line">+ 镜像队列过多，且消息体量大</span><br><span class="line">+ 集群内部网络带宽将会被此种同步通讯所消耗</span><br><span class="line">+ 应用场景</span><br><span class="line">+ 可靠性要求较高场合，如下单、库存队列</span><br><span class="line">        + 若消费过程中，master 挂掉，则选举新 master</span><br><span class="line">           + 若未来得及确认，则可能会重复消费</span><br></pre></td></tr></table></figure><h3 id="集群搭建-1"><a href="#集群搭建-1" class="headerlink" title="集群搭建"></a>集群搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、启动容器</span><br><span class="line">mkdir /mydata/rabbitmq </span><br><span class="line">cd rabbitmq/ </span><br><span class="line">mkdir rabbitmq01 rabbitmq02 rabbitmq03</span><br><span class="line">docker run -d --hostname rabbitmq01 --name rabbitmq01 -v /mydata/rabbitmq/rabbitmq01:/var/lib/rabbitmq -p 15673:15672 -p 5673:5672 -e RABBITMQ_ERLANG_COOKIE=&#x27;atguigu&#x27; rabbitmq:management</span><br><span class="line">docker run -d --hostname rabbitmq02 --name rabbitmq02 -v</span><br><span class="line">/mydata/rabbitmq/rabbitmq02:/var/lib/rabbitmq -p 15674:15672 -p 5674:5672 -e RABBITMQ_ERLANG_COOKIE=&#x27;atguigu&#x27; --link rabbitmq01:rabbitmq01 rabbitmq:management</span><br><span class="line">docker run -d --hostname rabbitmq03 --name rabbitmq03 -v /mydata/rabbitmq/rabbitmq03:/var/lib/rabbitmq -p 15675:15672 -p 5675:5672 -e RABBITMQ_ERLANG_COOKIE=&#x27;atguigu&#x27; --link rabbitmq01:rabbitmq01 --link rabbitmq02:rabbitmq02 rabbitmq:management</span><br><span class="line">--hostname 设置容器的主机名 </span><br><span class="line">RABBITMQ_ERLANG_COOKIE 节点认证作用，部署集成时 需要同步该值</span><br><span class="line">2、节点加入集群</span><br><span class="line">docker exec -it rabbitmq01 /bin/bash </span><br><span class="line">rabbitmqctl stop_app </span><br><span class="line">rabbitmqctl reset </span><br><span class="line">rabbitmqctl start_app </span><br><span class="line">进入第二个节点 </span><br><span class="line">docker exec -it rabbitmq02 /bin/bash rabbitmqctl stop_app rabbitmqctl reset rabbitmqctl join_cluster --ram rabbit@rabbitmq01 rabbitmqctl start_app exit </span><br><span class="line">进入第三个节点 docker exec -it rabbitmq03 bash rabbitmqctl stop_app rabbitmqctl reset rabbitmqctl join_cluster --ram rabbit@rabbitmq01 rabbitmqctl start_app exit</span><br><span class="line">3、实现镜像集群</span><br><span class="line">docker exec -it rabbitmq01 bash</span><br><span class="line">rabbitmqctl set_policy -p / ha &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27; </span><br><span class="line">可以使用 rabbitmqctl list_policies -p /；查看 vhost/下面的所有 policy</span><br><span class="line">在 cluster 中任意节点启用策略，策略会自动同步到集群节点</span><br><span class="line">rabbitmqctl set_policy-p/ha-all&quot;^&quot;’&#123;“ha-mode”:“all”&#125;’</span><br><span class="line">策略模式 all 即复制到所有节点，包含新增节点，策略正则表达式为 “^” 表示所有匹配所有队列名称。“^hello”表示只匹配名为 hello 开始的队列</span><br></pre></td></tr></table></figure><p>改为镜像集群：同步</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220310234800034.png" alt="image-20220310234800034"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——云原生核心-Kubernetes</title>
      <link href="/2022/03/06/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A0%B8%E5%BF%83-Kubernetes/"/>
      <url>/2022/03/06/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A0%B8%E5%BF%83-Kubernetes/</url>
      
        <content type="html"><![CDATA[<h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker只是解决服务下层的问题，服务上层建筑如容器编排，服务发现等问题已经超越了Docker的管辖。</p><p>Kubernetes提供的编排和管理功能，轻松完成大规模容器部署，借助k8s的编排功能，用户可以构建跨多个容器的应用服务，实现跨集群调度，扩展容器，以及长期持续管理这些容器的健康状况等，并整合网络，存储，安全性，监控及其他服务，提供全面的容器基础架构。</p><p>Kubernetes 满足了一系列产品内运行程序的普通需求，兼具平台即服务（PaaS）的简化和基础架构即服务（IaaS）的灵活，并促进了在平台服务提供商之间的迁移。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225820940.png" alt="image-20220306225820940"></p><p><strong>微服务</strong><br>微服务解决的是我们软件开发中一直追求的低耦合+高内聚，微服务可以解决这个问题，微服务的本质是把一块大饼分成若干块低耦合的小饼，比如一块小饼专门负责接收外部的数据，一块小饼专门负责响应前台的操作，小饼可以进一步拆分，比如负责接收外部数据的小饼可以继续分成多块负责接收不同类型数据的小饼，这样每个小饼出问题了，其它小饼还能正常对外提供服务。</p><p><strong>DevOps</strong><br>DevOps的意思就是开发和运维不再是分开的两个团队，而是你中有我，我中有你的一个团队。我们现在开发和运维已经是一个团队了，但是运维方面的知识和经验还需要持续提高。</p><p><strong>持续交付</strong><br>持续交付的意思就是在不影响用户使用服务的前提下频繁把新功能发布给用户使用，要做到这点非常非常难。我们现在两周一个版本，每次上线之后都会给不同的用户造成不同程度的影响。</p><p><strong>容器化</strong><br>容器化的好处在于运维的时候不需要再关心每个服务所使用的技术栈了，每个服务都被无差别地封装在容器里，可以被无差别地管理和维护，现在比较流行的工具是docker和k8s。</p><p>简单地把云原生理解为：云原生 = 微服务 + DevOps + 持续交付 + 容器化</p><p>k8s官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>整体主从方式</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230018184.png" alt="image-20220306230018184"></p><ul><li><p>组件</p><ul><li><p>master</p><ul><li>kube-apiserver<ul><li>外界进行资源操作的入口</li><li>认证、授权、访问控制、api注册、发现</li></ul></li><li>etcd<ul><li>nosql数据库</li><li>集群数据</li></ul></li><li>kube-schedule<ul><li>从etcd中获取任务进行调度，选择节点运行</li><li>所有对k8s集群的操作，都必须经过主节点</li></ul></li><li>kube-controller-manager<ul><li>node controller（节点控制器）<ul><li>在节点出现故障时进行通知和响应</li></ul></li><li>replication controller（副本控制器）<ul><li>部署</li></ul></li><li>endpoints controller（端点控制器）<ul><li>暴露端口之类的</li></ul></li><li>service account &amp; token controllers<ul><li>控制安全</li></ul></li></ul></li></ul></li><li><p>node</p><ul><li>container runtime<ul><li>容器运行环境，如docker</li></ul></li><li>kubelet<ul><li>每个节点的代理，保证容器都运行在Pod中<ul><li>pod：一组容器，最小部署单元</li></ul></li><li>维护容器的生命周期，数据卷、网络</li></ul></li><li>kube-proxy<ul><li>每个节点的网络代理，帮助请求路由和访问具体容器</li></ul></li><li>fluentd<ul><li>节点日志收集</li></ul></li></ul></li></ul></li></ul><p>master</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230319472.png" alt="image-20220306230319472"></p><p>node</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230348661.png" alt="image-20220306230348661"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230401741.png" alt="image-20220306230401741"></p><ul><li><p>Container：容器，可以是 docker 启动的一个容器 </p></li><li><p>Pod： </p><ul><li>k8s 使用 Pod 来组织一组容器 </li><li>一个 Pod 中的所有容器共享同一网络。 </li><li>Pod 是 k8s 中的最小部署单元 </li></ul></li><li><p>Volume </p><ul><li>声明在 Pod 容器中可访问的文件目录 </li><li>可以被挂载在 Pod 中一个或多个容器指定路径下 </li><li>支持多种后端存储抽象(本地存储，分布式存储，云存储…) </li></ul></li><li><p>Controllers：更高层次对象，部署和管理 Pod；</p><ul><li>ReplicaSet：确保预期的 Pod 副本数量 </li><li>Deplotment：无状态应用部署 </li><li>StatefulSet：有状态应用部署 </li><li>DaemonSet：确保所有 Node 都运行一个指定 Pod </li><li>Job：一次性任务 </li><li>Cronjob：定时任务 </li></ul></li><li><p>Deployment： </p><ul><li>定义一组 Pod 的副本数目、版本等 </li><li>通过控制器（Controller）维持 Pod 数目(自动回复失败的 Pod) </li><li>通过控制器以指定的策略控制版本（滚动升级，回滚等） </li></ul></li><li><p>Service </p><ul><li>定义一组 Pod 的访问策略 </li><li>Pod 的负载均衡，提供一个或者多个 Pod 的稳定访问地址 </li><li>支持多种方式（ClusterIP、NodePort、LoadBalance） </li></ul></li><li><p>Label：标签，用于对象资源的查询，筛选 </p></li><li><p>Namespace：命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制（鉴权，资源） </li><li>每个资源都属于一个 namespace </li><li>同一个 namespace 所有资源名不能重复 </li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230837907.png" alt="image-20220306230837907"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 流程</span><br><span class="line">    + kubectl——apiserver——etcd</span><br><span class="line">    + controller manager——监听——apiserver</span><br><span class="line">    + 发现pod未创建</span><br><span class="line">    + 根据pod模板生成pod对象，apiserver——etcd</span><br><span class="line">    + scheduler——监听——选定node，apiserver——etcd</span><br><span class="line">    + kubelet——监听——启动pod</span><br></pre></td></tr></table></figure><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>调度</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225909169.png" alt="image-20220306225909169"></p><p>自动恢复</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225921697.png" alt="image-20220306225921697"></p><p>水平伸缩</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225940799.png" alt="image-20220306225940799"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231026852.png" alt="image-20220306231026852"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231116495.png" alt="image-20220306231116495"></p><p>1、设置 linux 环境</p><p>2、所有节点安装 Docker、kubeadm、kubelet、kubectl</p><p>3、安装 Pod 网络插件（CNI）</p><p>4、加入 Kubernetes Node </p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231924323.png" alt="image-20220306231924323"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>pod、controller</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232549267.png" alt="image-20220306232549267"></p><p>deployment、service</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232559381.png" alt="image-20220306232559381"></p><p>labels、selectors</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232631265.png" alt="image-20220306232631265"></p><p>ingress</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232639695.png" alt="image-20220306232639695"></p><p>ingress——&gt;service——&gt;pod——&gt;container</p><p>网络模型</p><p>Kubernetes的网络模型从内至外由四个部分组成：</p><p>1、Pod内部容器所在的网络 </p><p>2、Pod所在的网络 </p><p>3、Pod和Service之间通信的网络</p><p>4、外界与Service之间通信的网络</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232717133.png" alt="image-20220306232717133"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——高并发（秒杀）系统&amp;Sentinel&amp;链路追踪</title>
      <link href="/2022/03/04/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E7%A7%92%E6%9D%80%EF%BC%89%E7%B3%BB%E7%BB%9F&amp;Sentinel&amp;%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
      <url>/2022/03/04/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E7%A7%92%E6%9D%80%EF%BC%89%E7%B3%BB%E7%BB%9F&amp;Sentinel&amp;%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="1、秒杀业务"><a href="#1、秒杀业务" class="headerlink" title="1、秒杀业务"></a>1、秒杀业务</h1><p>秒杀具有瞬间高并发的特点，针对这一特点，必须要做限流 + 异步 + 缓存（页面静态化）+ 独立部署。 </p><h2 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304221850788.png" alt="image-20220304221850788"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304221910750.png" alt="image-20220304221910750"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ 秒杀（高并发）系统关注的问题</span><br><span class="line">    + 独立部署</span><br><span class="line">    + 防止影响其他服务</span><br><span class="line">    + 链接加密</span><br><span class="line">    + 防止请求暴露，恶意攻击</span><br><span class="line">    + 库存预热</span><br><span class="line">        + redis信号量</span><br><span class="line">        + redis高可用</span><br><span class="line">    + 动静分离</span><br><span class="line">        + nginx</span><br><span class="line">        + cdn</span><br><span class="line">    + 恶意请求拦截</span><br><span class="line">    + 网关层</span><br><span class="line">    + 流量错峰</span><br><span class="line">        + 小米：验证码</span><br><span class="line">        + 验证正常请求</span><br><span class="line">    + 流量错峰</span><br><span class="line">   + 加入购物车</span><br><span class="line">    + 结算时间不同，流量错峰</span><br><span class="line">    + 限流&amp;熔断&amp;降级</span><br><span class="line">        + 限流</span><br><span class="line">            + 前端限流</span><br><span class="line">            + 点击次数、间隔限制</span><br><span class="line">            + 后端限流</span><br><span class="line">                + 筛选非用户行为</span><br><span class="line">                + 限制请求次数、总量            </span><br><span class="line">            + nginx限流</span><br><span class="line">            + 直接负载部分请求到错误的静态页面</span><br><span class="line">            + 令牌算法 漏斗算法</span><br><span class="line">            + 网关限流</span><br><span class="line">            + 限流的过滤器</span><br><span class="line">        + 熔断、降级</span><br><span class="line">            + 调用链路异常，快速失败熔断</span><br><span class="line">            + 流量太大，引导部分请求降级</span><br><span class="line">    + 队列削峰（杀手锏）</span><br><span class="line">        + 抢到信号量的放行后台</span><br><span class="line">        + 后台发送消息到队列，返回秒杀成功回调</span><br><span class="line">        + 订单服务等监听队列，慢慢创建订单处理成功秒杀的消息</span><br></pre></td></tr></table></figure><h2 id="秒杀商品上架（定时、异步、幂等性）、展示、渲染"><a href="#秒杀商品上架（定时、异步、幂等性）、展示、渲染" class="headerlink" title="秒杀商品上架（定时、异步、幂等性）、展示、渲染"></a>秒杀商品上架（定时、异步、幂等性）、展示、渲染</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304222418396.png" alt="image-20220304222418396"></p><p>定时任务&amp;异步任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ 开启定时任务@EnableScheduling</span><br><span class="line">+ 定时方法注解@Scheduled</span><br><span class="line">+ spring中区别</span><br><span class="line">        + cron语法</span><br><span class="line">        + 默认阻塞</span><br><span class="line">+ 解决阻塞</span><br><span class="line">        + 异步编排运行，自己提交到线程池</span><br><span class="line">        + 支持定时任务线程池（线程池默认大小为一）</span><br><span class="line">            + 配置文件设置线程池大小</span><br><span class="line">            + 不太好使</span><br><span class="line">        + 让定时任务异步执行（异步任务）</span><br><span class="line"></span><br><span class="line">+ 异步任务</span><br><span class="line">    + 开启异步任务@EnableAsync</span><br><span class="line">    + 异步方法注解@Async</span><br><span class="line">        + 默认使用线程池，大小为8</span><br><span class="line">        + 可配置线程池属性</span><br><span class="line"></span><br><span class="line">+ 在Spring中表达式是6位组成，不允许第七位的年份</span><br><span class="line">+ 在周几的的位置,1-7代表周一到周日</span><br><span class="line">+ 定时任务不该阻塞。默认是阻塞的</span><br><span class="line">+ 可以让业务以异步的方式，自己提交到线程池</span><br><span class="line">+ CompletableFuture.runAsync(() -&gt; &#123;&#125;,execute);</span><br><span class="line">+ 支持定时任务线程池；设置 TaskSchedulingProperties</span><br><span class="line">+ spring.task.scheduling.pool.size: 5</span><br><span class="line">+ 让定时任务异步执行</span><br><span class="line">+ 异步任务</span><br><span class="line">+ 解决：使用异步任务 + 定时任务来完成定时任务不阻塞的功能</span><br></pre></td></tr></table></figure><p>上架商品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 上架service</span><br><span class="line">    + 远程调用优惠系统，扫描最近三天需要秒杀的商品</span><br><span class="line">    + 查询最近三天秒杀活动</span><br><span class="line">    + 得到最近三天格式化日期 </span><br><span class="line">+ 查询起始时间between起始和结束之间的活动</span><br><span class="line">+ 遍历每一个活动，查询关联商品list</span><br><span class="line">+ 根据活动id查询关联表</span><br><span class="line">    + 封装返回数据Vo</span><br><span class="line">    + 上架商品</span><br><span class="line">+ 缓存到reids</span><br><span class="line">            + 缓存活动信息</span><br><span class="line">                + 遍历活动，获取开始结束时间作为key</span><br><span class="line">                + 收集活动所有商品id list作为value</span><br><span class="line">            + 缓存活动的关联商品信息</span><br><span class="line">                + 准备hash操作</span><br><span class="line">                + 遍历每个商品，商品skuid作为key</span><br><span class="line">                + 商品To（sku秒杀信息、详细信息、随机码、开始结束时间）作为value（转为json）</span><br><span class="line">                + 远程调用商品服务（查询详细信息）</span><br><span class="line">+ 根据sku id查询商品详细信息</span><br><span class="line">                    + 随机码（UUID）</span><br><span class="line">                    + 防止提前脚本发请求秒杀</span><br><span class="line">                    + 秒杀开始才暴露</span><br><span class="line">+ 秒杀商品设置分布式信号量（限流），作为库存扣减信息</span><br><span class="line">                    + 引入redisson</span><br><span class="line">                    + 配置redisson客户端</span><br><span class="line">                    + key：商品随机码</span><br><span class="line">                    + value：商品秒杀数量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304223213629.png" alt="image-20220304223213629"></p><p>幂等性保证</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304223954144.png" alt="image-20220304223954144"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 加入分布式锁</span><br><span class="line">    + 防止多台机器同一时间上架</span><br><span class="line">    + 同时判断key不存在，导致同时追加，所以必须有锁</span><br><span class="line">+ 幂等性保证</span><br><span class="line">    + 缓存活动信息，判断key sessionid是否存在</span><br><span class="line">    + 缓存sku信息，key：场次 + 商品id，判断key sessionid_skuid是否存在</span><br><span class="line">    + 解决多场次同一商品问题</span><br><span class="line">    + 缓存信号量，跟商品是否上架一起执行</span><br></pre></td></tr></table></figure><p>查询秒杀商品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 展示首页秒杀商品</span><br><span class="line">    + controller：判断符合当前时间秒杀场次的商品（获取当前时间可以参与的秒杀商品信息）</span><br><span class="line">        + 确定当前时间属于哪个秒杀场次</span><br><span class="line">        + 遍历所有keys，截取字符串，判断时间</span><br><span class="line">        + 获取秒杀场次的所有商品信息</span><br><span class="line">            + 获取场次所有商品id</span><br><span class="line">            + 根据id获取hash中的商品详情</span><br><span class="line">            + 封装Vo</span><br></pre></td></tr></table></figure><p>秒杀页面渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 秒杀预告</span><br><span class="line">+ 商品页面，查询当前sku是否参与秒杀优惠</span><br><span class="line">    + 远程调用秒杀服务，根据skuid 查询redis商品详情hash</span><br><span class="line">        + 找到所有秒杀商品的key</span><br><span class="line">        + 遍历key正则匹配，找到商品</span><br><span class="line">    + 判断秒杀是否开始，未开始则不暴露随机码</span><br><span class="line">    + feign调用、封装</span><br><span class="line">    + 异步编排</span><br><span class="line">+ 前端取值，格式化日期，三个时间区间判断</span><br><span class="line">        + 未到</span><br><span class="line">        + 正在秒杀</span><br><span class="line">        + 已过，不显示</span><br><span class="line">+ 首页跳转</span><br></pre></td></tr></table></figure><h2 id="秒杀业务（登录检查、）"><a href="#秒杀业务（登录检查、）" class="headerlink" title="秒杀业务（登录检查、）"></a>秒杀业务（登录检查、）</h2><p>登录检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 处于秒杀阶段商品，加入购物车改为立即抢购</span><br><span class="line">+ 秒杀前端跳转请求</span><br><span class="line">    + 登录判断</span><br><span class="line">    + 参数</span><br><span class="line">        + 场次_商品id</span><br><span class="line">        + 随机码（令牌）</span><br><span class="line">        + 件数</span><br><span class="line">+ 处理秒杀请求</span><br><span class="line">    + controller</span><br><span class="line">        + 登录拦截</span><br><span class="line">        + 引入spring-session</span><br><span class="line">                + 序列化器等配置</span><br><span class="line">                + 存储类型为redis</span><br><span class="line">            + 引入登录拦截器</span><br><span class="line">            + 注册拦截器</span><br></pre></td></tr></table></figure><p><strong>秒杀流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一套流程：</span><br><span class="line">+ 购物车——订单确认页——提交订单结算</span><br><span class="line">+ 多个服务都收到高并发流量</span><br><span class="line">+ 同时也错峰了一部分流量</span><br><span class="line">+ 融合和兼容秒杀购买与正常购买流程</span><br><span class="line"></span><br><span class="line">第二套流程：</span><br><span class="line">+ 点击秒杀，合法校验通过直接获取信号量</span><br><span class="line">+ 发送消息给MQ，直接返回秒杀成功</span><br><span class="line">+ 订单等其他服务慢慢处理MQ请求</span><br><span class="line">+ 订单创建完成，用户确认结算即可</span><br><span class="line">+ 优点</span><br><span class="line">    + 流程快速，除了创建订单无需操作数据库、远程调用等</span><br><span class="line">    + 订单服务需要高可用</span><br><span class="line">    + 整个业务独立</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304224859675.png" alt="image-20220304224859675"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponFeignService couponFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductFeignService productFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SESSION__CACHE_PREFIX = <span class="string">&quot;seckill:sessions:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SECKILL_CHARE_PREFIX = <span class="string">&quot;seckill:skus&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SKU_STOCK_SEMAPHORE = <span class="string">&quot;seckill:stock:&quot;</span>;    <span class="comment">//+商品随机码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadSeckillSkuLatest3Days</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、扫描最近三天的商品需要参加秒杀的活动</span></span><br><span class="line">        R lates3DaySession = couponFeignService.getLates3DaySession();</span><br><span class="line">        <span class="keyword">if</span> (lates3DaySession.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//上架商品</span></span><br><span class="line">            List&lt;SeckillSessionWithSkusVo&gt; sessionData = lates3DaySession.getData(<span class="string">&quot;data&quot;</span>, <span class="keyword">new</span> TypeReference&lt;List&lt;SeckillSessionWithSkusVo&gt;&gt;() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//缓存到Redis</span></span><br><span class="line">            <span class="comment">//1、缓存活动信息</span></span><br><span class="line">            saveSessionInfos(sessionData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、缓存活动的关联商品信息</span></span><br><span class="line">            saveSessionSkuInfo(sessionData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存秒杀活动信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveSessionInfos</span><span class="params">(List&lt;SeckillSessionWithSkusVo&gt; sessions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sessions.stream().forEach(session -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前活动的开始和结束时间的时间戳</span></span><br><span class="line">            <span class="keyword">long</span> startTime = session.getStartTime().getTime();</span><br><span class="line">            <span class="keyword">long</span> endTime = session.getEndTime().getTime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存入到Redis中的key</span></span><br><span class="line">            String key = SESSION__CACHE_PREFIX + startTime + <span class="string">&quot;_&quot;</span> + endTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断Redis中是否有该信息，如果没有才进行添加</span></span><br><span class="line">            Boolean hasKey = redisTemplate.hasKey(key);</span><br><span class="line">            <span class="comment">//缓存活动信息</span></span><br><span class="line">            <span class="keyword">if</span> (!hasKey) &#123;</span><br><span class="line">                <span class="comment">//获取到活动中所有商品的skuId</span></span><br><span class="line">                List&lt;String&gt; skuIds = session.getRelationSkus().stream()</span><br><span class="line">                        .map(item -&gt; item.getPromotionSessionId() + <span class="string">&quot;-&quot;</span> + item.getSkuId().toString()).collect(Collectors.toList());</span><br><span class="line">                redisTemplate.opsForList().leftPushAll(key,skuIds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存秒杀活动所关联的商品信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveSessionSkuInfo</span><span class="params">(List&lt;SeckillSessionWithSkusVo&gt; sessions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sessions.stream().forEach(session -&gt; &#123;</span><br><span class="line">            <span class="comment">//准备hash操作，绑定hash</span></span><br><span class="line">            BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">            session.getRelationSkus().stream().forEach(seckillSkuVo -&gt; &#123;</span><br><span class="line">                <span class="comment">//生成随机码</span></span><br><span class="line">                String token = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                String redisKey = seckillSkuVo.getPromotionSessionId().toString() + <span class="string">&quot;-&quot;</span> + seckillSkuVo.getSkuId().toString();</span><br><span class="line">                <span class="keyword">if</span> (!operations.hasKey(redisKey)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//缓存我们商品信息</span></span><br><span class="line">                    SeckillSkuRedisTo redisTo = <span class="keyword">new</span> SeckillSkuRedisTo();</span><br><span class="line">                    Long skuId = seckillSkuVo.getSkuId();</span><br><span class="line">                    <span class="comment">//1、先查询sku的基本信息，调用远程服务</span></span><br><span class="line">                    R info = productFeignService.getSkuInfo(skuId);</span><br><span class="line">                    <span class="keyword">if</span> (info.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">                        SkuInfoVo skuInfo = info.getData(<span class="string">&quot;skuInfo&quot;</span>,<span class="keyword">new</span> TypeReference&lt;SkuInfoVo&gt;()&#123;&#125;);</span><br><span class="line">                        redisTo.setSkuInfo(skuInfo);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2、sku的秒杀信息</span></span><br><span class="line">                    BeanUtils.copyProperties(seckillSkuVo,redisTo);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3、设置当前商品的秒杀时间信息</span></span><br><span class="line">                    redisTo.setStartTime(session.getStartTime().getTime());</span><br><span class="line">                    redisTo.setEndTime(session.getEndTime().getTime());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//4、设置商品的随机码（防止恶意攻击）</span></span><br><span class="line">                    redisTo.setRandomCode(token);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//序列化json格式存入Redis中</span></span><br><span class="line">                    String seckillValue = JSON.toJSONString(redisTo);</span><br><span class="line">                    operations.put(seckillSkuVo.getPromotionSessionId().toString() + <span class="string">&quot;-&quot;</span> + seckillSkuVo.getSkuId().toString(),seckillValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果当前这个场次的商品库存信息已经上架就不需要上架</span></span><br><span class="line">                    <span class="comment">//5、使用库存作为分布式Redisson信号量（限流）</span></span><br><span class="line">                    <span class="comment">// 使用库存作为分布式信号量</span></span><br><span class="line">                    RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);</span><br><span class="line">                    <span class="comment">// 商品可以秒杀的数量作为信号量</span></span><br><span class="line">                    semaphore.trySetPermits(seckillSkuVo.getSeckillCount());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到当前可以参加秒杀商品的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;getCurrentSeckillSkusResource&quot;,blockHandler = &quot;blockHandler&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SeckillSkuRedisTo&gt; <span class="title">getCurrentSeckillSkus</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">&quot;seckillSkus&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//1、确定当前属于哪个秒杀场次</span></span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从Redis中查询到所有key以seckill:sessions开头的所有数据</span></span><br><span class="line">            Set&lt;String&gt; keys = redisTemplate.keys(SESSION__CACHE_PREFIX + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="comment">//seckill:sessions:1594396764000_1594453242000</span></span><br><span class="line">                String replace = key.replace(SESSION__CACHE_PREFIX, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                String[] s = replace.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">                <span class="comment">//获取存入Redis商品的开始时间</span></span><br><span class="line">                <span class="keyword">long</span> startTime = Long.parseLong(s[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//获取存入Redis商品的结束时间</span></span><br><span class="line">                <span class="keyword">long</span> endTime = Long.parseLong(s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断是否是当前秒杀场次</span></span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line">                    <span class="comment">//2、获取这个秒杀场次需要的所有商品信息</span></span><br><span class="line">                    List&lt;String&gt; range = redisTemplate.opsForList().range(key, -<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">                    BoundHashOperations&lt;String, String, String&gt; hasOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">                    <span class="keyword">assert</span> range != <span class="keyword">null</span>;</span><br><span class="line">                    List&lt;String&gt; listValue = hasOps.multiGet(range);</span><br><span class="line">                    <span class="keyword">if</span> (listValue != <span class="keyword">null</span> &amp;&amp; listValue.size() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        List&lt;SeckillSkuRedisTo&gt; collect = listValue.stream().map(item -&gt; &#123;</span><br><span class="line">                            String items = (String) item;</span><br><span class="line">                            SeckillSkuRedisTo redisTo = JSON.parseObject(items, SeckillSkuRedisTo.class);</span><br><span class="line">                            <span class="comment">// redisTo.setRandomCode(null);当前秒杀开始需要随机码</span></span><br><span class="line">                            <span class="keyword">return</span> redisTo;</span><br><span class="line">                        &#125;).collect(Collectors.toList());</span><br><span class="line">                        <span class="keyword">return</span> collect;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;资源被限流&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SeckillSkuRedisTo&gt; <span class="title">blockHandler</span><span class="params">(BlockException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;getCurrentSeckillSkusResource被限流了,&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据skuId查询商品是否参加秒杀活动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillSkuRedisTo <span class="title">getSkuSeckilInfo</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、找到所有需要秒杀的商品的key信息---seckill:skus</span></span><br><span class="line">        BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到所有的key</span></span><br><span class="line">        Set&lt;String&gt; keys = hashOps.keys();</span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//4-45 正则表达式进行匹配</span></span><br><span class="line">            String reg = <span class="string">&quot;\\d-&quot;</span> + skuId;</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="comment">//如果匹配上了</span></span><br><span class="line">                <span class="keyword">if</span> (Pattern.matches(reg,key)) &#123;</span><br><span class="line">                    <span class="comment">//从Redis中取出数据来</span></span><br><span class="line">                    String redisValue = hashOps.get(key);</span><br><span class="line">                    <span class="comment">//进行序列化</span></span><br><span class="line">                    SeckillSkuRedisTo redisTo = JSON.parseObject(redisValue, SeckillSkuRedisTo.class);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//随机码</span></span><br><span class="line">                    Long currentTime = System.currentTimeMillis();</span><br><span class="line">                    Long startTime = redisTo.getStartTime();</span><br><span class="line">                    Long endTime = redisTo.getEndTime();</span><br><span class="line">                    <span class="comment">//如果当前时间大于等于秒杀活动开始时间并且要小于活动结束时间</span></span><br><span class="line">                    <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line">                        <span class="keyword">return</span> redisTo;</span><br><span class="line">                    &#125;</span><br><span class="line">                    redisTo.setRandomCode(<span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">return</span> redisTo;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前商品进行秒杀（秒杀开始）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> killId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">kill</span><span class="params">(String killId, String key, Integer num)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取当前用户的信息</span></span><br><span class="line">        MemberResponseVo user = LoginUserInterceptor.loginUser.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取当前秒杀商品的详细信息从Redis中获取</span></span><br><span class="line">        BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">        String skuInfoValue = hashOps.get(killId);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(skuInfoValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(合法性效验)</span></span><br><span class="line">        SeckillSkuRedisTo redisTo = JSON.parseObject(skuInfoValue, SeckillSkuRedisTo.class);</span><br><span class="line">        Long startTime = redisTo.getStartTime();</span><br><span class="line">        Long endTime = redisTo.getEndTime();</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//判断当前这个秒杀请求是否在活动时间区间内(效验时间的合法性)</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、效验随机码和商品id</span></span><br><span class="line">            String randomCode = redisTo.getRandomCode();</span><br><span class="line">            String skuId = redisTo.getPromotionSessionId() + <span class="string">&quot;-&quot;</span> +redisTo.getSkuId();</span><br><span class="line">            <span class="keyword">if</span> (randomCode.equals(key) &amp;&amp; killId.equals(skuId)) &#123;</span><br><span class="line">                <span class="comment">//3、验证购物数量是否合理和库存量是否充足</span></span><br><span class="line">                Integer seckillLimit = redisTo.getSeckillLimit();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取信号量</span></span><br><span class="line">                String seckillCount = redisTemplate.opsForValue().get(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">                Integer count = Integer.valueOf(seckillCount);</span><br><span class="line">                <span class="comment">//判断信号量是否大于0,并且买的数量不能超过库存</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; num &lt;= seckillLimit &amp;&amp; count &gt; num ) &#123;</span><br><span class="line">                    <span class="comment">//4、验证这个人是否已经买过了（幂等性处理）,如果秒杀成功，就去占位。userId-sessionId-skuId</span></span><br><span class="line">                    <span class="comment">//SETNX 原子性处理</span></span><br><span class="line">                    String redisKey = user.getId() + <span class="string">&quot;-&quot;</span> + skuId;</span><br><span class="line">                    <span class="comment">//设置自动过期(活动结束时间-当前时间)</span></span><br><span class="line">                    Long ttl = endTime - currentTime;</span><br><span class="line">                    Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(redisKey, num.toString(), ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (aBoolean) &#123;</span><br><span class="line">                        <span class="comment">//占位成功说明从来没有买过,分布式锁(获取信号量-1)</span></span><br><span class="line">                        RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">                        <span class="comment">//TODO 秒杀成功，快速下单</span></span><br><span class="line">                        <span class="keyword">boolean</span> semaphoreCount = semaphore.tryAcquire(num, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="comment">//保证Redis中还有商品库存</span></span><br><span class="line">                        <span class="keyword">if</span> (semaphoreCount) &#123;</span><br><span class="line">                            <span class="comment">//创建订单号和订单信息发送给MQ</span></span><br><span class="line">                            <span class="comment">// 秒杀成功 快速下单 发送消息到 MQ 整个操作时间在 10ms 左右</span></span><br><span class="line">                            String timeId = IdWorker.getTimeId();</span><br><span class="line">                            SeckillOrderTo orderTo = <span class="keyword">new</span> SeckillOrderTo();</span><br><span class="line">                            orderTo.setOrderSn(timeId);</span><br><span class="line">                            orderTo.setMemberId(user.getId());</span><br><span class="line">                            orderTo.setNum(num);</span><br><span class="line">                            orderTo.setPromotionSessionId(redisTo.getPromotionSessionId());</span><br><span class="line">                            orderTo.setSkuId(redisTo.getSkuId());</span><br><span class="line">                            orderTo.setSeckillPrice(redisTo.getSeckillPrice());</span><br><span class="line">                            rabbitTemplate.convertAndSend(<span class="string">&quot;order-event-exchange&quot;</span>,<span class="string">&quot;order.seckill.order&quot;</span>,orderTo);</span><br><span class="line">                            <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">                            log.info(<span class="string">&quot;耗时...&quot;</span> + (s2 - s1));</span><br><span class="line">                            <span class="keyword">return</span> timeId;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> s3 = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗时...&quot;</span> + (s3 - s1));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ Service kill</span><br><span class="line">    + 登录判断 √</span><br><span class="line">    + 合法性校验</span><br><span class="line">        + 获取当前秒杀商品的详细信息</span><br><span class="line">        + redis根据killid 获取sku信息</span><br><span class="line">        + json转为To数据</span><br><span class="line">        + 判断当前时间是否为秒杀时间</span><br><span class="line">        + 比较开始结束时间</span><br><span class="line">        + 判断随机码是否正确</span><br><span class="line">        + 判断购物数量是否合适</span><br><span class="line">    + 判断是否重复秒杀（幂等性）</span><br><span class="line">    + 到redis站位，setnx</span><br><span class="line">            + 指定key：userid_sessionid_skuid</span><br><span class="line">            + 拦截器获取user信息</span><br><span class="line">            + 设置自动过期时间（当前场次结束时间）</span><br><span class="line">            + 结束时间减去当前时间作为ttl</span><br><span class="line">            + 站位成功则说明未秒杀</span><br><span class="line">    + 获取分布式信号量</span><br><span class="line">    + 根据购买件数扣减信号量</span><br><span class="line">    + 调用tryAcquire（尝试性获取，非阻塞）</span><br><span class="line">    //+ 100毫秒尝试时间</span><br><span class="line">    + 无需等待</span><br><span class="line">    + 拿到信号量则成功秒杀</span><br><span class="line">    + 快速下单</span><br><span class="line">        + 创建订单号</span><br><span class="line">        + 发送消息给mq</span><br><span class="line">            + 引入rabbitmq</span><br><span class="line">            + 序列化、可靠消息等配置</span><br><span class="line">+ 秒杀订单To</span><br><span class="line">+ 发送消息</span><br><span class="line">    + 直接返回订单号</span><br><span class="line">    + 订单服务</span><br><span class="line">+ 队列、binding</span><br><span class="line">+ 监听秒杀队列</span><br><span class="line">+ 创建秒杀单，保存订单信息</span><br><span class="line">            + 保存订单项信息（订单关联sku表）</span><br><span class="line">            + TODO 其他</span><br></pre></td></tr></table></figure><h1 id="2、Sentinel、Sleuth-Zipkin"><a href="#2、Sentinel、Sleuth-Zipkin" class="headerlink" title="2、Sentinel、Sleuth + Zipkin"></a>2、Sentinel、Sleuth + Zipkin</h1><h2 id="Sentinel：流控、熔断降级、系统负载保护"><a href="#Sentinel：流控、熔断降级、系统负载保护" class="headerlink" title="Sentinel：流控、熔断降级、系统负载保护"></a>Sentinel：流控、熔断降级、系统负载保护</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304230038114.png" alt="image-20220304230038114"><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304230504257.png" alt="image-20220304230504257"></p><p>熔断：</p><p>  A 服务调用 B 服务的某个功能，由于网络不稳定问题，或者 B 服务卡机，导致功能时 间超长。如果这样子的次数太多。我们就可以直接将 B 断路了（A 不再请求 B 接口），凡是 调用 B 的直接返回降级数据，不必等待 B 的超长执行。 这样 B 的故障问题，就不会级联影响到 A。 熔断是被调方多次故障，触发系统的主动保护规则。</p><p>降级：</p><p>  整个网站处于流量高峰期，服务器压力剧增，根据当前业务情况及流量，对一些服务和 页面进行有策略的降级[停止服务，所有的调用直接返回降级数据]。以此缓解服务器资源的 的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到正确的相应。</p><p>流量控制几个角度：</p><p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系； </p><p>运行指标，例如 QPS、线程池、系统负载等； </p><p>控制的效果，例如直接限流、冷启动、排队等。</p><p>Sentinel相比Hystrix：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ Sentinel相比Hystrix：</span><br><span class="line">+ 隔离策略</span><br><span class="line">        + 线程池隔离</span><br><span class="line">            + 为请求分配自带线程池</span><br><span class="line">            + 优点</span><br><span class="line">                + 线程池之间隔离，池子炸了与其他请求无关</span><br><span class="line">        + 信号量隔离</span><br><span class="line">            + 为请求分配信号量</span><br></pre></td></tr></table></figure><p>sentinel-定义资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 定义resource</span><br><span class="line">    + 主流框架默认适配</span><br><span class="line">    + 抛出异常方式定义资源</span><br><span class="line">    + 返回布尔值方式定义资源</span><br><span class="line">    + 注解方式定义资源（可配置回调）</span><br><span class="line">    + 异步调用支持</span><br><span class="line">+ 自定义定义资源</span><br><span class="line">+ try-catch</span><br><span class="line">+ 基于注解 </span><br><span class="line">+ 调用链路</span><br><span class="line">        + 自定义blockhandler：限流、降级、系统保护时调用</span><br><span class="line">        + fallback：处理异常</span><br></pre></td></tr></table></figure><p>sentinel-限流模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 限流模式</span><br><span class="line">    + 链路限流模式</span><br><span class="line">        + 只统计某个入口进入的流量</span><br><span class="line">    + 关联模式</span><br><span class="line">        + 其他人流量大限制自己</span><br><span class="line">    + 直接拒绝</span><br><span class="line">    + warm up</span><br><span class="line">        + 预热：指定时间内将流量慢慢增加到限流阈值</span><br><span class="line">    + 排队等待</span><br></pre></td></tr></table></figure><p>Sentinel-熔断降级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 熔断降级</span><br><span class="line">+ 限流是对请求进行流控</span><br><span class="line">    + 远程调用需要用熔断降级进行保护</span><br><span class="line">    + 调用方熔断保护</span><br><span class="line">        + 开启feign-sentinel</span><br><span class="line">        + 对调用方接口加入fallback</span><br><span class="line">        + 实现feign接口</span><br><span class="line">            + 实现fallback方法</span><br><span class="line">    + 指定降级策略</span><br><span class="line">    + 远程服务（服务提供方）降级保护</span><br><span class="line">        + 流量过大时全局考虑，将某些服务提供方降级处理</span><br></pre></td></tr></table></figure><p>Sentinel-网关流控</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231223789.png" alt="image-20220304231223789"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 网关限流功能</span><br><span class="line">+ 引入sentinel与gateway适配整合</span><br><span class="line">+ 网关页面</span><br><span class="line">        + 流控</span><br><span class="line">        + api分组（对整个组进行流控设置）</span><br><span class="line">    + 定制网关流控返回</span><br><span class="line">    + Mono Webflux</span><br><span class="line">        + 响应式编程</span><br><span class="line">        + 天然支持高并发系统</span><br></pre></td></tr></table></figure><h2 id="Sleuth-Zipkin：链路追踪"><a href="#Sleuth-Zipkin：链路追踪" class="headerlink" title="Sleuth + Zipkin：链路追踪"></a>Sleuth + Zipkin：链路追踪</h2><p><strong>为什么用</strong></p><p>  微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务 单元。由于服务单元数量众多，业务的复杂性，如果<strong>出现了错误和异常，很难去定位</strong>。主要 体现在，<strong>一个请求可能需要调用很多个服务</strong>，而内部服务的调用复杂性，决定了问题难以 定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与， 参与的顺序又是怎样的，从而<strong>达到每个请求的步骤清晰可见，出了问题，很快定位</strong>。 </p><p>链路追踪组件有 Google 的 Dapper，Twitter 的 Zipkin，以及阿里的 Eagleeye （鹰眼）等，它们都是非常优秀的链路追踪开源组件。 </p><p><strong>基本术语</strong></p><p>Span（跨度）：基本工作单元，发送一个远程调度任务 就会产生一个 Span，Span 是一 个 64 位 ID 唯一标识的，Trace 是用另一个 64 位 ID 唯一标识的，Span 还有其他数据信息，比如摘要、时间戳事件、Span 的 ID、以及进度 ID。 </p><p>Trace（跟踪）：一系列 Span 组成的一个树状结构。请求一个微服务系统的 API 接口， 这个 API 接口，需要调用多个微服务，调用每个微服务都会产生一个新的 Span，所有 由这个请求产生的 Span 组成了这个 Trace。 </p><p>Annotation（标注）：用来及时记录一个事件的，一些核心注解用来定义一个请求的开 始和结束 。这些注解包括以下：  </p><ul><li><p>cs - Client Sent -客户端发送一个请求，这个注解描述了这个 Span 的开始  </p></li><li><p>sr - Server Received -服务端获得请求并准备开始处理它，如果将其 sr 减去 cs 时间戳 便可得到网络传输的时间。 </p></li><li><p>ss - Server Sent （服务端发送响应）–该注解表明请求处理的完成(当请求返回客户 端)，如果 ss 的时间戳减去 sr 时间戳，就可以得到服务器请求的时间。  </p></li><li><p>cr - Client Received （客户端接收响应）-此时 Span 的结束，如果 cr 的时间戳减去 cs 时间戳便可以得到整个请求所消耗的时间。 </p></li></ul><p>Sleuth原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231626939.png" alt="image-20220304231626939"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 每一个服务一个span</span><br><span class="line">    + trace id</span><br><span class="line">    + span id</span><br><span class="line">    + annotation标注</span><br><span class="line">    + 用来计算时间</span><br></pre></td></tr></table></figure><p>Sleuth + Zipkin</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231702938.png" alt="image-20220304231702938"></p><p>链路追踪</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231828856.png" alt="image-20220304231828856"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——支付宝支付&amp;RSA加密&amp;内网穿透</title>
      <link href="/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98&amp;RSA%E5%8A%A0%E5%AF%86&amp;%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98&amp;RSA%E5%8A%A0%E5%AF%86&amp;%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1、支付"><a href="#1、支付" class="headerlink" title="1、支付"></a>1、支付</h1><p>支付宝&amp;蚂蚁金服开发者平台：</p><p><a href="https://gitee.com/link?target=https://open.alipay.com/platform/home.htm">https://open.alipay.com/platform/home.htm</a></p><p>文档地址：</p><p>创建应用对应文档 <a href="https://gitee.com/link?target=https://openhome.alipay.com/docCenter/docCenter.htm">https://openhome.alipay.com/docCenter/docCenter.htm</a></p><p>网页移动应用文档 <a href="https://gitee.com/link?target=https://opendocs.alipay.com/open/200/105304">https://opendocs.alipay.com/open/200/105304</a></p><h2 id="支付宝支付流程"><a href="#支付宝支付流程" class="headerlink" title="支付宝支付流程"></a>支付宝支付流程</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230726942.png" alt="image-20220228230726942"></p><p>跳转的页面是根据AlipayTemplate定义的回调地址来进行跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">// 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息</span></span><br><span class="line">    <span class="keyword">private</span>  String notify_url = <span class="string">&quot;http://member.gulimall.com/memberOrder.html&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">//同步通知，支付成功，一般跳转到成功页</span></span><br><span class="line">    <span class="keyword">private</span>  String return_url = <span class="string">&quot;http://member.gulimall.com/memberOrder.html&quot;</span>;</span><br></pre></td></tr></table></figure><p>支付成功后异步回调接口处理，需要有服务器或配置了内网穿透才能接收到该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付宝异步通知回调接口,需要拥有内网穿透或服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/payed/notify&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleAlipayed</span><span class="params">(PayAsyncVo vo, HttpServletRequest request)</span> <span class="keyword">throws</span> UnsupportedEncodingException, AlipayApiException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重要一步验签名</span></span><br><span class="line"><span class="comment">         *  防止别人通过postman给我们发送一个请求，告诉我们请求成功，为了防止这种效果通过验签</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        Map&lt;String,String[]&gt; requestParams = request.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            String name = (String) iter.next();</span><br><span class="line">            String[] values = (String[]) requestParams.get(name);</span><br><span class="line">            String valueStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                valueStr = (i == values.length - <span class="number">1</span>) ? valueStr + values[i]</span><br><span class="line">                        : valueStr + values[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//乱码解决，这段代码在出现乱码时使用</span></span><br><span class="line">            valueStr = <span class="keyword">new</span> String(valueStr.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            params.put(name, valueStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 支付宝验签 防止恶意提交</span></span><br><span class="line">        <span class="keyword">boolean</span> signVerified = AlipaySignature.rsaCheckV1(params</span><br><span class="line">                , alipayTemplate.getAlipay_public_key()</span><br><span class="line">                , alipayTemplate.getCharset()</span><br><span class="line">                , alipayTemplate.getSign_type());</span><br><span class="line">        <span class="keyword">if</span> (signVerified) &#123;</span><br><span class="line">            String result = orderService.handleAlipayed(vo);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收单问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228233211250.png" alt="image-20220228233211250"></p><h2 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ 支付跳转</span><br><span class="line">    + controller</span><br><span class="line">        + 根据订单号查询封装订单Vo</span><br><span class="line">        + 调用支付方法</span><br><span class="line">+ 响应返回一个页面（支付宝收银台）</span><br><span class="line">+ 直接交给浏览器即可</span><br><span class="line">+ 跳转到会员订单列表页</span><br><span class="line">    + 支付成功跳转controller</span><br><span class="line">    + 会员服务feign远程调用订单服务</span><br><span class="line">            + 查询用户订单详情controller</span><br><span class="line">                + 根据id查询订单</span><br><span class="line">                + 遍历订单</span><br><span class="line">                    + 根据订单id查询订单项</span><br><span class="line">                    + 封装订单项详情</span><br><span class="line">    + 配置feign cookie同步拦截器（请求带上cookie）</span><br><span class="line">+ 异步通知（支付宝推荐）</span><br><span class="line">+ 不断通知，直到商户返回收到（最大努力通知型方案）</span><br><span class="line">+ 保证外网能够访问到</span><br><span class="line">            + 内网穿透</span><br><span class="line">            + server_name 加上外网的地址，保证可以进行server的跳转</span><br><span class="line">+ 异步通知获取参数接口</span><br><span class="line">+ 抽取异步参数的Vo</span><br><span class="line">+ 修改状态之前，需要验签（是否支付宝的数据）</span><br><span class="line">+ 验签代码，从demo中复制</span><br><span class="line">+ 支付成功处理（修改状态）</span><br><span class="line">+ 保存交易流水</span><br><span class="line">+ 数据库保证订单号、交易号等唯一</span><br><span class="line">+ 修改订单状态</span><br><span class="line">+ 查询订单，改为已支付</span><br><span class="line">+ 收单</span><br><span class="line">+ 问题</span><br><span class="line">        + 在支付页面过久，关单后才支付</span><br><span class="line">        + 库存关单后解锁，订单支付后变为已支付</span><br><span class="line">+ 支付宝自动收单功能（自动关闭收银台）</span><br><span class="line">    + 解锁库存完，支付完的异步通知才到</span><br><span class="line">    + 订单解锁，手动收单</span><br></pre></td></tr></table></figure><h1 id="2、RSA、加密加签、密钥"><a href="#2、RSA、加密加签、密钥" class="headerlink" title="2、RSA、加密加签、密钥"></a>2、RSA、加密加签、密钥</h1><p>对称加密：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230515319.png" alt="image-20220228230515319"></p><p>对称加密</p><ul><li>加密解密用同一把钥匙</li><li>一把钥匙不安全</li></ul><p>非对称加密 ：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230534327.png" alt="image-20220228230534327"></p><p>非对称加密</p><ul><li>加密解密使用不同钥匙</li></ul><p>公钥私钥：</p><p>公钥和私钥是一个相对概念，它们的公私性是相对于生成者来说的。 </p><p>一对密钥生成后，保存在生成者手里的就是私钥， 生成者发布出去大家用的就是公钥</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228231813227.png" alt="image-20220228231813227"></p><h1 id="3、内网穿透"><a href="#3、内网穿透" class="headerlink" title="3、内网穿透"></a>3、内网穿透</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228231656684.png" alt="image-20220228231656684"></p><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>内网穿透功能可以允许我们使用外网的网址来访问主机 正常的外网需要访问我们项目的流程是:</p><p>1、买服务器并且有公网固定IP</p><p>2、买域名映射到服务器的IP</p><p>3、域名需要进行备案和审核</p><h2 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h2><p>1、开发测试(微信、支付宝)</p><p>2、智慧互联</p><p>3、远程控制</p><p>4、私有云</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 优点</span><br><span class="line">+ 免服务器部署，直接在本地启动项目指定端口进行内网穿透即可</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——柔性事务-可靠消息+最终一致性解决方案（异步确保型）</title>
      <link href="/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF+%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF+%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="柔性事务-可靠消息-最终一致性解决方案（异步确保型）"><a href="#柔性事务-可靠消息-最终一致性解决方案（异步确保型）" class="headerlink" title="柔性事务-可靠消息+最终一致性解决方案（异步确保型）"></a>柔性事务-可靠消息+最终一致性解决方案（异步确保型）</h1><h2 id="RabbitMQ延时队列（实现定时任务）"><a href="#RabbitMQ延时队列（实现定时任务）" class="headerlink" title="RabbitMQ延时队列（实现定时任务）"></a>RabbitMQ延时队列（实现定时任务）</h2><p>场景： </p><p>比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 常用解决方案 </span><br><span class="line">+ spring的 schedule 定时任务轮询数据库 </span><br><span class="line">+ 缺点 </span><br><span class="line">+ 消耗系统内存、增加了数据库的压力、存在较大的时间误差 </span><br><span class="line">+ 解决</span><br><span class="line">+ rabbitmq的消息TTL和死信Exchange结合</span><br></pre></td></tr></table></figure><p>TTL存活时间</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102109187.png" alt="image-20220228102109187"></p><p>DLX死信交换机（Dead Letter Exchanges）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102131676.png" alt="image-20220228102131676"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102251153.png" alt="image-20220228102251153"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 模拟延迟场景</span><br><span class="line">    + 消息设置30m过期（队列不被监听）</span><br><span class="line">    + 30m后进入死信交换机</span><br><span class="line">    + 消息进入另一个队列（被监听）</span><br></pre></td></tr></table></figure><h3 id="延时队列实现"><a href="#延时队列实现" class="headerlink" title="延时队列实现"></a>延时队列实现</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102330181.png" alt="image-20220228102330181"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 给队列设置消息过期时间(推荐)</span><br><span class="line">+ 给消息设置消息过期时间</span><br><span class="line">+ rabbitmq懒检查</span><br><span class="line">    + 只会检查第一个消息是否过期</span><br><span class="line">    + 若后面消息ttl小，仍无法出队列</span><br><span class="line">    + 所以给队列设置过期时间</span><br></pre></td></tr></table></figure><h2 id="基于MQ可靠消息的一致性解决"><a href="#基于MQ可靠消息的一致性解决" class="headerlink" title="基于MQ可靠消息的一致性解决"></a>基于MQ可靠消息的一致性解决</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%81%E7%A8%8B.jpg" alt="消息队列流程"></p><p>监听库存解锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 解锁场景</span><br><span class="line">+ 未支付场景、手动取消订单</span><br><span class="line">+ 锁定成功，其他业务失败，订单回滚，自动解锁库存、</span><br><span class="line">+ 解锁之前，保存工作单（追溯）</span><br><span class="line">+ 库存锁成功时</span><br><span class="line">    + 保存工作单详情</span><br><span class="line">    + 给MQ发送消息到延时队列（消息包含工作单详情）</span><br></pre></td></tr></table></figure><p>库存解锁逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 监听解锁队列（延时过期队列）</span><br><span class="line">+ 根据消息查找库存工作单</span><br><span class="line">+ 没有：失败正常回滚</span><br><span class="line">    + 有：库存锁定成功，远程调用查询订单</span><br><span class="line">        + 没有订单：必须解锁</span><br><span class="line">        + 有订单，查看订单状态</span><br><span class="line">            + 已取消：解锁库存</span><br><span class="line">            + 没取消：不解锁</span><br><span class="line">    + ack</span><br><span class="line">+ 库存解锁，更新工作单状态</span><br></pre></td></tr></table></figure><p>定时关单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 监听器——关闭订单</span><br><span class="line">    + 执行成功则ack</span><br><span class="line">    + 不成功拒绝消息，重回队列</span><br><span class="line">+ 订单创建成功后，发送消息（订单）到MQ延时队列</span><br><span class="line">    + 消息过期到达监听器</span><br><span class="line">        + 查询订单的最新状态（可能已支付）</span><br><span class="line">        + 仍在代付款状态，则关单</span><br><span class="line">            + 更新订单状态为已取消</span><br></pre></td></tr></table></figure><p>问题：</p><p>1、订单消息卡顿，导致关单比库存解锁慢</p><p>2、库存解锁判断订单</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228103933963.png" alt="image-20220228103933963"></p><p>解决：关单后发送消息解锁库存（主动解锁库存补偿）</p><p>关单解锁库存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 查询库存工作单状态，防止重复解锁库存</span><br><span class="line">+ 按照工作单找到所有未解锁的库存（状态为1）进行解锁</span><br></pre></td></tr></table></figure><p>库存解锁总结：两种消息监听（库存解锁延迟消息、order主动关闭消息）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 主动补偿：关单解锁</span><br><span class="line">+ 被动补偿：自动解锁</span><br><span class="line">+ 若判断解锁过则放过消息</span><br><span class="line">+ 解决高并发</span><br><span class="line">+ 解决系统异构</span><br></pre></td></tr></table></figure><h2 id="消息丢失、积压、重复等解决方案"><a href="#消息丢失、积压、重复等解决方案" class="headerlink" title="消息丢失、积压、重复等解决方案"></a>消息丢失、积压、重复等解决方案</h2><h3 id="消息丢失：ack，防重表"><a href="#消息丢失：ack，防重表" class="headerlink" title="消息丢失：ack，防重表"></a>消息丢失：ack，防重表</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104351405.png" alt="image-20220228104351405"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104549154.png" alt="image-20220228104549154"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 消息丢失</span><br><span class="line">+ 网络问题，发送失败</span><br><span class="line">+ 加上try-catch</span><br><span class="line">    + 日志记录</span><br><span class="line">            + 数据库保存发送的消息详细信息，记录消息状态</span><br><span class="line">            + 定期扫描数据库，发送失败消息</span><br><span class="line">    + 消息抵达broker，尚未持久化完成（未抵达队列），宕机</span><br><span class="line">    + 发送端加入消息确认回调机制（e-&gt;q）</span><br><span class="line">    + 自动ack，消费者没来得及消费，宕机</span><br><span class="line">    + 开启手动ack模式，消费成功才移除消息</span><br><span class="line">    + 总结</span><br><span class="line">    + 做好消息确认机制（ pulisher，consumer 手动ack）</span><br><span class="line">+ 每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `mq_message` (</span><br><span class="line">`message_id` <span class="type">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`content` text,</span><br><span class="line">`to_exchane` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`routing_key` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`class_type` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`message_status` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0-新建 1-已发送 2-错误抵达 3-已抵达&#x27;</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`message_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br></pre></td></tr></table></figure><h3 id="消息重复：幂等性"><a href="#消息重复：幂等性" class="headerlink" title="消息重复：幂等性"></a>消息重复：幂等性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 消息重复</span><br><span class="line">    + 消息消费成功，ack前宕机，再次被消费</span><br><span class="line">    + 消费失败，重试机制</span><br><span class="line">    + ack宕机，unack变为ready，broker重新发送消息，同1</span><br><span class="line">    + 解决</span><br><span class="line">        + 业务逻辑解锁库存方法设为幂等性：判断库存工单状态，已解锁则无需解锁</span><br><span class="line">        + 保证幂等：使用防重表，处理后保存唯一标识id，免再次处理</span><br><span class="line">        + 消息的redelivered属性，判断是否为重新投递</span><br><span class="line">            + 无法判断上次是否处理成功</span><br></pre></td></tr></table></figure><h3 id="消息积压："><a href="#消息积压：" class="headerlink" title="消息积压："></a>消息积压：</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104743095.png" alt="image-20220228104743095"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 消息积压</span><br><span class="line">    + 消费者宕机</span><br><span class="line">    + 消费能力不足</span><br><span class="line">    + 发送流量太大</span><br><span class="line">        + 限制业务流量</span><br><span class="line">        + 上线更多消费者</span><br><span class="line">        + 批量取出消息保存到数据库中，离线业务慢慢处理</span><br></pre></td></tr></table></figure><p>1、分离消息微服务，考虑消息可靠性</p><p>2、调用微服务去发送消息</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——幂等性&amp;分布式事务&amp;Raft原理</title>
      <link href="/2022/02/27/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%B9%82%E7%AD%89%E6%80%A7&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1&amp;%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF&amp;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/02/27/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%B9%82%E7%AD%89%E6%80%A7&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1&amp;%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF&amp;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1、订单链路"><a href="#1、订单链路" class="headerlink" title="1、订单链路"></a>1、订单链路</h1><h2 id="订单中心"><a href="#订单中心" class="headerlink" title="订单中心"></a>订单中心</h2><p>电商系统涉及到 3 流，分别时信息流，资金流，物流，而订单系统作为中枢将三者有机的集合起来。 </p><p>订单模块是电商系统的枢纽，在订单这个环节上需求获取多个模块的数据和信息，同时对这些信息进行加工处理后流向下个环节，这一系列就构成了订单的信息流通。 </p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228080432263.png" alt="image-20220228080432263"></p><h2 id="订单流程"><a href="#订单流程" class="headerlink" title="订单流程"></a>订单流程</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228081824936.png" alt="image-20220228081824936"></p><h2 id="Feign远程异步调用丢失请求头、上下文问题"><a href="#Feign远程异步调用丢失请求头、上下文问题" class="headerlink" title="Feign远程异步调用丢失请求头、上下文问题"></a>Feign远程异步调用丢失请求头、上下文问题</h2><p>Feign远程调用丢失请求头问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228091104146.png" alt="image-20220228091104146"></p><p>feign异步情况丢失上下文问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228091118962.png" alt="image-20220228091118962"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ Feign远程调用丢失请求头问题</span><br><span class="line">    + 原因</span><br><span class="line">    + fegin调用没带session</span><br><span class="line">        + 创建一个新request，没有请求头</span><br><span class="line">    + 解决（同步老请求cookie）</span><br><span class="line">        + 加个feign请求调用的拦截器</span><br><span class="line">        + ThreadLocal获取老请求请求属性——cookie</span><br><span class="line">        + 设置新请求cookie</span><br><span class="line">+ feign异步情况丢失上下文问题</span><br><span class="line">+ 原因</span><br><span class="line">+ requecontexHolder底层是同一线程共享数据</span><br><span class="line">+ 通过ThreadLocal获取老请求，异步编排非同一线程</span><br><span class="line">+ 解决</span><br><span class="line">+ 执行异步前，提前共享请求数据</span><br></pre></td></tr></table></figure><p>也可以传传用户id，传用户会话，后者安全些，</p><p>1、id传参</p><p>2、传递cookie</p><h1 id="2、接口幂等性"><a href="#2、接口幂等性" class="headerlink" title="2、接口幂等性"></a>2、接口幂等性</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%E9%A1%B5%E6%B5%81%E7%A8%8B.png" alt="订单确认页流程"></p><p>保证幂等情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 用户多次点击按钮</span><br><span class="line">+ 用户页面回退再次提交</span><br><span class="line">+ 微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制</span><br><span class="line">+ 其他业务情况</span><br></pre></td></tr></table></figure><p>幂等解决方案：</p><h2 id="1、token机制"><a href="#1、token机制" class="headerlink" title="1、token机制"></a>1、token机制</h2><p>1、服务端提供了发送 token 的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取 token，服务器会把 token 保存到 redis 中。<br>2、然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。<br>3、服务器判断 token 是否存在 redis 中，存在表示第一次请求，然后删除 token,继续执行业务。<br>4、如果判断 token 不存在 redis 中，就表示是重复操作，直接返回重复标记给 client，这样就保证了业务代码，不被重复执行。</p><p>危险性(非原子操作)：<br>1、先删除 token 还是后删除 token；<br>    (1) 先删除可能导致，业务确实没有执行，重试还带上之前 token，由于防重设计导致， 请求还是不能执行。<br>    (2) 后删除可能导致，业务处理成功，但是服务闪断，出现超时，没有删除 token，别 人继续重试，导致业务被执行两边<br>    (3) 我们最好设计为先删除 token，如果业务调用失败，就重新获取 token 再次请求。<br>2、Token 获取、比较和删除必须是原子性<br>    (1) redis.get(token) 、token.equals、redis.del(token)如果这两个操作不是原子，可能导 致，高并发下，都 get 到同样的数据，判断都成功，继续业务并发执行<br>    (2) 可以在 redis 使用 lua 脚本完成这个操作 if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">必须原子性：lua脚本</span><br><span class="line">1、获取令牌</span><br><span class="line">2、对比token</span><br><span class="line">3、删除令牌</span><br></pre></td></tr></table></figure><h2 id="2、各种锁机制"><a href="#2、各种锁机制" class="headerlink" title="2、各种锁机制"></a>2、各种锁机制</h2><p>数据库悲观锁</p><p>select * from xxxx where id = 1 for update; 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。 另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。</p><p>数据库乐观锁</p><p>这种方法适合在更新的场景中， update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1 根据 version 版本，也就是在操作库存前先获取当前商品的 version 版本号，然后操作的时候 带上此 version 号。我们梳理下，我们第一次操作库存时，得到 version 为 1，调用库存服务 version 变成了 2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订 单服务传如的 version 还是 1，再执行上面的 sql 语句时，就不会执行；因为 version 已经变 为 2 了，where 条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。乐观锁主要使用于处理读多写少的问题</p><p>业务层分布式锁</p><p>如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数 据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</p><h2 id="3、各种唯一约束"><a href="#3、各种唯一约束" class="headerlink" title="3、各种唯一约束"></a>3、各种唯一约束</h2><p>数据库唯一约束</p><p>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。 这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键 的要求不是自增的主键，这样就需要业务生成全局唯一的主键。 如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p><p>redis set防重</p><p>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的 set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理。</p><h2 id="4、防重表"><a href="#4、防重表" class="headerlink" title="4、防重表"></a>4、防重表</h2><p>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且 他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。 </p><p>redis 防重也算</p><h2 id="5、全局请求唯一id"><a href="#5、全局请求唯一id" class="headerlink" title="5、全局请求唯一id"></a>5、全局请求唯一id</h2><p>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。 </p><p>可以使用 nginx 设置每一个请求的唯一 id；</p><p>proxy_set_header X-Request-Id $request_id;</p><p>总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ token令牌</span><br><span class="line">+ 原子性获取、对比、删除token</span><br><span class="line">+ 锁</span><br><span class="line">+ 数据库乐观锁、悲观锁</span><br><span class="line">+ 分布式锁</span><br><span class="line">+ 唯一约束</span><br><span class="line">+ 数据库主键唯一约束</span><br><span class="line">+ MD5加密redis set</span><br><span class="line">+ 防重表</span><br><span class="line">+ 操作之后以唯一索引放入去重表中，且与业务表同一数据库保证同一事务</span><br><span class="line">+ 全局请求唯一id</span><br><span class="line">+ 调用接口生成唯一id，放到redis中去重</span><br><span class="line">+ 链路追踪</span><br></pre></td></tr></table></figure><h1 id="3、分布式事务"><a href="#3、分布式事务" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h1><h2 id="1、本地事务"><a href="#1、本地事务" class="headerlink" title="1、本地事务"></a>1、本地事务</h2><h3 id="事务的基本性质"><a href="#事务的基本性质" class="headerlink" title="事务的基本性质"></a>事务的基本性质</h3><p>数据库事务的几个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称就是 ACID。</p><ul><li><p>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败；</p></li><li><p>一致性：数据在事务的前后，业务整体一致；</p></li><li><p>隔离性：事务之间互相隔离；</p></li><li><p>持久性：一旦事务成功，数据一定会落盘在数据库。</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li><p>READ UNCOMMITTED（读未提交）：该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。</p></li><li><p>READ COMMITTED（读提交）：一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。</p></li><li><p>REPEATABLE READ（可重复读）：该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL的 InnoDB 引擎可以通过 next-key locks 机制（参考下文”行锁的算法”一节）来避免幻读。</p></li><li><p>SERIALIZABLE（序列化）：在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p></li></ul><h3 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别"></a>事务的传播级别</h3><ol><li><p>PROPAGATION_REQUIRED： ：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p></li><li><p>PROPAGATION_SUPPORTS： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p></li><li><p>PROPAGATION_MANDATORY： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p></li><li><p>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p></li><li><p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p>PROPAGATION_NEVER： 以非事务方式执行，如果当前存在事务，则抛出异常。</p></li><li><p>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</p></li></ol><p>问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 远程调用超时——假异常</span><br><span class="line">    + 抛出异常导致全部回滚</span><br><span class="line">+ 扣减积分异常</span><br><span class="line">    + 扣减积分可以回滚</span><br><span class="line">    + 本地的订单可以回滚</span><br><span class="line">    + 远程锁库存无法回滚</span><br><span class="line">        + 事务无法控制远程服务</span><br><span class="line">        + 还需手动释放库存</span><br></pre></td></tr></table></figure><h2 id="2、SpringBoot事务"><a href="#2、SpringBoot事务" class="headerlink" title="2、SpringBoot事务"></a>2、SpringBoot事务</h2><p>@Transactional</p><p>内部事务互调问题：</p><p>在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。</p><p>原因：同一对象内事务互调默认失效，绕过了代理对象。</p><p>解决：</p><ol><li><p>导入 spring-boot-starter-aop</p></li><li><p>@EnableTransactionManagement(proxyTargetClass = true)</p></li><li><p>@EnableAspectJAutoProxy(exposeProxy=true)</p></li><li><p>AopContext.currentProxy() 调用方法</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 本地事务互调解决</span><br><span class="line">    + 使用代理对象调用事务方法</span><br><span class="line">        + 引入aop的aspectj</span><br><span class="line">        + 开启aspectj动态代理功能</span><br><span class="line">        + spring中bean可以代替 aspectj</span><br></pre></td></tr></table></figure><h2 id="3、分布式事务-1"><a href="#3、分布式事务-1" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228092926460.png" alt="image-20220228092926460"></p><p>1、远程服务假失败</p><p>2、远程事务回滚</p><h3 id="分布式CAP定理"><a href="#分布式CAP定理" class="headerlink" title="分布式CAP定理"></a>分布式CAP定理</h3><p>分布式系统经常出现的异常机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失…</p><p>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094112202.png" alt="image-20220228094112202"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ CAP定理</span><br><span class="line">+ 一致、可用二选一，分区容错性无法避免</span><br></pre></td></tr></table></figure><h3 id="Raft原理"><a href="#Raft原理" class="headerlink" title="Raft原理"></a>Raft原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094509282.png" alt="image-20220228094509282"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ 分布式系统实现一致性的Raft算法、paxos等</span><br><span class="line">    + leader选举</span><br><span class="line">        + 随从自旋时间（随机），等待命令</span><br><span class="line">        + 自旋结束的随从变成候选人，开启一轮新的选举</span><br><span class="line">        + 随从若当前未投票可发送投票</span><br><span class="line">        + 随从投过票后重新自旋</span><br><span class="line">        + leader发送追加日志信息给随从</span><br><span class="line">            + 消息发送以间隔（心跳时间）发送</span><br><span class="line">            + 随从收到消息后重置自旋时间</span><br><span class="line">        + leader宕机</span><br><span class="line">            + 随从自旋时间结束，变为候选者</span><br><span class="line">            + 开启选举，成为leader</span><br><span class="line">        + 如果出现两个候选者，出现投票分离</span><br><span class="line">            + 谁的投票请求先到投谁，其他的拒收</span><br><span class="line">            + 票数一样</span><br><span class="line">            + 重写来一轮自旋，候选者选举</span><br><span class="line">            + 直到候选者票数最多选出leader</span><br><span class="line">    + 日志复制</span><br><span class="line">    + leader将所有改变复制给其他node</span><br><span class="line">            + 使用追加日志方式复制（在每一个心跳时发送）</span><br><span class="line">            + 随从收到同步后回复消息</span><br><span class="line">            + leader收到大多数回复后提交，并响应客户端</span><br><span class="line">            + 在下一个心跳时间，请求其他node提交</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094701842.png" alt="image-20220228094701842"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094710919.png" alt="image-20220228094710919"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 出现分区错误</span><br><span class="line">    + 分区之后</span><br><span class="line">        + 接收不到消息，选举领导</span><br><span class="line">        + 大多数同意才能进行改变</span><br><span class="line">    + 恢复网络分区</span><br><span class="line">        + 低轮次leader退位</span><br><span class="line">        + 处于低轮次的node未提交日志全部回滚</span><br><span class="line">        + 匹配新leader日志</span><br><span class="line">        + 全部node一致</span><br></pre></td></tr></table></figure><p>Raft算法官网：<a href="https://raft.github.io/">https://raft.github.io/</a></p><h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>是对 CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可以采用适当的采取弱一致性，即<strong>最终一致性</strong>。 </p><p>BASE 是指</p><ul><li><p>基本可用（Basically Available）</p></li><li><ul><li>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。</li></ul></li><li><ul><li><ul><li>响应时间上的损失：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。</li><li>功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li></ul></li><li><p>软状态（ Soft State）</p></li><li><ul><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。</li></ul></li><li><p>最终一致性（ Eventual Consistency）</p></li><li><ul><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ base</span><br><span class="line">    + 基本可用</span><br><span class="line">        + 允许损失部分可用性</span><br><span class="line">    + 软状态</span><br><span class="line">        + 允许系统存在中间状态</span><br><span class="line">    + 最终一致性</span><br><span class="line">        + 经历一定时间后，最终能达到一致性状态</span><br></pre></td></tr></table></figure><h3 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h3><p>​    从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是 <strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是 <strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是 <strong>最终一致性。</strong></p><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><h4 id="2PC模式"><a href="#2PC模式" class="headerlink" title="2PC模式"></a>2PC模式</h4><p>数据库支持的 2PC【2 phase commit 二阶提交】，又叫做 XA Transactions。</p><p>MySQL 从 5.5 版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：</p><p>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</p><p>第二阶段：事务协调器要求每个数据库提交数据。</p><p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228100342688.png" alt="image-20220228100342688"></p><ul><li><p>XA 协议比较简单，而且一旦商业数据库实现了 XA 协议，使用分布式事务的成本也比较低。</p></li><li><p>XA  性能不理想，特别是在交易下单链路，往往并发量很高，XA 无法满足高并发场景</p></li><li><p>XA 目前在商业数据库支持的比较理想，在 在 mysql  数据库中支持的不太理想，mysql 的XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</p></li><li><p>许多 nosql 也没有支持 XA，这让 XA 的应用场景变得非常狭隘。</p></li><li><p>也有 3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 2PC模式（XA）：二阶段提交</span><br><span class="line">    + 使用场景小</span><br><span class="line">    + 高并发性能差</span><br></pre></td></tr></table></figure><h4 id="柔性事务-TCC"><a href="#柔性事务-TCC" class="headerlink" title="柔性事务-TCC"></a>柔性事务-TCC</h4><p>刚性事务：遵循 ACID 原则，强一致性。</p><p>柔性事务：遵循 BASE 理论，最终一致性；</p><p>与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1629027928516-e4e2272b-2df1-48ec-ac90-dee09d1c96ab.png" alt="image.png"></p><p>一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。</p><p>二阶段 commit 行为：调用 自定义 的 commit 逻辑。</p><p>二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。</p><p>所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228100848491.png" alt="image-20220228100848491"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 柔性事务-TCC事务补偿型方案</span><br><span class="line">    + 一阶段prepare——try</span><br><span class="line">    + 二阶段commit——confirm</span><br><span class="line">    + 二阶段rollback——cancel</span><br></pre></td></tr></table></figure><h4 id="柔性事务-最大努力通知型方案（结合MQ）"><a href="#柔性事务-最大努力通知型方案（结合MQ）" class="headerlink" title="柔性事务-最大努力通知型方案（结合MQ）"></a>柔性事务-最大努力通知型方案（结合MQ）</h4><p>按规律进行通知， <strong>不保证数据一定能通知成功，但会提供可查询操作接口进行核对</strong>。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。</p><p>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调。</p><h4 id="柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="柔性事务-可靠消息 + 最终一致性方案（异步确保型）"></a>柔性事务-可靠消息 + 最终一致性方案（异步确保型）</h4><p>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><p>防止消息丢失：</p><ol><li>做好消息确认机制（ pulisher ， consumer 【手动 ack 】）</li><li>每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍.</li></ol><h3 id="Seata分布式事务"><a href="#Seata分布式事务" class="headerlink" title="Seata分布式事务"></a>Seata分布式事务</h3><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/145942191-7a2d469f-94c8-4cd2-8c7e-46ad75683636.png" alt="image"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 创建UNDO_LOG表（每一个数据库）（AT模式：自动模式）</span><br><span class="line">    + 回滚表</span><br><span class="line">    + 自动补偿</span><br><span class="line">+ 安装事务协调器：seata-server</span><br><span class="line">+ 使用seata DataSourceProxy代理自己的数据源</span><br><span class="line">+ 全局事务注解</span><br><span class="line">    + GlobalTransactional</span><br></pre></td></tr></table></figure><p>问题：AT模式吞吐量低，不支持高并发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ seata默认AT模式</span><br><span class="line">    + 不用做高并发场景</span><br><span class="line">    + 后台简单场景，不要求高并发</span><br><span class="line">    + 包含各种锁机制</span><br></pre></td></tr></table></figure><p>高并发场景：考虑基于消息服务的柔性事务方案</p><p>1、锁库存成功数据库保存锁库存工作单</p><p>2、引入延迟队列——完成库存自动解锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228101557537.png" alt="image-20220228101557537"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——session共享&amp;sso&amp;ThreadLocal</title>
      <link href="/2022/02/17/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-session%E5%85%B1%E4%BA%AB&amp;sso&amp;ThreadLocal/"/>
      <url>/2022/02/17/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-session%E5%85%B1%E4%BA%AB&amp;sso&amp;ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="1、MD5-amp-盐值-amp-BCrypt"><a href="#1、MD5-amp-盐值-amp-BCrypt" class="headerlink" title="1、MD5&amp;盐值&amp;BCrypt"></a>1、MD5&amp;盐值&amp;BCrypt</h1><p>MD5 （Message Digest algorithm 5，信息摘要算法） </p><p>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。 </p><p>2、容易计算：从原数据计算出MD5值很容易。 </p><p>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 </p><p>4、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 </p><p>5、不可逆 </p><p>加盐： </p><p>1、通过生成随机数与MD5生成字符串进行组合 </p><p>2、数据库同时存储MD5值与salt值。验证正确性时使用salt进行MD5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ Spring的加密</span><br><span class="line">+ 自动加盐</span><br><span class="line">+ match匹配（与encode匹配）</span><br></pre></td></tr></table></figure><h1 id="2、分布式session共享"><a href="#2、分布式session共享" class="headerlink" title="2、分布式session共享"></a>2、分布式session共享</h1><p>问题：</p><p>不同服务session不共享</p><p>同一服务session不同步</p><h2 id="session原理"><a href="#session原理" class="headerlink" title="session原理"></a>session原理</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218001900202.png" alt="image-20220218001900202"></p><h2 id="分布式session解决方案"><a href="#分布式session解决方案" class="headerlink" title="分布式session解决方案"></a>分布式session解决方案</h2><h3 id="1、session复制"><a href="#1、session复制" class="headerlink" title="1、session复制"></a>1、session复制</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002213539.png" alt="image-20220218002213539"></p><p>Session复制（tomcat之间同步）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + web-server（Tomcat）原生支持，只需要修改配置文件 </span><br><span class="line">+ 缺点：</span><br><span class="line">+ session同步需要数据传输，占用大量网络带宽，降低了服务器群的业务处理能力 </span><br><span class="line">    + 任意一台web-server保存的数据都是所有web-server的session总和，受到内存限制无法水平扩展更多的web-server </span><br><span class="line">    + 大型分布式集群情况下，由于所有web-server都全量保存数据，所以此方案不可取。</span><br></pre></td></tr></table></figure><h3 id="2、客户端存储"><a href="#2、客户端存储" class="headerlink" title="2、客户端存储"></a>2、客户端存储</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002226115.png" alt="image-20220218002226115"></p><p>放到cookie中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 优点</span><br><span class="line">+ 服务器不需存储session，用户保存自己的session信息到cookie中。</span><br><span class="line">+ 节省服务端资源</span><br><span class="line">+ 缺点</span><br><span class="line">    + 都是缺点，这只是一种思路。</span><br><span class="line">    + 每次http请求，携带用户在cookie中的完整信息，浪费网络带宽</span><br><span class="line">    + session数据放在cookie中，cookie有长度限制4K，不能保存大量信息</span><br><span class="line">    + session数据放在cookie中，存在泄漏、篡改、窃取等安全隐患</span><br></pre></td></tr></table></figure><h3 id="3、hash一致性"><a href="#3、hash一致性" class="headerlink" title="3、hash一致性"></a>3、hash一致性</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002507539.png" alt="image-20220218002507539"></p><p>Hash一致性（修改负载均衡）</p><p>+ 服务器闪断会丢失</p><p>+ 服务器数量变化重新hash，部分会丢失</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + 只需要改nginx配置，不需要修改应用代码 负载均衡，只要hash属性的值分布是均匀的，多台web-server的负载是均衡的 </span><br><span class="line">    + 可以支持web-server水平扩展（session同步法是不行的，受内存限制） </span><br><span class="line">缺点</span><br><span class="line">    + session还是存在web-server中的，所以web-server重 </span><br><span class="line">    启可能导致部分session丢失，影响业务，如部分用户 </span><br><span class="line">    需要重新登录 </span><br><span class="line">    + 如果web-server水平扩展，rehash后session重新分布， </span><br><span class="line">    也会有一部分用户路由不到正确的session </span><br><span class="line">+ 但是以上缺点问题也不是很大，因为session本来都是有有 </span><br></pre></td></tr></table></figure><h3 id="4、统一存储"><a href="#4、统一存储" class="headerlink" title="4、统一存储"></a>4、统一存储</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002612719.png" alt="image-20220218002612719"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + 没有安全隐患</span><br><span class="line">    + 可以水平扩展，数据库/缓存水平切分即可</span><br><span class="line">    + web-server重启或者扩容都不会有 session丢失</span><br><span class="line">+ 不足</span><br><span class="line">    + 增加了一次网络调用，并且需要修改应 用代码；如将所有的getSession方法替换为从Redis查数据的方式。redis获取数 据比内存慢很多</span><br><span class="line">    + 上面缺点可以用SpringSession完美解决</span><br></pre></td></tr></table></figure><h3 id="5、扩大cookie作用域"><a href="#5、扩大cookie作用域" class="headerlink" title="5、扩大cookie作用域"></a>5、扩大cookie作用域</h3><p>解决子域共享问题</p><p>问题：多域名</p><h2 id="SpringSession"><a href="#SpringSession" class="headerlink" title="SpringSession"></a>SpringSession</h2><p>配置类：json编码、cooki子域问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">//放大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">&quot;gulimall.com&quot;</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">&quot;GULISESSION&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理：装饰者模式"><a href="#原理：装饰者模式" class="headerlink" title="原理：装饰者模式"></a>原理：装饰者模式</h3><p>狸猫换太子</p><p>@EnableRedisHttpSession 导入 RedisHttpSessionConfiguration 配置</p><p>1、给容器中添加了一个组件 RedisOperationsSessionRepository：Redis操作session，session的增删改查封装类；</p><p>2、继承 SpringHttpSessionConfiguration 初始化了一个 SessionRepositoryFilter：session 存储过滤器；每个请求过来都必须经过 Filter 组件；创建的时候，自动从容器中获取到了 SessionRepository；</p><p> SessionRepositoryFilter：</p><ul><li>将原生的 HttpServletRequest Response 包装成 SessionRepositoryRequestWrapper ResponseWrapper；包装后的对象应用到了后面整个执行链；</li><li>以后获取 request.getSession(); 都会调用 wrappedRequesr.getSession(); 从SessionRepository获取；</li></ul><p>3、装饰者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    request.setAttribute(SESSION_REPOSITORY_ATTR, <span class="keyword">this</span>.sessionRepository);</span><br><span class="line">    SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper wrappedRequest = <span class="keyword">new</span> SessionRepositoryFilter.SessionRepositoryRequestWrapper(request, response);</span><br><span class="line">    SessionRepositoryFilter.SessionRepositoryResponseWrapper wrappedResponse = <span class="keyword">new</span> SessionRepositoryFilter.SessionRepositoryResponseWrapper(wrappedRequest, response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filterChain.doFilter(wrappedRequest, wrappedResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        wrappedRequest.commitSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、sso单点登录"><a href="#3、sso单点登录" class="headerlink" title="3、sso单点登录"></a>3、sso单点登录</h1><p>跨域名单点登录简单实现：</p><p>1、服务端：未登录跳转认证中心（附带参数保存原地址）</p><p>2、认证中心：登录成功本地保存cookie（sso_token）</p><p>3、认证中心：保存登录用户登录状态到redis中</p><p>4、认证中心：重定向url中附带token跳转回原页面</p><p>5、服务端：根据token查询redis获取用户信息保存session</p><p>6、其他服务端：未登录跳转到认证中心，直接登录成功返回</p><p>服务端：根据有无session判断是否登录</p><p>认证中心：根据有无sso_token判断是否登录</p><p>可实现：filter、jwt、springsecurity</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" alt="单点登录流程"></p><h1 id="4、ThreadLocal同一个线程共享数据"><a href="#4、ThreadLocal同一个线程共享数据" class="headerlink" title="4、ThreadLocal同一个线程共享数据"></a>4、ThreadLocal同一个线程共享数据</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218004911488.png" alt="image-20220218004911488"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; toThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">toThreadLocal.set(userInfoTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">UserInfoTo userInfoTo = CartInterceptor.toThreadLocal.get();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——缓存&amp;分布式锁&amp;检索&amp;异步&amp;线程池</title>
      <link href="/2022/02/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E7%BC%93%E5%AD%98&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;%E6%A3%80%E7%B4%A2&amp;%E5%BC%82%E6%AD%A5/"/>
      <url>/2022/02/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E7%BC%93%E5%AD%98&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;%E6%A3%80%E7%B4%A2&amp;%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1、缓存"><a href="#1、缓存" class="headerlink" title="1、缓存"></a>1、缓存</h1><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220216234206407.png" alt="image-20220216234206407"></h2><h2 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h2><p>1、缓存穿透：</p><p>不存在数据</p><p>缓存null、设置短的过期时间</p><p>2、缓存雪崩：</p><p>大面积同时失效</p><p>失效加随机值</p><p>3、缓存击穿</p><p>热点key失效</p><p>加锁</p><h2 id="缓存数据一致性解决"><a href="#缓存数据一致性解决" class="headerlink" title="缓存数据一致性解决"></a>缓存数据一致性解决</h2><p>双写模式：</p><p>+ 改完数据库同时改缓存</p><p>+ 脏数据</p><p>​    + 加锁</p><p>​    + 是否允许暂时不一致性——缓存过期后可读正确数据</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220216234700247.png" alt="image-20220216234700247"></p><p>失效模式</p><p>+ 删除缓存数据</p><p>+ 等待下次查询主动更新</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003139062.png" alt="image-20220217003139062"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003318428.png" alt="image-20220217003318428"></p><p>+ 并发量小不考虑</p><p>+ 菜单等，用canal</p><p>​    + 自动更新缓存（db从库）</p><p>​    + 数据异构（访问记录表 和 商品 进行分析计算——用户推荐）</p><p>+ 过期时间保证 最终一致性</p><p>+ 加读写锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003503499.png" alt="image-20220217003503499"></p><p>我们系统的一致性<strong>解决方案</strong>： </p><p>1、缓存的所有数据都有过期时间，数据过期下一次查询触发主动更新 </p><p>2、读写数据的时候，加上分布式的<strong>读写锁</strong>。 （经常写，经常读）</p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>使用大量aop切面编程，最终都是动态代理机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ @Cacheable：结果缓存</span><br><span class="line">+ key、value</span><br><span class="line">+ ttl</span><br><span class="line">+ 序列化：json</span><br><span class="line">+ @CacheEvict：删除缓存</span><br><span class="line">+ @CachePut：调用方法且缓存</span><br><span class="line">+ 双写模式</span><br><span class="line">+ @Caching：多个操作</span><br><span class="line">+ 开启缓存空值</span><br><span class="line">+ 防止缓存穿透</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 读模式</span><br><span class="line">+ 缓存穿透：缓存null</span><br><span class="line">+ 缓存击穿：加锁</span><br><span class="line">+ 缓存雪崩：过期时间加随机</span><br><span class="line">+ 写模式（缓存与数据库一致）</span><br><span class="line">+ 读写加锁</span><br><span class="line">+ canal感知数据库</span><br><span class="line">+ 读多写多，直接去数据库</span><br></pre></td></tr></table></figure><h1 id="2、分布式锁"><a href="#2、分布式锁" class="headerlink" title="2、分布式锁"></a>2、分布式锁</h1><h3 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h3><p>redis setnx</p><p>问题：异常退出死锁</p><h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><p>同时原子设置过期时间</p><p>问题：锁过期，删错锁</p><h3 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h3><p>唯一标识value验证</p><p>问题：获取value和删除key非原子，仍存在删错锁</p><h3 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h3><p>lua脚本，解锁保证原子性</p><p>问题：未执行完锁过期，续期问题</p><h3 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h3><p>锁时间放长，finally解锁</p><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217001540526.png" alt="image-20220217001540526"></p><p>使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，更进一步简化了分布式环境中程序相互之间的协作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+lock锁</span><br><span class="line">+自动续期</span><br><span class="line">+看门狗：判断线程 + 定时任务（重设过期时间）</span><br><span class="line">+ trylock（获取一次）</span><br><span class="line">+ fair lock公平锁（队列）</span><br><span class="line">+ readwritelock读写锁</span><br><span class="line">    + 写锁限制读和写操作（保证读数据一致性）</span><br><span class="line">    + 读锁单独无限制（无锁）</span><br><span class="line">    + 只要有写操作，就需要等待（读写，写读）</span><br><span class="line">+ 信号量（固定车位）</span><br><span class="line">+ 分布式限流</span><br><span class="line">+ acquire（阻塞）、Tryacquire</span><br><span class="line">+ 闭锁（走完关门）</span><br></pre></td></tr></table></figure><p>看门狗原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/816762-20210425105548419-1714180337.jpg" alt="img"></p><h1 id="3、检索"><a href="#3、检索" class="headerlink" title="3、检索"></a>3、检索</h1><p>vo封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询到的所有商品信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SkuEsModel&gt; product;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer totalPages;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; pageNavs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的品牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BrandVo&gt; brands;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的所有属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AttrVo&gt; attrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的所有分类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CatalogVo&gt; catalogs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================以上是返回给页面的所有信息============================//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 面包屑导航数据 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;NavVo&gt; navs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NavVo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String navName;</span><br><span class="line">        <span class="keyword">private</span> String navValue;</span><br><span class="line">        <span class="keyword">private</span> String link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long brandId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String brandName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String brandImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AttrVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long attrId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String attrName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; attrValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CatalogVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long catalogId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String catalogName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DSL</p><p>模糊匹配、过滤（属性、分类、品牌、价格区间、库存）</p><p>排序、分页、高亮、聚合分析</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">GET mall_product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [ &#123;<span class="attr">&quot;match&quot;</span>: &#123;  <span class="attr">&quot;skuTitle&quot;</span>: <span class="string">&quot;华为&quot;</span> &#125;&#125; ], # 检索出华为</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [ # 过滤</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;catalogId&quot;</span>: <span class="string">&quot;225&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;brandId&quot;</span>: [ <span class="string">&quot;2&quot;</span>] &#125; &#125;, </span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;hasStock&quot;</span>: <span class="string">&quot;false&quot;</span>&#125; &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;skuPrice&quot;</span>: &#123; # 价格1K~7K</span><br><span class="line">              <span class="attr">&quot;gte&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">              <span class="attr">&quot;lte&quot;</span>: <span class="number">7000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;nested&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;attrs&quot;</span>, # 聚合名字</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;attrs.attrId&quot;</span>: &#123; <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;6&quot;</span>&#125; &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [ &#123;<span class="attr">&quot;skuPrice&quot;</span>: &#123;<span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125; ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;  </span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;<span class="attr">&quot;skuTitle&quot;</span>: &#123;&#125;&#125;, # 高亮的字段</span><br><span class="line">    <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;b style=&#x27;color:red&#x27;&gt;&quot;</span>,  # 前缀</span><br><span class="line">    <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/b&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123; # 查完后聚合</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123; # 子聚合</span><br><span class="line">        <span class="attr">&quot;brandNameAgg&quot;</span>: &#123;  # 每个商品id的品牌</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandName&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      </span><br><span class="line">        <span class="attr">&quot;brandImgAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandImg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;catalogAgg&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;catalogId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;catalogNameAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;catalogName&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;attrs&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;nested&quot;</span>: &#123;<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;attrs&quot;</span> &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;attrIdAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;attrs.attrId&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;attrNameAgg&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;attrs.attrName&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、异步-amp-线程池"><a href="#4、异步-amp-线程池" class="headerlink" title="4、异步&amp;线程池"></a>4、异步&amp;线程池</h1><p>1）、继承 Thread </p><p>2）、实现 Runnable 接口 </p><p>3）、实现 Callable 接口 + FutureTask （可以拿到返回结果，可以处理异常） </p><p>4）、线程池：调度、资源控制</p><p>线程池七大参数：</p><p>核心线程数、最大线程数、超时时间、超时时间单位、阻塞队列，线程工厂、拒绝策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行流程： </span><br><span class="line">1、线程池创建，准备好 core 数量的核心线程，准备接受任务 </span><br><span class="line">2、新的任务进来，用 core 准备好的空闲线程执行。 </span><br><span class="line">  (1) 、core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队 列获取任务执行 </span><br><span class="line">  (2) 、阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量</span><br><span class="line">  (3) 、max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自 动销毁。最终保持到 core 大小 </span><br><span class="line">  (4) 、如果线程数开到了 max 的数量，还有新任务进来，就会使用 reject 指定的拒绝策 略进行处理 </span><br><span class="line">3、所有的线程创建都是由指定的 factory 创建的。</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h2><p>  很多语言，比如 Node.js，采用回调的方式实现异步编程。Java 的一些框架，比如 Netty，自 己扩展了 Java 的 <code>Future</code>接口，提供了<code>addListener</code>等多个扩展方法；Google guava 也提供了 通用的扩展 Future；Scala 也提供了简单易用且功能强大的 Future/Promise 异步编程模式。</p><p>  在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以 通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。 CompletableFuture 类实现了 Future 接口，所以你还是可以像以前一样通过<code>get</code>方法阻塞或 者轮询的方式获得结果，但是这种方式不推荐使用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ 启动异步任务</span><br><span class="line">+ runAsync</span><br><span class="line">+ supplyAsync</span><br><span class="line">+ 完成回调与异常感知</span><br><span class="line">+ whenComplete</span><br><span class="line">+ exceptionally</span><br><span class="line">+ whenCompleteAsync</span><br><span class="line">+ handle最终处理</span><br><span class="line">+ 和 complete 一样</span><br><span class="line">+ 可对结果做最后的处理（可处理异常），可改变返回值</span><br><span class="line">+ 线程串行化方法</span><br><span class="line">+ thenApply</span><br><span class="line">+ thenAccept</span><br><span class="line">+ thenRun</span><br><span class="line">+ 两任务组合</span><br><span class="line">    + 都要完成</span><br><span class="line">    + 一个完成</span><br><span class="line">+ 多任务组合</span><br><span class="line">+ allOf</span><br><span class="line">+ anyOf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——性能压测</title>
      <link href="/2022/02/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%8E%8B%E6%B5%8B/"/>
      <url>/2022/02/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%8E%8B%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1、jvm-内存模型"><a href="#1、jvm-内存模型" class="headerlink" title="1、jvm 内存模型"></a>1、jvm 内存模型</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214153035740.png" alt="image-20220214153035740"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 程序计数器 Program Counter Register： </span><br><span class="line"> + 记录的是正在执行的虚拟机字节码指令的地址， </span><br><span class="line"> + 此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OutOfMemoryError的区域 </span><br><span class="line">+ 虚拟机：VM Stack </span><br><span class="line"> + 描述的是 JAVA 方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法接口等信息</span><br><span class="line"> + 局部变量表存储了编译期可知的各种基本数据类型、对象引用  </span><br><span class="line"> + 线程请求的栈深度不够会报 StackOverflowError 异常  </span><br><span class="line"> + 栈动态扩展的容量不够会报 OutOfMemoryError 异常  </span><br><span class="line"> + 虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈  </span><br><span class="line">+ 本地方法：Native Stack  </span><br><span class="line"> + 本地方法栈类似于虚拟机栈，只不过本地方法栈使用的是本地方法  </span><br><span class="line">+ 堆：Heap </span><br><span class="line"> + 几乎所有的对象实例都在堆上分配内存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145444465.png" alt="image-20220214145444465"></p><h1 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h1><p>所有的对象实例以及数组都要在堆上分配。堆是垃圾收集器管理的主要区域，也被称为“GC堆”；也是我们优化最多考虑的地方。 堆可以细分为： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 新生代 </span><br><span class="line"> + Eden 空间 </span><br><span class="line"> + From Survivor 空间 </span><br><span class="line"> + To Survivor 空间 </span><br><span class="line">+ 老年代</span><br><span class="line">+ 永久代/元空间 </span><br><span class="line"> + Java8 以前永久代，受 jvm 管理，java8 以后元空间，直接使用物理内存。因此， 默认情况下，元空间的大小仅受本地内存限制。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145921888.png" alt="image-20220214145921888"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145742455.png" alt="image-20220214145742455"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145909109.png" alt="image-20220214145909109"></p><h1 id="3、JVM-分析-amp-调优"><a href="#3、JVM-分析-amp-调优" class="headerlink" title="3、JVM 分析&amp;调优"></a>3、JVM 分析&amp;调优</h1><p>Full gc 最会影响性能，根据代码问题，避免 full gc 频率。可以适当调大年轻代容量，让大对象可以在年轻代触发 yong gc，调整大对象在年轻代的回收频次，尽可能保证大对象在年轻代回收，减小老年代缩短回收时间。</p><h1 id="4、压测"><a href="#4、压测" class="headerlink" title="4、压测"></a>4、压测</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214152417181.png" alt="image-20220214152417181"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214152548781.png" alt="image-20220214152548781"></p><p>现阶段优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 中间件</span><br><span class="line"> + nginx 动静分离</span><br><span class="line"> + gateway</span><br><span class="line">+ db</span><br><span class="line"> + 索引</span><br><span class="line"> + 操作</span><br><span class="line">+ log</span><br><span class="line">+ redis</span><br><span class="line">+ page cache</span><br><span class="line">+ jvm内存</span><br><span class="line">+ 业务流程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷粒商城——分布式基础-全栈开发篇</title>
      <link href="/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1、写在前面"><a href="#1、写在前面" class="headerlink" title="1、写在前面"></a>1、写在前面</h1><p>仿京东商城大型分布式架构电商平台：微服务架构+分布式+全栈+集群+部署+自动化运维+可视化CICD</p><p>Gitee仓库：<a href="https://gitee.com/namdev/gulimall">https://gitee.com/namdev/gulimall</a></p><p>后台接口文档：<a href="https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd">https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd</a></p><p>b站视频地址：<a href="https://www.bilibili.com/video/BV1np4y1C7Yf">全网最强电商教程《谷粒商城》对标阿里P6/P7，40-60万年薪</a></p><h1 id="2、架构"><a href="#2、架构" class="headerlink" title="2、架构"></a>2、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201439633.png" alt="image-20220212201439633"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201228064.png" alt="image-20220212201228064"></p><h1 id="3、基础环境"><a href="#3、基础环境" class="headerlink" title="3、基础环境"></a>3、基础环境</h1><p>linux、docker</p><p>数据库</p><p>人人后台</p><p>分布式组件</p><h1 id="4、商品、订单、仓库服务后台"><a href="#4、商品、订单、仓库服务后台" class="headerlink" title="4、商品、订单、仓库服务后台"></a>4、商品、订单、仓库服务后台</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211040144.png" alt="image-20220212211040144"></p><h2 id="pms库"><a href="#pms库" class="headerlink" title="pms库"></a>pms库</h2><p>Attr：属性表</p><p>Attr_group：属性分组表</p><p>Attr_attrgroup_relation：属性分组关联表</p><p>Product_attr_value：商品id属性值表</p><p>Spu_info：商品spu</p><p>Sku_info：商品sku</p><p>Sku_images：商品sku图片</p><p>Sku_sale_attr_values：商品sku销售属性值</p><p>三级分类——属性分组——属性</p><p>属性——商品（spu）属性集——商品型号（sku）属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211136464.png" alt="image-20220212211136464"></p><h2 id="保存商品"><a href="#保存商品" class="headerlink" title="保存商品"></a>保存商品</h2><p>Spu_info：基本信息</p><p>Spu_info_desc：id + 描述图片</p><p>Spu_images：id + 图片集</p><p>Product_attr_value：spu规格参数 spuid + 属性值</p><p>Spu_bounds：商品积分 （sms库）</p><p>Sku_info：sku基本信息 + spuid</p><p>Sku_images：skuid + sku图片信息</p><p>Sku_sale_attr_value：sku销售属性 skuid + 属性值</p><p>Sku优惠满减信息（sms库）：skuid</p><p>Sku_ladder：打折表</p><p>Sku_full_reduction：满减表</p><p>Member_price：会员价格表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211157512.png" alt="image-20220212211157512"></p><h2 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h2><p>单表、多表、多库、远程调用、属性拷贝等暂时省略</p><h1 id="5、jsr303校验"><a href="#5、jsr303校验" class="headerlink" title="5、jsr303校验"></a>5、jsr303校验</h1><p>开启校验（错误返回） + bean校验注解</p><p>统一异常处理</p><p>枚举类</p><p>jsr303分组校验</p><p>jsr303自定义校验注解</p><h1 id="5、object"><a href="#5、object" class="headerlink" title="5、object"></a>5、object</h1><p>1.PO(persistant object) 持久对象 </p><p>PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 </p><p>2.DO（Domain Object）领域对象就是从现实世界中抽象出来的有形或无形的业务实体。 </p><p>3.TO(Transfer Object) 数据传输对象</p><p>不同的应用程序之间传输的对象 </p><p>4.DTO（Data Transfer Object）数据传输对象</p><p>这个概念来源于 J2EE 的设计模式，原来的目的是为了 EJB 的分布式应用提供粗粒度的 数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。 </p><p>5.VO(value object) 值对象 </p><p>通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已。但应是抽象出 的业务对象 , 可以和表对应 , 也可以不 , 这根据业务的需要 。用 new 关键字创建，由 GC 回收的。 View object：视图对象； 接受页面传递来的数据，封装对象将业务处理完成的对象，封装成页面要用的数据 </p><p><strong>6.BO(business object)</strong> <strong>业务对象</strong> </p><p>从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 </p><p>java 对 象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。business object: 业务对象主要作 用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简 历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经 历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。</p><p>7.POJO(plain ordinary java object) 简单无规则 java 对象 </p><p>传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护 数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增 加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及 setter 和 getter 方法！。POJO 是 DO/DTO/BO/VO 的统称。 </p><p>8.DAO(data access object) 数据访问对象 </p><p>是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久 层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作.</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——金融业务平台</title>
      <link href="/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/"/>
      <url>/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/</url>
      
        <content type="html"><![CDATA[<h1 id="1、产品架构"><a href="#1、产品架构" class="headerlink" title="1、产品架构"></a>1、产品架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207192011048.png" alt="image-20220207192011048"></p><h1 id="2、业务流程"><a href="#2、业务流程" class="headerlink" title="2、业务流程"></a>2、业务流程</h1><p>1、账户绑定</p><p>（用户表、用户绑定表）</p><p>用户——绑定信息提交（借款、出借）——调用第三方托管平台账户创建（阿里云短信）——绑定完成（异步更新）</p><p>2、申请借款额度</p><p>（用户表、积分表、借款人表、借款人图片表）垂直分表</p><p>提交借款人个人信息（身份证等证件资源：对象存储）——后台系统评估——审核通过——获取额度</p><p>3、借款额度审核</p><p>后台借款额度申请列表——借款人信息——借款额度审核</p><p>4、借款申请</p><p>（借款信息表、积分等级配置表、标的准备表）</p><p>获取借款额度（用户积分）——提交借款申请——获取借款申请状态</p><p>5、借款审核</p><p>后台借款信息列表——借款详情——借款审批</p><p>6、标的管理</p><p>（标的表）</p><p>审核完成——新标的、标的详情、标的列表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207194625467.png" alt="image-20220207194625467"></p><p>7、我要投资</p><p>前端标的列表</p><p>8、充值</p><p>（用户账号表[余额等]、交易流水表）</p><p>注册 + 账户绑定——充值——第三方托管支付——完成（异步修改）</p><p>幂等性保证（重复请求）：判断流水是否存在，存在则退出</p><p>9、投标</p><p>收益根据还款方式：等额本息、等额本金、按期付息到期还本、一次还本付息</p><p>（标的表、标的出借记录表、还款记录表、标的出借回款记录表）标的id</p><p>标的详情——输入金额计算收益——投标支付——完成（异步回调：标的状态、投资流水、金额、标的信息）</p><p>10、放款</p><p>（还款人还款记录表、投资人回款记录表）</p><p>管理平台放款——（1）标的状态和标的平台收益（2）<strong>给借款账号转入金额</strong>（3）增加借款交易流水（4）<strong>解冻并扣除投资人资金</strong>（5）增加投资人交易流水（6）生成借款人还款计划和出借人回款计划</p><p>11、投资列表展示</p><p>后台列表——前台列表——后台还款计划——前台还款计划——前台回款计划</p><p>12、提现和还款</p><p>第三方托管提现</p><p>还款——转出金额——分配转入投资方——流水明细、回款明细</p><p>13、个人中心</p><p>流水明细、用户账号明细</p><p>14、消息队列</p><p>监听消息队列发送短信（充值、绑定、转出等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/27528777bac0634fd778ca60094057b4.png" alt="27528777bac0634fd778ca60094057b4"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——MongoDB、业务流程</title>
      <link href="/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/"/>
      <url>/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<h1 id="1、架构"><a href="#1、架构" class="headerlink" title="1、架构"></a>1、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222116806.png" alt="image-20220206222116806"></p><h1 id="2、MongoDB"><a href="#2、MongoDB" class="headerlink" title="2、MongoDB"></a>2、MongoDB</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于分布式文件存储的开源数据库系统</p><p>字段值可以包含其他文档，数组及文档数组。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222409680.png" alt="image-20220206222409680"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MongoDB 是一个面向文档存储的数据库</p><p>MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序</p><p>可以通过本地或者网络创建数据镜像，实现高扩展性</p><p>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上，分片</p><p>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>1、网站数据、大数据、缓存</p><p>2、高伸缩性</p><p>3、对象、json数据</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>MongoTemplate</p><p>MongoRepository（SpringData方法定义规范）</p><h1 id="3、预约挂号业务"><a href="#3、预约挂号业务" class="headerlink" title="3、预约挂号业务"></a>3、预约挂号业务</h1><p>1、排班和挂号详情信息——【医院+科室——规则——日期——排班、挂号信息】</p><p>2、确认挂号信息——【就诊人、排班信息】</p><p>3、生成预约挂号订单【就诊人 + 排班 —— 生成订单】</p><p>4、挂号订单支付（微信）【微信支付、订单状态】</p><p>5、取消预约订单【退款、取消订单】</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206221759069.png" alt="image-20220206221759069"></p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发总结——前后端分离+微服务</title>
      <link href="/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1、MP"><a href="#1、MP" class="headerlink" title="1、MP"></a>1、MP</h1><p>基本流程</p><p>主键自动生成</p><p>自动填充</p><p>乐观锁实现</p><p>select、分页</p><p>delete：逻辑删除、物理删除</p><p>mp性能分析插件</p><p>条件查询Querywrapper</p><h1 id="2、后端1"><a href="#2、后端1" class="headerlink" title="2、后端1"></a>2、后端1</h1><p>json时区</p><p>swagger测试</p><p>统一返回格式</p><p>@requestbody</p><p>统一、指定、自定义异常处理</p><p>日志输出、日志级别</p><h1 id="3、前端1"><a href="#3、前端1" class="headerlink" title="3、前端1"></a>3、前端1</h1><p>es6语法：</p><p>数组解构、对象赋值、模拟字符串、对象方法、箭头函数</p><p>vue指令、组件</p><p>vue生命周期：</p><p>Create、Mounted</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220205230634449.png" alt="image-20220205230634449"></p><p>断点</p><p>Vue路由</p><p>Axios</p><p>Element-ui</p><p>Node.js</p><p>npm</p><p>Babel</p><p>前端模块化</p><p>Webpack</p><p>vue-admin-template、目录结构</p><p>跨域</p><p>路由切换</p><p><strong>开发流程</strong></p><p>服务端渲染技术</p><p>NUST框架</p><h1 id="4、oss、视频点播、短信、微信支付、微信注册"><a href="#4、oss、视频点播、短信、微信支付、微信注册" class="headerlink" title="4、oss、视频点播、短信、微信支付、微信注册"></a>4、oss、视频点播、短信、微信支付、微信注册</h1><p>阿里云对象存储</p><p>阿里云视频点播：上传、播放、删除</p><p>阿里云短信服务</p><p>微信支付</p><p>微信注册</p><h1 id="5、后端2"><a href="#5、后端2" class="headerlink" title="5、后端2"></a>5、后端2</h1><p>nginx</p><p>EasyExcel读写</p><p>Vue tree</p><p>vo</p><p>bean转换</p><p>树形结构：遍历、循环</p><p>路由、隐藏路由、动态路由</p><p>富文本编辑器</p><p>多表联查——SQL</p><p>openfeign、nacos</p><p>远程调用流程：</p><p>1、接口化请求调用</p><p>2、Feign</p><p>3、Hystrix</p><p>4、Ribbon</p><p>5、Httpclient</p><h1 id="6、后端3"><a href="#6、后端3" class="headerlink" title="6、后端3"></a>6、后端3</h1><p>redis缓存：</p><p>Cacheable、Cacheput、Cacheevict</p><p>sso单点登录</p><p>jwt：json web token</p><p>1、jwt头信息</p><p>2、有效载荷</p><p>3、签名哈希</p><p>sso实现：</p><p>1、session复制</p><p>2、Cookie带着唯一key在中redis 查询 </p><p>3、Token：用户信息加密成的字符串（自包含令牌）</p><p>（1）cookie 或者 地址栏</p><p>（2）访问时携带字符串</p><p>Reids过期时间、token过期时间 均可设置过期</p><p>密码加密：</p><p>1、MD5工具类</p><p>2、密码加密和数据库比较</p><p>token解析</p><h1 id="7、前端2"><a href="#7、前端2" class="headerlink" title="7、前端2"></a>7、前端2</h1><p>二维码</p><p>定时器</p><p>token实现：</p><p>(1) 登录返回token</p><p>(2) Token放到cookie中</p><p>(3) 前端拦截器（请求拦截）：判断cookie是否有token，把token放到请求头中</p><p>(4) 根据请求头的token获取用户信息，用户信息放到cookie中</p><p>(5) 显示用户信息</p><p>验证——获得token（放到cookie）——拦截：获取token放到header——调用api获取用户信息（放到cookie）</p><p>cookie：json字符串转为json对象</p><p>OAuth2</p><p>微信登录：</p><p>1、使用httpclient发送get请求（工具类 + 依赖）</p><p>2、从json字符串获取值（转为map）</p><p>3、再请求一个地址，获取扫码人信息</p><p>4、自动注册（未注册）</p><p>token路径传递</p><p>1、通过路径获取token</p><p>以下同前面</p><p>2、Token——cookie、拦截器：token——header</p><p>存在cookie中是因为有拦截器会将cookie中的token存到header中，后端也是从hader中取token的，cookie相当于转存的介质</p><p>3、Token + header = member——cookie</p><p>播放器组件</p><p>评论组件</p><p>微信支付：</p><p>(1) 生成订单</p><p>① 根据课程id获取课程信息——远程调用</p><p>② 根据用户id（jwt从header获取id）获取用户信息——远程调用</p><p>(2) 根据id查询订单信息</p><p>(3) 生成微信支付二维码</p><p>① 、获取订单参数</p><p>②、发送httpclient请求（参数xml）</p><p>③、获取返回结果</p><p>(4) 查询支付状态</p><p>①Service——发送httpclient请求——返回包含状态</p><p>②添加支付记录，更改订单状态</p><p>③定时器</p><p>根据Url下载二维码组件</p><p>Echarts</p><p>定时任务</p><h1 id="8、后端4"><a href="#8、后端4" class="headerlink" title="8、后端4"></a>8、后端4</h1><p>canal数据同步</p><p>Gateway：路由、断言、过滤器</p><p>权限管理</p><p>权限关系表</p><p>递归分级</p><p>SpringSecurity</p><p>nacos配置中心</p><h1 id="9、Jenkins"><a href="#9、Jenkins" class="headerlink" title="9、Jenkins"></a>9、Jenkins</h1><p>Jenkins、github action</p><h1 id="10、产品开发流程"><a href="#10、产品开发流程" class="headerlink" title="10、产品开发流程"></a>10、产品开发流程</h1><p>1、需求调研（产品经理）</p><p>2、需求评审（产品/设计/前端/后端/测试/运营）</p><p>3、立项（项目经理、品管）</p><p>4、UI设计</p><p>5、开发</p><p>· 架构、数据库设计、API文档、MOCK数据、开发、单元测试</p><p>· 前端</p><p>· 后端</p><p>6、前端后端联调</p><p>7、项目提测：黑盒白盒、压力测试（qps）  loadrunner</p><p>8、bug修改</p><p>9、回归测试</p><p>10、运维和部署上线</p><p>11、灰度发布</p><p>12、全量发布</p><p>13、维护和运营</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 产品开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mycat</title>
      <link href="/2022/01/28/Mycat/"/>
      <url>/2022/01/28/Mycat/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><p>① Java与数据库紧耦合。 </p><p>② 高访问量高并发对数据库的压力。 </p><p>③ 读写请求数据不一致</p><p>对比：<img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195056298.png" alt="image-20220128195056298"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>读写分离：配合主从复制、主备模式</p><p>数据分片：分库分表</p><p>多数据源整合</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195358045.png" alt="image-20220128195358045"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>拦截</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195439600.png" alt="image-20220128195439600"></p><p>三个重要配置文件</p><p>1、逻辑库、表、分片节点</p><p>2、分片规则</p><p>3、用户、系统配置</p><h1 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h1><p>Myqsl：从接入点开始复制</p><h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><p>日志格式</p><p>balance属性：读写分离</p><p>复制原理：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195544208.png" alt="image-20220128195544208"></p><h2 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h2><p>主备切换</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195329105.png" alt="image-20220128195329105"></p><h1 id="3、分库分表"><a href="#3、分库分表" class="headerlink" title="3、分库分表"></a>3、分库分表</h1><h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195834488.png" alt="image-20220128195834488"></p><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><p>多表联查</p><p>全局表：全局一致性（广播）</p><p>常用分片规则：</p><p>取模、分片枚举、范围约定、日期</p><h2 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h2><p>1、本地文件</p><p>2、时间戳</p><p>3、数据库方式</p><p>4、reids、雪花算法等</p><h1 id="4、基于HA机制的Mycat高可用"><a href="#4、基于HA机制的Mycat高可用" class="headerlink" title="4、基于HA机制的Mycat高可用"></a>4、基于HA机制的Mycat高可用</h1><p>Mycat集群保证数据库高可用</p><p>haproxy保证mycat高可用（负载均衡）</p><p>Keepalived保证haproxy高可用（创建虚拟ip）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200457657.png" alt="image-20220128200457657"></p><p>安全权限</p><p>user、privileges、sql拦截</p><h1 id="6、监控"><a href="#6、监控" class="headerlink" title="6、监控"></a>6、监控</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200635053.png" alt="image-20220128200635053"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mycat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2022/01/27/RocketMQ/"/>
      <url>/2022/01/27/RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h2><p>限流削峰（请求存在队列中）</p><p>异步解耦</p><p>数据采集</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213121974.png" alt="image-20220127213121974"></p><h2 id="MQ常见协议"><a href="#MQ常见协议" class="headerlink" title="MQ常见协议"></a>MQ常见协议</h2><p>JMS</p><p>STOMP</p><p>AMQP</p><p>MQTT</p><h1 id="2、RocketMQ"><a href="#2、RocketMQ" class="headerlink" title="2、RocketMQ"></a>2、RocketMQ</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>消息、主题、标签、队列、消息标识（消息唯一id：生产者、broker）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213610678.png" alt="image-20220127213610678"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213633953.png" alt="image-20220127213633953"></p><p>生产者</p><p>消费者</p><p>（一个消费者组，消费者消费队列不同）</p><p>Name Server（注册中心）：broker管理、路由信息管理</p><p>路由注册、路由剔除（心跳包）、路由发现、选择策略：轮询</p><p>broker</p><p>组成：实体、客户端管理、存储、高可用（集群数据同步）、索引（ID）</p><p>集群部署：主备集群</p><p>主从、主备</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213923298.png" alt="image-20220127213923298"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>1、启动server、监听端口</p><p>2、Broker与serve长连接</p><p>3、创建topic</p><p>4、生产者发送消息：和server建立连接，获取路由（topic、broker）。</p><p>与broker长连接，向broker发送消息。路由信息每30s缓存在本地。</p><p>5、消费者，server连接，获取路由。与broker长连接，消费。</p><p>Consumer发送心跳，确认broker存活状态。</p><h3 id="Topic的创建模式"><a href="#Topic的创建模式" class="headerlink" title="Topic的创建模式"></a>Topic的创建模式</h3><p>集群、broker模式</p><h3 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h3><p>一般情况数量一样</p><p>设计目的：方便topic的缩容</p><p>写队列先缩容，读队列消费完后再缩容，不丢失任何消息。</p><h2 id="集群搭建理论"><a href="#集群搭建理论" class="headerlink" title="集群搭建理论"></a>集群搭建理论</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214305521.png" alt="image-20220127214305521"></p><h3 id="数据复制与刷盘策略"><a href="#数据复制与刷盘策略" class="headerlink" title="数据复制与刷盘策略"></a>数据复制与刷盘策略</h3><p>生产者、消费者：groupname相同即可</p><p>Nameserver集群：相互不通信，启动即可</p><p>Broker集群：多个主备小集群</p><p>数据复制：master向slave复制</p><h3 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h3><p>刷盘：由内存写入到磁盘</p><p>同步、异步复制（ACK时机）</p><p>同步：slave成功后ack</p><p>异步：master写入后ack</p><h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p>同步、异步刷盘</p><p>同步：broker写入磁盘ack</p><p>异步：broker写入内存ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214313364.png" alt="image-20220127214313364"></p><p>多master集群：宕机后无法消费</p><h3 id="多master多slave集群"><a href="#多master多slave集群" class="headerlink" title="多master多slave集群"></a>多master多slave集群</h3><p>一个master一个slave：主备模式</p><p>Master处理消息读写</p><p>Slave负责消息备份和宕机后的自动切换</p><p>最好使用RAID阵列</p><p>同步双写：同步复制</p><p>安全性最高，RT响应时间长</p><p>Slave不能自动切换</p><p>RAID10磁盘阵列 + 异步复制</p><h2 id="磁盘阵列RAID"><a href="#磁盘阵列RAID" class="headerlink" title="磁盘阵列RAID"></a>磁盘阵列RAID</h2><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h1 id="3、RocketMQ的工作原理"><a href="#3、RocketMQ的工作原理" class="headerlink" title="3、RocketMQ的工作原理"></a>3、RocketMQ的工作原理</h1><h2 id="消息的生产"><a href="#消息的生产" class="headerlink" title="消息的生产"></a>消息的生产</h2><p>1、生产者向servre发送请求，获取topic路由</p><p>2、Server返回topic路由表及broker列表</p><p>（1）路由表：map&lt;topic,queuedata&gt;，queuedata：broker——queue</p><p>找到queue对应的broker</p><p>（2）Broker列表</p><p>3、选择queue</p><p>4、生产者对消息特殊处理</p><p>5、生产者向broker发出RPC请求，发送到queue（底层netty）</p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><p>轮询（问题：性能）、最小投递延迟（问题：分配不均）</p><h2 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h2><h3 id="store目录"><a href="#store目录" class="headerlink" title="store目录"></a>store目录</h3><p>刷盘、消息、配置、队列、消息索引、全局资源锁</p><h3 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h3><p>第n个文件名：前n-1个文件大小之和</p><p>消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214852355.png" alt="image-20220127214852355"></p><h3 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h3><p>消费队列</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214940291.png" alt="image-20220127214940291"></p><p>索引条目：</p><p>是commitlog的索引文件——定位具体消息</p><p>消息条目——偏移量、消息长度、消息tag</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215015213.png" alt="image-20220127215015213"></p><h3 id="对文件的读写"><a href="#对文件的读写" class="headerlink" title="对文件的读写"></a>对文件的读写</h3><p>消息写入</p><p>1、根据queueid，得到comsumequeue要写入的偏移量</p><p>2、封装消息单元</p><p>3、写入commitlog</p><p>4、形成索引条目</p><p>消息拉取</p><p>1、获取所在queue的偏移量</p><p>2、发送broker拉取请求，queue等信息</p><p>3、得到consumequeue中位置</p><p>4、查找指定tag索引</p><p>5、定位commitlog</p><p>6、读取其中的消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215053467.png" alt="image-20220127215053467"></p><p>性能提升：</p><p>文件读写：通过mmap零拷贝</p><p>Comsuequeue读取：</p><p>引入pagecache预读取机制，接近内存读取（顺序读写）</p><p>本质：缓存</p><p>写：先写入pagecache，再异步写入磁盘</p><p>读：首先读pagecache，若没有命中，将磁盘数据加载到pacache，同时对相邻数据预读取</p><p>Commitlog读取：随机访问，会影响性能</p><p>与kafka对比：</p><p>RocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。</p><p>mappedFile文件就类似于Kafka中的segment段</p><h2 id="indexfile"><a href="#indexfile" class="headerlink" title="indexfile"></a>indexfile</h2><p>根据key进行消息查询（前提：消息包含key）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215235908.png" alt="image-20220127215235908"></p><p>Indexheader：该索引索引相关信息（数量，偏移量等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215241833.png" alt="image-20220127215241833"></p><p>Slot</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215249106.png" alt="image-20220127215249106"></p><p>Index</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215257689.png" alt="image-20220127215257689"></p><p>创建</p><p>indexfile查询流程：</p><p>1、根据key、time找到indexfile</p><p>2、传入时间与文件名差值</p><p>3、计算key的hash——Slot序号——读取slot——最新的indexNo</p><p>4、根据indexN找到index位置</p><p>5、相比Index中的diff</p><p>（1）若时间差小，往前找</p><p>（2）若时间差大，index中定位位置，找到消息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215406692.png" alt="image-20220127215406692"></p><h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><h3 id="两种消息获取方式"><a href="#两种消息获取方式" class="headerlink" title="两种消息获取方式"></a>两种消息获取方式</h3><p>Push（consumer主动拉取），注意拉取时间间隔</p><p>pull（broker主动推动，实时性高），向queue注册监听器，基于长连接</p><h3 id="两种消息消费模式"><a href="#两种消息消费模式" class="headerlink" title="两种消息消费模式"></a>两种消息消费模式</h3><p>广播模式：每个消费者都接收topic全部消息</p><p>集群模式：消费者平分消息</p><h3 id="消息进度保存"><a href="#消息进度保存" class="headerlink" title="消息进度保存"></a>消息进度保存</h3><p>广播模式：消费者保存</p><p>集群模式：保存broker中共享，消息进度参与负载均衡</p><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>Queue和consumer的之间重新分配</p><p>增加减少消费者，提升消息并行</p><p>消费者要小于队列</p><p>危害：</p><p>消息暂停：重分配后才能再消费</p><p>消费重复：异步提交，导致可能重复消费</p><p>一次性读取消息数量需要均衡：重复消费、性能</p><p>消息突刺：重复消费过多消息、积压时间过长</p><p>产生的原因和过程</p><p>1、Queue数量变化</p><p>（1）broker扩缩容</p><p>（2）Broker升级运维</p><p>（3）网络异常</p><p>（4）Queue扩缩容</p><p>2、消费者数量变化</p><p>（1）consumergroup扩缩容</p><p>（2）Consumer升级运维</p><p>（3）网络异常</p><p>过程：</p><p>Broker发现变化，向consumergroup发出Rebalance通知</p><p>Consumer采用分配算法，自主进行Rebalance</p><p>Broker中group coordinate选举consumer leader</p><p>由lerder完成分区的再分配，上报coordinate，coordinate同步给consumer实例</p><p>Kafka的Rebalance由选举的comsumer leader完成。</p><p>Rocket的Rebalance由每个consumer完成</p><p>Queue分配算法</p><p>平均分配</p><p>环形平均策略：类似轮询</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215711998.png" alt="image-20220127215711998"></p><p>一致性hash策略：先把consumer放到环上，再把queue的hash值放环上，顺时针找consumer （缺点：分配不均）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215721201.png" alt="image-20220127215721201"></p><p>同机房策略</p><p>一致性hash：减少扩缩容的rebalance</p><p>扩缩容需要rebalance，变化较大</p><p>一致性hash扩缩容变化较小：应用场景，consumer变化较多</p><p>至少一次原则</p><h2 id="订阅关系的一致性"><a href="#订阅关系的一致性" class="headerlink" title="订阅关系的一致性"></a>订阅关系的一致性</h2><h2 id="offset管理"><a href="#offset管理" class="headerlink" title="offset管理"></a>offset管理</h2><p>Consumer的消费进度offset</p><h3 id="Offset本地管理"><a href="#Offset本地管理" class="headerlink" title="Offset本地管理"></a>Offset本地管理</h3><p>广播，消费进度保存在consumer中</p><h3 id="Offset远程管理"><a href="#Offset远程管理" class="headerlink" title="Offset远程管理"></a>Offset远程管理</h3><p>集群消费，保存在broker文件中</p><p>所有consumer共享queue的消费进度</p><p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制</p><p>Rebalance后，新的consumer可以读取相应消费进度继续消费</p><p>NextBeginOffset：下次消费起始</p><p>消费异常：异常消息提交broker的重试队列</p><p>同步、异步提交offset</p><p>异步：提交offset、无需等待broker响应，直接从broker获取next</p><h2 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h2><h3 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h3><p>重复消费影响相同</p><p>1、发送重复：Broker对生产者ack失败，生产者重复发送相同消息（msgid相同）</p><p>2、消费重复：consumer对broker的ack失败，broker再次投递相同消息</p><p>3、Rebalance：consumer、queue变化，没提交ack前Rebalance可能重复消费</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>幂等令牌：具备唯一业务表示的字符串，唯一id</p><p>唯一性处理：服务端采用算法，保证成功执行一次</p><p>1、通过缓存去重，缓存是否命中幂等令牌</p><p>2、数据库查询是否有幂等令牌（缓存可能过期）</p><p>3、同一事务中：唯一性处理、幂等令牌写入缓存，幂等令牌写入DB</p><h3 id="支付场景中的解决方案"><a href="#支付场景中的解决方案" class="headerlink" title="支付场景中的解决方案"></a>支付场景中的解决方案</h3><p>1、首先redis获取流水号</p><p>（1）不为空，调用重复逻辑</p><p>2、无缓存，查询DB</p><p>（1）不为空，调用重复逻辑</p><p>3、为空，在分布式事务完成</p><p>（1）完成支付</p><p>（2）流水号作为key，存入redis（过期时间）</p><p>（3）流水号作为主键存入DB</p><p>消费幂等的实现</p><p>最好以业务唯一标识作为依据</p><h2 id="消息堆积与消费延迟"><a href="#消息堆积与消费延迟" class="headerlink" title="消息堆积与消费延迟"></a>消息堆积与消费延迟</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220321282.png" alt="image-20220127220321282"></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>消费速度跟不上生产速度</p><p>1、上下游能力不匹配</p><p>2、实时性要求较高，延迟造成堆积</p><p>长轮询PULL模式</p><p>1、消息拉取：批量拉取，缓存到本地缓存队列</p><p>2、消息消费：取决于消费并发、消费耗时度</p><p>本地缓存队列达到上限，停止从服务端拉取消息</p><h3 id="消费耗时的深入分析"><a href="#消费耗时的深入分析" class="headerlink" title="消费耗时的深入分析"></a>消费耗时的深入分析</h3><p>主要耗时：外部IO代码</p><p>1、mysql 、redis访问</p><p>2、下游系统调用:dubbo的RPC远程调用、springcloud的http接口调用</p><p>下游系统服务异常等原因</p><p>消息堆积——消息消费——消息耗时——外部IO——下游DB、RPC、http调用——服务异常、容量限制——网络宽带等</p><h3 id="消息并发度的深入分析"><a href="#消息并发度的深入分析" class="headerlink" title="消息并发度的深入分析"></a>消息并发度的深入分析</h3><p>普通消息 并发度 = 单节点线程数 * 节点数（consumer）</p><p>顺序消息：topic的queue分区数量</p><p>全局顺序消息</p><p>分区顺序消息</p><p>单机线程数的计算</p><h3 id="避免消息堆积与消费延迟"><a href="#避免消息堆积与消费延迟" class="headerlink" title="避免消息堆积与消费延迟"></a>避免消息堆积与消费延迟</h3><p>消费耗时</p><p>1、避免循环、递归</p><p>2、IO操作是否可以本地缓存</p><p>3、是否可以异步化处理</p><p>设置消费并发度</p><h2 id="消息的清理"><a href="#消息的清理" class="headerlink" title="消息的清理"></a>消息的清理</h2><p>以commitlog为单位进行清理</p><p>文件过期、磁盘占用率</p><h1 id="4、RocketMQ的应用"><a href="#4、RocketMQ的应用" class="headerlink" title="4、RocketMQ的应用"></a>4、RocketMQ的应用</h1><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>同步发送消息：收到ack后继续发送</p><p>1、创建生产者、group名称</p><p>2、Nameserver配置</p><p>3、开启生产者，发送消息</p><p>4、关闭生产者</p><p>SendResult：状态、msgid</p><p>异步发送消息：无需等待mq的ack消息，发送的回调接口异步响应</p><p>指定回调函数</p><p>单向发送消息：不接收ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220358071.png" alt="image-20220127220358071"></p><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>顺序消息：</p><p>严格按发送顺序进行消费——只有一条queue——一个消费者消费</p><p>相同订单号消息放到同一queue中</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220514365.png" alt="image-20220127220514365"></p><h3 id="消息有序性的分类"><a href="#消息有序性的分类" class="headerlink" title="消息有序性的分类"></a>消息有序性的分类</h3><p>全局有序：只有一个queue</p><p>分区有序</p><p>生产者可以指定queue选择器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220623422.png" alt="image-20220127220623422"></p><h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>指定时长后才可被处理：实现定时任务</p><p>发送延迟消息：过时且判断未支付，放回票池</p><h3 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220640775.png" alt="image-20220127220640775"></p><p>1、先发给延迟topic延迟队列</p><p>2、根据定时管理器，时间到了——发送给commitlog——正常消息</p><p>写入commitqueue</p><p>原本Tage的hashcode改为消息投递时间（定时结束时间）</p><h3 id="再次投递"><a href="#再次投递" class="headerlink" title="再次投递"></a>再次投递</h3><p>1、定时管理器中有相应timertask——负责消息消费和投递</p><p>2、检测相应queue中第一条消息是否到期</p><p>3、若到期，投递</p><p>管理器作为生产者，重新写入commitlog</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220802767.png" alt="image-20220127220802767"></p><p>1、TM向TC发指令，开启全局事务</p><p>2、工行给TC发送事务消息M</p><p>3、TC给broker发送半事务消息（预提交）</p><p>4、Broker预提交返回执行结果</p><p>（1）失败——TC——TM，全局事务结束</p><p>5、成功——调用——预扣款——返回执行结果（本地事务）——TC——TM</p><p>（1）预扣款成功——commit——TC——broker（branch commit）——M可被建行看到</p><p>（2）预扣款失败——rollback——TC——broker（branch rollback）</p><h3 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h3><p>事务消息</p><p>半事务消息：暂不能被消费者看到</p><p>本地事务状态：生产者回调操作执行的结果——TC——TM——全局事务确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220933007.png" alt="image-20220127220933007"></p><p>消息回查：重新查看本地事务的执行状态</p><p>（1）状态（UNKNOWN）</p><p>（2）TC未收到TM的最终全局事务确认指令</p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>XA：分布式事务处理模式</p><p>三剑客</p><p>（1）TC：事务协调者（broker）维护全局事务</p><p>（2）TM：事务管理器（生产者）全局事务发起者</p><p>（3）RM：资源管理器（生产者、broker）报告事务状态</p><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221048552.png" alt="image-20220127221048552"></p><p>1、TM向TC发指令开启全局事务</p><p>2、RM向TC注册分支事务，TC——RM——预执行</p><p>3、RM执行结果返回，TC汇总结果——TM</p><p>（1）global commit——TC——RM</p><p>（2）Global rollback——TC——RM</p><p>事务消息：同步的，先broker再生产者</p><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>Topic、刷盘策略一样</p><p>不能是延时、事务消息</p><p>消息——字符串：topic、body、日志、properties相关属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221147787.png" alt="image-20220127221147787"></p><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>默认一次拉取32条消息</p><p>默认最大一次消费32条</p><p>分割器</p><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>tag过滤</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221233544.png" alt="image-20220127221233544"></p><p>SQL过滤：Properties中的属性，支持运算符</p><h2 id="消息重试机制"><a href="#消息重试机制" class="headerlink" title="消息重试机制"></a>消息重试机制</h2><h3 id="发送-1"><a href="#发送-1" class="headerlink" title="发送"></a>发送</h3><p>1、同步异步会重试，单向无法重试（只管发送）</p><p>2、顺序消息没有重试</p><p>3、可能消息重复、重复消息（负载变化、网络原因）</p><p>4、发送重试策略：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</p><p>同步发送失败</p><p>失败隔离：选择不同broker</p><p>异步发送失败</p><p>消息刷盘失败策略：刷盘失败，默认不会发送到其他broker</p><h3 id="消费-1"><a href="#消费-1" class="headerlink" title="消费"></a>消费</h3><p>顺序消息消费重试：不断重试直至消费成功</p><p>广播消费：消费失败——无消费重试</p><p>若重复完仍然失败——死信队列</p><p>需要重试消费的消息——&gt;重试队列（基于延时消息实现）</p><p>消息监听接口配置</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列：处理异常消息</p><p>详见RabbitMQ</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/01/25/RabbitMQ/"/>
      <url>/2022/01/25/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>消息队列</p><p>流量削峰</p><p>应用解耦：上游只需发送消息</p><p>异步处理：异步处理回调消息</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><p>生产者、交换机、队列、消费者</p><h2 id="六大核心模式"><a href="#六大核心模式" class="headerlink" title="六大核心模式"></a>六大核心模式</h2><p>简单、工作队列、发布订阅、路由、主题、发布确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223147422.png" alt="image-20220125223147422"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>Broker</strong></p><p><strong>Virtual host</strong></p><p><strong>Connection</strong></p><p><strong>Channel</strong></p><p><strong>Exchange</strong></p><p><strong>Queue</strong></p><p><strong>Binding</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223250580.png" alt="image-20220125223250580"></p><h1 id="2、核心"><a href="#2、核心" class="headerlink" title="2、核心"></a>2、核心</h1><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><strong>轮询</strong>分发消息</p><p>消息应答：消费者是否处理消息</p><p>自动应答、手动应答（批量应答）</p><p>消息自动重新入队</p><p>rabbitmq持久化：队列持久化、消息持久化</p><p>不公平分发</p><p>预取值：通道中堆积消息个数</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>单个确认发布</p><p>批量确认发布</p><p>异步确认发布：异步通知——交换机确认收到、未确认收到</p><p>并发链路式队列——发消息和监听线程之间传递消息——本质：map</p><p>1、发送消息时进记录队列</p><p>2、确认回调再删除</p><p>未删除的——未确认消息</p><p>跳表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224155047.png" alt="image-20220125224155047"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224048175.png" alt="image-20220125224048175"></p><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p><p>无名 exchange</p><p>临时队列</p><p>bindings</p><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h3><p>广播：路由key为空</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224517818.png" alt="image-20220125224517818"></p><h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>发送路由key对应队列——无论队列个数</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224644373.png" alt="image-20220125224644373"></p><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p>没有*和#：fanout、direct模式</p><p>*(星号)可以代替一个单词</p><p>#(井号)可以替代零个或多个单词</p><h1 id="3、高级"><a href="#3、高级" class="headerlink" title="3、高级"></a>3、高级</h1><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>发送异常消息——进入死信队列</p><p>死信队列的来源：</p><p>消息 TTL 过期</p><p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p><p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224938734.png" alt="image-20220125224938734"></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延迟队列——消息过期进入死信队列</p><p>存放需要在指定时间被处理的元素的队列</p><p>应用场景</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225016545.png" alt="image-20220125225016545"></p><p>缺陷：ttl不灵活</p><h3 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h3><p>QC队列不设置过期时间，由生产者设置ttl</p><p>缺陷：队列FIFO</p><h3 id="基于插件优化"><a href="#基于插件优化" class="headerlink" title="基于插件优化"></a>基于插件优化</h3><p>基于插件的交换机：在交换机处延迟</p><p>延迟交换机：类型、延迟类型（直接：路由key固定）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225256329.png" alt="image-20220125225256329"></p><p>其他延时队列：</p><p>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz，或者利用 kafka 的时间轮。RabbitMQ安全，完善。</p><h2 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h2><h3 id="交换机回调"><a href="#交换机回调" class="headerlink" title="交换机回调"></a>交换机回调</h3><p>交换机确认消息是否收到</p><p>写回调方法、注入</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225816018.png" alt="image-20220125225816018"></p><p>生产者只管给交换机消息，只接受交换机的接收结果</p><p>路由错误无法接收结果</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>无法路由时，消息回退给交换机，通知生产者</p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>无法投递的消息给备份交换机</p><p>没有什么是加一层解决不了的</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230021103.png" alt="image-20220125230021103"></p><p>备份优先级更高</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等性：重复提交</p><p>消费者ack中断，造成重新消费</p><p>解决思路：生成全局唯一id，消费之前判断是否被消费过</p><p>1、唯一ID + 指纹码机制（数据库）</p><p>2、Redis原子性：利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>设置优先级参数</p><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>消息存到磁盘中，消费者从磁盘取</p><p>内存占比非常小，取消息慢</p><h1 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h1><h2 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125221757500.png" alt="image-20220125221757500"></p><h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125222245390.png" alt="image-20220125222245390"></p><h2 id="高负载均衡"><a href="#高负载均衡" class="headerlink" title="高负载均衡"></a>高负载均衡</h2><p><strong>nginx、gateway</strong>、Haproxy等集群，进行反向代理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230327710.png" alt="image-20220125230327710"></p><p>以下暂用不到</p><h2 id="Shovel集群"><a href="#Shovel集群" class="headerlink" title="Shovel集群"></a>Shovel集群</h2><p>远程同步</p><h2 id="Federation-联邦集群"><a href="#Federation-联邦集群" class="headerlink" title="Federation 联邦集群"></a>Federation 联邦集群</h2><p>Federation Exchange、Federation Queue</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/acae23ba5952abdce66bb65e8b00a5a0.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ</title>
      <link href="/2022/01/24/ActiveMQ/"/>
      <url>/2022/01/24/ActiveMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221656632.png" alt="image-20220124221656632"></p><p>解耦、异步、削峰</p><p>分布式系统</p><p>只要消息发送，尽量异步</p><p>只要解耦，尽量引入消息中间件</p><h2 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h2><p>JMS编码架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221810182.png" alt="image-20220124221810182"></p><p>原生API：</p><p>生产者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息生产者</p><p>消息生产者发送消息</p><p>（1）创建消息</p><p>（2）通过生产者发送</p><p>关闭资源（倒序：生产者、session、连接）</p><p>消费者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息消费者</p><p>消费生产者接收消息——接收消息（一直型、定时型）、消息类型要一致</p><p>关闭资源（倒序：消费者、session、连接）</p><p>1、receive</p><p>2、监听</p><p>队列同时监听：轮询</p><p>主题：先订阅再有生产消息</p><h2 id="3、JMS"><a href="#3、JMS" class="headerlink" title="3、JMS"></a>3、JMS</h2><p>JavaEE</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222038405.png" alt="image-20220124222038405"></p><p>JMS：java消息服务</p><p>消息头</p><p>消息体</p><p>消息属性</p><p>可靠性：持久化、事务、签收、集群</p><h2 id="4、Broker"><a href="#4、Broker" class="headerlink" title="4、Broker"></a>4、Broker</h2><h2 id="5、spring-boot整合"><a href="#5、spring-boot整合" class="headerlink" title="5、spring boot整合"></a>5、spring boot整合</h2><p>间隔定投</p><p>注解监听</p><h2 id="6、传输协议"><a href="#6、传输协议" class="headerlink" title="6、传输协议"></a>6、传输协议</h2><p>种类</p><p>NIO + 多协议</p><h2 id="7、消息存储和持久化"><a href="#7、消息存储和持久化" class="headerlink" title="7、消息存储和持久化"></a>7、消息存储和持久化</h2><p>AMQ</p><p>KahaDB：事务日志 + 索引文件</p><p>Db.log：存储消息、Db.data：B树索引、Lock：文件锁</p><p>LevelDB：基于文件的本地数据库：redis aof</p><p>JDBC + Mysql：</p><p>建库，自动建表：消息表、订阅关系表、记录master表</p><p>JDBC With Journal：</p><p>存到高速缓存日志，减少数据库压力</p><h2 id="8、多节点集群"><a href="#8、多节点集群" class="headerlink" title="8、多节点集群"></a>8、多节点集群</h2><p>Zookeeper和Replicated LevelDB集群</p><p>原理：对外暴露master</p><p>主从复制 + Zookeeper集群</p><p>已被舍弃</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222731107.png" alt="image-20220124222731107"></p><h2 id="9、高级特性、面试考点"><a href="#9、高级特性、面试考点" class="headerlink" title="9、高级特性、面试考点"></a>9、高级特性、面试考点</h2><p>异步投递：</p><p>发送是否成功：写回调函数：成功、失败的信息</p><p>延时投递和定时投递：消息头属性中设置</p><p>分发策略</p><p>消息重试机制：消息侧回滚、消费侧没有commit等</p><p>有毒消息：重发超过6次，放到DLQ（死信队列）</p><p>死信队列：查看出错消息，人工干预修复，可自定义</p><p>防止重复调用，幂等性：数据库主键、redis key</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security</title>
      <link href="/2022/01/24/Spring%20Security/"/>
      <url>/2022/01/24/Spring%20Security/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h2><p>认证</p><p>授权</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220153579.png" alt="image-20220124220153579"></p><h2 id="2、web权限"><a href="#2、web权限" class="headerlink" title="2、web权限"></a>2、web权限</h2><p>查询数据库认证</p><p>自定义登录页面</p><p>方法注解</p><p>注销</p><p>原理分析</p><p>CSRF</p><h2 id="3、微服务权限"><a href="#3、微服务权限" class="headerlink" title="3、微服务权限"></a>3、微服务权限</h2><p>流程</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220433500.png" alt="image-20220124220433500"></p><p>数据库分表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220446710.png" alt="image-20220124220446710"></p><p>JWT：JWT 头、内容、签名哈希</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220917745.png" alt="image-20220124220917745"></p><h2 id="4、源码解析"><a href="#4、源码解析" class="headerlink" title="4、源码解析"></a>4、源码解析</h2><p><strong>Spring Security</strong> 采取<strong>过滤链</strong>实现认证与授权</p><p>认证流程</p><p>权限访问流程</p><p>请求间共享认证信息</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2022/01/24/nginx/"/>
      <url>/2022/01/24/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>nginx</p><p>正向代理</p><p>反向代理</p><p>负载均衡</p><p>动静分离</p><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>高可用集群（主从模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215235206.png" alt="image-20220124215235206"></p><p>高可用集群（双主模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215307904.png" alt="image-20220124215307904"></p><h2 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h2><p><img src="https://img-blog.csdnimg.cn/20191103213303224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hcml0aC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="Nginx 整体架构"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2022/01/24/zookeeper/"/>
      <url>/2022/01/24/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="1、入门"><a href="#1、入门" class="headerlink" title="1、入门"></a>1、入门</h2><p>概述：工作机制</p><p>数据结构：ZNode 树型文件系统</p><p>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下</p><p>线、软负载均衡等</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h2 id="3、集群"><a href="#3、集群" class="headerlink" title="3、集群"></a>3、集群</h2><p>选举机制：</p><p>第一次启动</p><p>非第一次启动：任期id——事务id——id</p><p>节点类型：</p><p>持久、短暂、有序号、无序号</p><p>监听器</p><p>写数据原理：</p><p>发给leader</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213707456.png" alt="image-20220124213707456"></p><p>发给follower</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213720276.png" alt="image-20220124213720276"></p><h2 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h2><p>服务器动态上下线</p><p>分布式锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213847011.png" alt="image-20220124213847011"></p><p>Curator框架实现分布式锁</p><h2 id="5、源码"><a href="#5、源码" class="headerlink" title="5、源码"></a>5、源码</h2><p>选举机制：第一次、非第一次</p><p>分布式一致性：</p><p>Paxos算法</p><p>ZAB协议：消息广播、崩溃恢复</p><p>异常发生——leader选举 + 数据恢复</p><p>数据恢复——一个follower所有事务提交之后才变为follower</p><p>CAP理论：保证CP</p><p>持久化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214406672.png" alt="image-20220124214406672"></p><p>序列化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214429678.png" alt="image-20220124214429678"></p><p>服务端初始化源码-启动脚本</p><p>初始化-解析参数</p><p>初始化-过期快照删除</p><p>初始化-通信初始化</p><p>服务端加载数据源码</p><p>选举-选举准备</p><p>选举-选举执行</p><p>Follower 和 Leader 状态同步源码</p><p>状态同步细节</p><p>Leader启动</p><p>Follower启动</p><p>客户端启动</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214747431.png" alt="image-20220124214747431"></p><p>选举</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo</title>
      <link href="/2022/01/24/dubbo/"/>
      <url>/2022/01/24/dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>分布式系统演变</p><p>RPC原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212540495.png" alt="image-20220124212540495"></p><p>dubbo核心原理</p><p>监控中心</p><h2 id="2、dubbo配置"><a href="#2、dubbo配置" class="headerlink" title="2、dubbo配置"></a>2、dubbo配置</h2><h2 id="3、高可用"><a href="#3、高可用" class="headerlink" title="3、高可用"></a>3、高可用</h2><p>zookeeper</p><p>集群负载均衡</p><p>hystrix、服务熔断、服务降级</p><h2 id="4、原理"><a href="#4、原理" class="headerlink" title="4、原理"></a>4、原理</h2><h3 id="RPC原理："><a href="#RPC原理：" class="headerlink" title="RPC原理："></a>RPC原理：</h3><p>一次完整的RPC调用流程（同步调用，异步另说）如下： </p><p><strong>1）服务消费方（client）调用以本地调用方式调用服务；</strong> </p><p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p><p>3）client stub找到服务地址，并将消息发送到服务端； </p><p>4）server stub收到消息后进行解码； </p><p>5）server stub根据解码结果调用本地的服务； </p><p>6）本地服务执行并将结果返回给server stub； </p><p>7）server stub将返回结果打包成消息并发送至消费方； </p><p>8）client stub接收到消息，并进行解码； </p><p><strong>9）服务消费方得到最终结果。</strong></p><p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h3 id="netty通信原理"><a href="#netty通信原理" class="headerlink" title="netty通信原理"></a>netty通信原理</h3><p>BIO</p><p>NIO</p><h3 id="dubbo原理"><a href="#dubbo原理" class="headerlink" title="dubbo原理"></a>dubbo原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212904106.png" alt="image-20220124212904106"></p><p>框架设计</p><p>启动解析、加载配置信息</p><p>服务暴露</p><p>服务引用</p><p>服务调用</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch</title>
      <link href="/2022/01/24/elasticsearch/"/>
      <url>/2022/01/24/elasticsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="入门-HTTP"><a href="#入门-HTTP" class="headerlink" title="入门-HTTP"></a>入门-HTTP</h1><h1 id="入门-JavaAPI"><a href="#入门-JavaAPI" class="headerlink" title="入门-JavaAPI"></a>入门-JavaAPI</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>进阶：文档、字段、映射、分片、副本、分配</p><p>系统架构：</p><p>选举主节点，master调度管理集群</p><p>P1P2P3分片、R2R0R1副本，不在一个机器上</p><p>每一个分片就是底层的LUCENE的索引</p><p>分布式集群：</p><p>故障转移、水平扩容、应对故障</p><p>路由计算 &amp; 分片控制</p><p>数据写流程</p><p>数据读流程</p><p>更新流程 &amp; 批量操作流程</p><p>倒排索引</p><p>文档搜索</p><p>文档刷新 &amp; 文档刷写 &amp; 文档合并</p><p>文档分析</p><p>文档处理</p><p>文档展示-Kibana</p><h1 id="框架集成"><a href="#框架集成" class="headerlink" title="框架集成"></a>框架集成</h1><p>SpringData-整体介绍</p><p>文档搜索</p><p>Spark streaming</p><p>Flink</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>硬件选择</p><p>分片策略</p><p>路由选择</p><p>写入速度优化</p><p>重要配置</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>为什么使用elasticsearch</p><p>Master选举</p><p>集群脑裂</p><p>索引文档的流程</p><p>更新和删除文档</p><p>搜索流程</p><p>Linux设置部署优化</p><p>GC方面，注意</p><p>上亿数据的聚合实现</p><p>并发情况下，如何保证读写—致</p><p>监控</p><p>字典树</p><p>集群、节点、索引、文档、类型</p><p>倒排索引</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>为什么使用es</p><p>概念：集群、节点、索引、文档、类型</p><p>基本操作：索引、更新、删除、搜索</p><p>集群：master选举、脑裂</p><p>字典树</p><p>倒排索引</p><p>优化：linux部署设置、GC、</p><p>海量数据：如何聚合</p><p>高并发：如何保证读写一致</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2022/01/24/docker/"/>
      <url>/2022/01/24/docker/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/docker%E6%80%BB%E7%BB%93.png" alt="docker总结"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/01/24/redis/"/>
      <url>/2022/01/24/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h2><p>Memcache</p><p>Redis</p><p>MongoDB</p><h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>单线程+多路IO复用</p><p>应用场景：</p><p>缓存、session共享、持久化</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124203929901.png" alt="image-20220124203929901"></p><h2 id="五大常用数据类型"><a href="#五大常用数据类型" class="headerlink" title="五大常用数据类型"></a>五大常用数据类型</h2><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><h2 id="三大新数据类型"><a href="#三大新数据类型" class="headerlink" title="三大新数据类型"></a>三大新数据类型</h2><h2 id="redis配置文件"><a href="#redis配置文件" class="headerlink" title="redis配置文件"></a>redis配置文件</h2><p>网络连接：心跳检测、连接时长</p><p>通用：日志级别、库</p><p>存储策略</p><h2 id="reids的发布和订阅"><a href="#reids的发布和订阅" class="headerlink" title="reids的发布和订阅"></a>reids的发布和订阅</h2><p>Bitmaps：统计</p><p>HyperLogLog：基数计算：不重复数据个数的计算</p><p>Geographic：地理</p><h2 id="Jedis、RedisTemplate"><a href="#Jedis、RedisTemplate" class="headerlink" title="Jedis、RedisTemplate"></a>Jedis、RedisTemplate</h2><h2 id="事务、锁机制、秒杀"><a href="#事务、锁机制、秒杀" class="headerlink" title="事务、锁机制、秒杀"></a>事务、锁机制、秒杀</h2><p>事务：</p><p>Multi、Exec、discard</p><p>悲观锁、乐观锁</p><p>监视key</p><p>特点：单独的隔离操作、没有隔离级别的概念、不保证原子性</p><p>秒杀：</p><p>乐观锁 + 连接池 + LUA脚本（原子化）  解决库存遗留问题</p><h2 id="持久化RDB、AOF"><a href="#持久化RDB、AOF" class="headerlink" title="持久化RDB、AOF"></a>持久化RDB、AOF</h2><p>RDB：临时文件 –&gt; 覆盖</p><p>AOF：只记录写的操作，只能追加，redis读取这些操作重写构建数据</p><p>写操作追加到缓存区，根据策略进行持久化同步，根据重写策略进行重写压缩</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>一主二仆</p><p>薪火相传：分组传递</p><p>宕机上位</p><p>连接时：全量复制</p><p>同步时：增量复制</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124205643714.png" alt="image-20220124205643714"></p><p>主从复制原理</p><p>哨兵模式：</p><p>Master down ，sentinel自动监控 —&gt; 选举某从机作为主机</p><p>Master 再次上线后 变为从机</p><p>选举规则：</p><p>1、Priority最小</p><p>2、偏移量最全</p><p>3、Runid最小的（随机生成）</p><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><p>无中心化</p><p>集群节点的插槽计算：计算key所属的插槽，平均分摊压力</p><p>哈希槽分区</p><h2 id="应用问题"><a href="#应用问题" class="headerlink" title="应用问题"></a>应用问题</h2><p>缓存穿透</p><p>解决方案：</p><p>缓存空值（设置过期时间）、设置白名单（bitmaps）</p><p>布隆过滤器（底层bitmap）、实时监控redis（设置黑名单）</p><p>缓存击穿</p><p>解决方案：</p><p>预先设置热门key（增加时长）、实时调整（频繁访问key增加时长）</p><p>锁（先上锁，查完数据库放锁）</p><p>缓存雪崩</p><p>构建多层缓存（多级缓存处理）、锁和队列（不适合高并发）</p><p>设置过期标志（更新时长）、分散缓存失效时间（过期时间不同）</p><p>分布式锁</p><p>reids分布式锁：</p><p>setnx  同时设置过期时间</p><p>Redisson</p><p>总结：</p><p>Uuid + 过期时间 + 加锁</p><p>Lua释放锁（uuid比较）</p><h2 id="Redis6新功能"><a href="#Redis6新功能" class="headerlink" title="Redis6新功能"></a>Redis6新功能</h2><p>Acl用户权限</p><p>Io多线程：网络数据读写和协议解析</p><p>工具支持cluster</p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud + SpringCloud Alibaba分布式集群总结</title>
      <link href="/2022/01/24/SpringCoud%20Alibaba/"/>
      <url>/2022/01/24/SpringCoud%20Alibaba/</url>
      
        <content type="html"><![CDATA[<h2 id="eureka："><a href="#eureka：" class="headerlink" title="eureka："></a>eureka：</h2><p>单机eureka、集群eureka</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="zookeeper："><a href="#zookeeper：" class="headerlink" title="zookeeper："></a>zookeeper：</h2><p>linux docker部署zookeeper，配置注册地址</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="consul："><a href="#consul：" class="headerlink" title="consul："></a>consul：</h2><p>命令本地启动consul，8500端口页面</p><p>resttemplate + @loadbalance 负载均衡 调用</p><h2 id="Ribbon："><a href="#Ribbon：" class="headerlink" title="Ribbon："></a>Ribbon：</h2><p>Irule配置或自定义负载均衡算法，@Ribbonclient配置调用的服务和算法</p><p>手写轮询算法，CAS锁</p><h2 id="Openfeign："><a href="#Openfeign：" class="headerlink" title="Openfeign："></a>Openfeign：</h2><p>接口注解调用，默认支持ribbon自带负载均衡</p><p>ribbon超时控制，日志显示</p><h2 id="Hystrix："><a href="#Hystrix：" class="headerlink" title="Hystrix："></a>Hystrix：</h2><p>服务降级：@HystrixCommand，调用中出现错误、超时、宕机等，启用兜底方法，fallback方法分离</p><p>服务熔断：配置熔断情况，时间窗口，请求阈值，错误百分比阈值等，half open</p><p>hystrixDashboard可视化监控，监控服务访问</p><h2 id="Zuul、Gataway："><a href="#Zuul、Gataway：" class="headerlink" title="Zuul、Gataway："></a>Zuul、Gataway：</h2><p>路由转发、断言匹配、执行过滤器链，支持负载均衡</p><p>作为中转站进行路由映射，过滤器生命周期pre、post，常用过滤器：请求头、参数匹配等，自定义过滤器</p><h2 id="Config："><a href="#Config：" class="headerlink" title="Config："></a>Config：</h2><p>服务端实时获取Github配置，文件配置映射，生产模式配置，客户端父子配置文件，设置文件映射和配置中心</p><p>Post请求动态刷新客户端配置</p><h2 id="Bus："><a href="#Bus：" class="headerlink" title="Bus："></a>Bus：</h2><p>支持RabbitMQ和kafka，自动进行消息监听配置中心变化，全局订阅实现配置更新，称为消息总线</p><p>加入bus依赖，rabbitmq配置，自动监听，一次发送处处生效</p><p>定点刷新，post附带服务端端口号</p><h2 id="Stream："><a href="#Stream：" class="headerlink" title="Stream："></a>Stream：</h2><p>统一底层差异，设置生产者、消费者、监听进行消息发送</p><p>分组消费，配置group，支持消息持久化</p><h2 id="Sleuth："><a href="#Sleuth：" class="headerlink" title="Sleuth："></a>Sleuth：</h2><p>zipkin可视化监控，本地命令启动，全局链路id关联调用链路</p><p>配置zikpin地址，采样率设置</p><h2 id="Nacos："><a href="#Nacos：" class="headerlink" title="Nacos："></a>Nacos：</h2><p>nacos服务注册中心，本地命令启动，支持CP、AP切换</p><p>作为配置中心，加入配置匹配格式，配置名称空间，分组等进行匹配，自带动态刷新</p><p>namespace：环境、group：分组，不同微服务模块、service：微服务模块、cluster：集群，杭州虚拟划分，实现容灾，instance：微服务实例</p><p>持久化配置，默认嵌入式数据库derby，连接到mysql即可</p><p>nacos集群，linux docker部署，请求到Nginx集群，nacos集群，底层db集群</p><h2 id="Sentinel："><a href="#Sentinel：" class="headerlink" title="Sentinel："></a>Sentinel：</h2><p>sentinel可视化控制台，本地命令启动，yaml配置地址，默认懒加载</p><p>流控规则，</p><p>统计规则：慢调用比例，异常比例、异常数，</p><p>流控模式：直接、关联，关联的资源达到阈值限流自己、链路，统计指定资源到当前资源，对请求来源限流，</p><p>流控效果：直接、预热，阈值从冷启动因子经过预热时长后达到正常阈值，秒杀应用、排队等待，匀速排队，阈值必须为qps，处理间隔突发的流量</p><p>服务降级，降级策略：RT平均响应时间、异常比例、异常数，分钟统计，支持半开状态</p><p>热点key限流，支持参数索引，排除特殊参数。系统规则，全局限流</p><p>@SentinelResource，blockhandler：限流兜底方法，自定义限流处理逻辑，代码分离</p><p>服务熔断，整合ribbon，加上fallback即可，整合feign，消费者侧接口注解处fallback</p><p>规则持久化，yaml配置datasource，地址指向nacos，文件匹配</p><h2 id="seata："><a href="#seata：" class="headerlink" title="seata："></a>seata：</h2><p>ID+三组件，TC全局事务协调器，TM事务提交回滚，RM分支事务、分支注册、状态汇报等</p><p>seata service本机命令启动，配置文件，数据库，nacos地址</p><p>mysql建表，seata事务表，业务数据库回滚日志表</p><p>微服务配置，文件nacos匹配，yaml配置，seata代理数据库，@GlobalTransactional，异常回滚</p><p>执行流程：一阶段加载：解析sql语句找到业务数据保存为before image，执行业务sql，保存after iamge，生成行锁，二阶段提交：顺利提交，seata删除快照和行锁，完成数据清理即可，二阶段回滚：回滚执行的业务sql，通过一阶段回滚日志进行反向补偿，用before image还原业务数据，脏写校验，对比当前和after image</p><h2 id="分布式全局唯一id："><a href="#分布式全局唯一id：" class="headerlink" title="分布式全局唯一id："></a>分布式全局唯一id：</h2><p>UUID，入库性能差、数据库自增主键，B+树索引分裂、reids集群增长步长，需要维护，雪花算法</p><p><img src="https://z3.ax1x.com/2021/07/27/WhcJM9.png" alt="WhcJM9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud Alibaba </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
