<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gca的学习录</title>
  
  
  <link href="https://fireonice.github.io/atom.xml" rel="self"/>
  
  <link href="https://fireonice.github.io/"/>
  <updated>2022-03-06T15:28:24.559Z</updated>
  <id>https://fireonice.github.io/</id>
  
  <author>
    <name>gca</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谷粒商城——云原生核心-Kubernetes</title>
    <link href="https://fireonice.github.io/2022/03/06/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A0%B8%E5%BF%83-Kubernetes/"/>
    <id>https://fireonice.github.io/2022/03/06/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A0%B8%E5%BF%83-Kubernetes/</id>
    <published>2022-03-06T14:49:41.462Z</published>
    <updated>2022-03-06T15:28:24.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker只是解决服务下层的问题，服务上层建筑如容器编排，服务发现等问题已经超越了Docker的管辖。</p><p>Kubernetes提供的编排和管理功能，轻松完成大规模容器部署，借助k8s的编排功能，用户可以构建跨多个容器的应用服务，实现跨集群调度，扩展容器，以及长期持续管理这些容器的健康状况等，并整合网络，存储，安全性，监控及其他服务，提供全面的容器基础架构。</p><p>Kubernetes 满足了一系列产品内运行程序的普通需求，兼具平台即服务（PaaS）的简化和基础架构即服务（IaaS）的灵活，并促进了在平台服务提供商之间的迁移。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225820940.png" alt="image-20220306225820940"></p><p><strong>微服务</strong><br>微服务解决的是我们软件开发中一直追求的低耦合+高内聚，微服务可以解决这个问题，微服务的本质是把一块大饼分成若干块低耦合的小饼，比如一块小饼专门负责接收外部的数据，一块小饼专门负责响应前台的操作，小饼可以进一步拆分，比如负责接收外部数据的小饼可以继续分成多块负责接收不同类型数据的小饼，这样每个小饼出问题了，其它小饼还能正常对外提供服务。</p><p><strong>DevOps</strong><br>DevOps的意思就是开发和运维不再是分开的两个团队，而是你中有我，我中有你的一个团队。我们现在开发和运维已经是一个团队了，但是运维方面的知识和经验还需要持续提高。</p><p><strong>持续交付</strong><br>持续交付的意思就是在不影响用户使用服务的前提下频繁把新功能发布给用户使用，要做到这点非常非常难。我们现在两周一个版本，每次上线之后都会给不同的用户造成不同程度的影响。</p><p><strong>容器化</strong><br>容器化的好处在于运维的时候不需要再关心每个服务所使用的技术栈了，每个服务都被无差别地封装在容器里，可以被无差别地管理和维护，现在比较流行的工具是docker和k8s。</p><p>简单地把云原生理解为：云原生 = 微服务 + DevOps + 持续交付 + 容器化</p><p>k8s官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>整体主从方式</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230018184.png" alt="image-20220306230018184"></p><ul><li><p>组件</p><ul><li><p>master</p><ul><li>kube-apiserver<ul><li>外界进行资源操作的入口</li><li>认证、授权、访问控制、api注册、发现</li></ul></li><li>etcd<ul><li>nosql数据库</li><li>集群数据</li></ul></li><li>kube-schedule<ul><li>从etcd中获取任务进行调度，选择节点运行</li><li>所有对k8s集群的操作，都必须经过主节点</li></ul></li><li>kube-controller-manager<ul><li>node controller（节点控制器）<ul><li>在节点出现故障时进行通知和响应</li></ul></li><li>replication controller（副本控制器）<ul><li>部署</li></ul></li><li>endpoints controller（端点控制器）<ul><li>暴露端口之类的</li></ul></li><li>service account &amp; token controllers<ul><li>控制安全</li></ul></li></ul></li></ul></li><li><p>node</p><ul><li>container runtime<ul><li>容器运行环境，如docker</li></ul></li><li>kubelet<ul><li>每个节点的代理，保证容器都运行在Pod中<ul><li>pod：一组容器，最小部署单元</li></ul></li><li>维护容器的生命周期，数据卷、网络</li></ul></li><li>kube-proxy<ul><li>每个节点的网络代理，帮助请求路由和访问具体容器</li></ul></li><li>fluentd<ul><li>节点日志收集</li></ul></li></ul></li></ul></li></ul><p>master</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230319472.png" alt="image-20220306230319472"></p><p>node</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230348661.png" alt="image-20220306230348661"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230401741.png" alt="image-20220306230401741"></p><ul><li><p>Container：容器，可以是 docker 启动的一个容器 </p></li><li><p>Pod： </p><ul><li>k8s 使用 Pod 来组织一组容器 </li><li>一个 Pod 中的所有容器共享同一网络。 </li><li>Pod 是 k8s 中的最小部署单元 </li></ul></li><li><p>Volume </p><ul><li>声明在 Pod 容器中可访问的文件目录 </li><li>可以被挂载在 Pod 中一个或多个容器指定路径下 </li><li>支持多种后端存储抽象(本地存储，分布式存储，云存储…) </li></ul></li><li><p>Controllers：更高层次对象，部署和管理 Pod；</p><ul><li>ReplicaSet：确保预期的 Pod 副本数量 </li><li>Deplotment：无状态应用部署 </li><li>StatefulSet：有状态应用部署 </li><li>DaemonSet：确保所有 Node 都运行一个指定 Pod </li><li>Job：一次性任务 </li><li>Cronjob：定时任务 </li></ul></li><li><p>Deployment： </p><ul><li>定义一组 Pod 的副本数目、版本等 </li><li>通过控制器（Controller）维持 Pod 数目(自动回复失败的 Pod) </li><li>通过控制器以指定的策略控制版本（滚动升级，回滚等） </li></ul></li><li><p>Service </p><ul><li>定义一组 Pod 的访问策略 </li><li>Pod 的负载均衡，提供一个或者多个 Pod 的稳定访问地址 </li><li>支持多种方式（ClusterIP、NodePort、LoadBalance） </li></ul></li><li><p>Label：标签，用于对象资源的查询，筛选 </p></li><li><p>Namespace：命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制（鉴权，资源） </li><li>每个资源都属于一个 namespace </li><li>同一个 namespace 所有资源名不能重复 </li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306230837907.png" alt="image-20220306230837907"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 流程</span><br><span class="line">    + kubectl——apiserver——etcd</span><br><span class="line">    + controller manager——监听——apiserver</span><br><span class="line">    + 发现pod未创建</span><br><span class="line">    + 根据pod模板生成pod对象，apiserver——etcd</span><br><span class="line">    + scheduler——监听——选定node，apiserver——etcd</span><br><span class="line">    + kubelet——监听——启动pod</span><br></pre></td></tr></table></figure><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>调度</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225909169.png" alt="image-20220306225909169"></p><p>自动恢复</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225921697.png" alt="image-20220306225921697"></p><p>水平伸缩</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306225940799.png" alt="image-20220306225940799"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231026852.png" alt="image-20220306231026852"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231116495.png" alt="image-20220306231116495"></p><p>1、设置 linux 环境</p><p>2、所有节点安装 Docker、kubeadm、kubelet、kubectl</p><p>3、安装 Pod 网络插件（CNI）</p><p>4、加入 Kubernetes Node </p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306231924323.png" alt="image-20220306231924323"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>pod、controller</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232549267.png" alt="image-20220306232549267"></p><p>deployment、service</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232559381.png" alt="image-20220306232559381"></p><p>labels、selectors</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232631265.png" alt="image-20220306232631265"></p><p>ingress</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232639695.png" alt="image-20220306232639695"></p><p>ingress——&gt;service——&gt;pod——&gt;container</p><p>网络模型</p><p>Kubernetes的网络模型从内至外由四个部分组成：</p><p>1、Pod内部容器所在的网络 </p><p>2、Pod所在的网络 </p><p>3、Pod和Service之间通信的网络</p><p>4、外界与Service之间通信的网络</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220306232717133.png" alt="image-20220306232717133"></p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——高并发（秒杀）系统&amp;Sentinel&amp;链路追踪</title>
    <link href="https://fireonice.github.io/2022/03/04/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E7%A7%92%E6%9D%80%EF%BC%89%E7%B3%BB%E7%BB%9F&amp;Sentinel&amp;%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://fireonice.github.io/2022/03/04/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E7%A7%92%E6%9D%80%EF%BC%89%E7%B3%BB%E7%BB%9F&amp;Sentinel&amp;%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-03-04T14:07:06.689Z</published>
    <updated>2022-03-04T15:32:18.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、秒杀业务"><a href="#1、秒杀业务" class="headerlink" title="1、秒杀业务"></a>1、秒杀业务</h1><p>秒杀具有瞬间高并发的特点，针对这一特点，必须要做限流 + 异步 + 缓存（页面静态化）+ 独立部署。 </p><h2 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304221850788.png" alt="image-20220304221850788"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304221910750.png" alt="image-20220304221910750"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ 秒杀（高并发）系统关注的问题</span><br><span class="line">    + 独立部署</span><br><span class="line">    + 防止影响其他服务</span><br><span class="line">    + 链接加密</span><br><span class="line">    + 防止请求暴露，恶意攻击</span><br><span class="line">    + 库存预热</span><br><span class="line">        + redis信号量</span><br><span class="line">        + redis高可用</span><br><span class="line">    + 动静分离</span><br><span class="line">        + nginx</span><br><span class="line">        + cdn</span><br><span class="line">    + 恶意请求拦截</span><br><span class="line">    + 网关层</span><br><span class="line">    + 流量错峰</span><br><span class="line">        + 小米：验证码</span><br><span class="line">        + 验证正常请求</span><br><span class="line">    + 流量错峰</span><br><span class="line">   + 加入购物车</span><br><span class="line">    + 结算时间不同，流量错峰</span><br><span class="line">    + 限流&amp;熔断&amp;降级</span><br><span class="line">        + 限流</span><br><span class="line">            + 前端限流</span><br><span class="line">            + 点击次数、间隔限制</span><br><span class="line">            + 后端限流</span><br><span class="line">                + 筛选非用户行为</span><br><span class="line">                + 限制请求次数、总量            </span><br><span class="line">            + nginx限流</span><br><span class="line">            + 直接负载部分请求到错误的静态页面</span><br><span class="line">            + 令牌算法 漏斗算法</span><br><span class="line">            + 网关限流</span><br><span class="line">            + 限流的过滤器</span><br><span class="line">        + 熔断、降级</span><br><span class="line">            + 调用链路异常，快速失败熔断</span><br><span class="line">            + 流量太大，引导部分请求降级</span><br><span class="line">    + 队列削峰（杀手锏）</span><br><span class="line">        + 抢到信号量的放行后台</span><br><span class="line">        + 后台发送消息到队列，返回秒杀成功回调</span><br><span class="line">        + 订单服务等监听队列，慢慢创建订单处理成功秒杀的消息</span><br></pre></td></tr></table></figure><h2 id="秒杀商品上架（定时、异步、幂等性）、展示、渲染"><a href="#秒杀商品上架（定时、异步、幂等性）、展示、渲染" class="headerlink" title="秒杀商品上架（定时、异步、幂等性）、展示、渲染"></a>秒杀商品上架（定时、异步、幂等性）、展示、渲染</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304222418396.png" alt="image-20220304222418396"></p><p>定时任务&amp;异步任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ 开启定时任务@EnableScheduling</span><br><span class="line">+ 定时方法注解@Scheduled</span><br><span class="line">+ spring中区别</span><br><span class="line">        + cron语法</span><br><span class="line">        + 默认阻塞</span><br><span class="line">+ 解决阻塞</span><br><span class="line">        + 异步编排运行，自己提交到线程池</span><br><span class="line">        + 支持定时任务线程池（线程池默认大小为一）</span><br><span class="line">            + 配置文件设置线程池大小</span><br><span class="line">            + 不太好使</span><br><span class="line">        + 让定时任务异步执行（异步任务）</span><br><span class="line"></span><br><span class="line">+ 异步任务</span><br><span class="line">    + 开启异步任务@EnableAsync</span><br><span class="line">    + 异步方法注解@Async</span><br><span class="line">        + 默认使用线程池，大小为8</span><br><span class="line">        + 可配置线程池属性</span><br><span class="line"></span><br><span class="line">+ 在Spring中表达式是6位组成，不允许第七位的年份</span><br><span class="line">+ 在周几的的位置,1-7代表周一到周日</span><br><span class="line">+ 定时任务不该阻塞。默认是阻塞的</span><br><span class="line">+ 可以让业务以异步的方式，自己提交到线程池</span><br><span class="line">+ CompletableFuture.runAsync(() -&gt; &#123;&#125;,execute);</span><br><span class="line">+ 支持定时任务线程池；设置 TaskSchedulingProperties</span><br><span class="line">+ spring.task.scheduling.pool.size: 5</span><br><span class="line">+ 让定时任务异步执行</span><br><span class="line">+ 异步任务</span><br><span class="line">+ 解决：使用异步任务 + 定时任务来完成定时任务不阻塞的功能</span><br></pre></td></tr></table></figure><p>上架商品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ 上架service</span><br><span class="line">    + 远程调用优惠系统，扫描最近三天需要秒杀的商品</span><br><span class="line">    + 查询最近三天秒杀活动</span><br><span class="line">    + 得到最近三天格式化日期 </span><br><span class="line">+ 查询起始时间between起始和结束之间的活动</span><br><span class="line">+ 遍历每一个活动，查询关联商品list</span><br><span class="line">+ 根据活动id查询关联表</span><br><span class="line">    + 封装返回数据Vo</span><br><span class="line">    + 上架商品</span><br><span class="line">+ 缓存到reids</span><br><span class="line">            + 缓存活动信息</span><br><span class="line">                + 遍历活动，获取开始结束时间作为key</span><br><span class="line">                + 收集活动所有商品id list作为value</span><br><span class="line">            + 缓存活动的关联商品信息</span><br><span class="line">                + 准备hash操作</span><br><span class="line">                + 遍历每个商品，商品skuid作为key</span><br><span class="line">                + 商品To（sku秒杀信息、详细信息、随机码、开始结束时间）作为value（转为json）</span><br><span class="line">                + 远程调用商品服务（查询详细信息）</span><br><span class="line">+ 根据sku id查询商品详细信息</span><br><span class="line">                    + 随机码（UUID）</span><br><span class="line">                    + 防止提前脚本发请求秒杀</span><br><span class="line">                    + 秒杀开始才暴露</span><br><span class="line">+ 秒杀商品设置分布式信号量（限流），作为库存扣减信息</span><br><span class="line">                    + 引入redisson</span><br><span class="line">                    + 配置redisson客户端</span><br><span class="line">                    + key：商品随机码</span><br><span class="line">                    + value：商品秒杀数量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304223213629.png" alt="image-20220304223213629"></p><p>幂等性保证</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304223954144.png" alt="image-20220304223954144"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 加入分布式锁</span><br><span class="line">    + 防止多台机器同一时间上架</span><br><span class="line">    + 同时判断key不存在，导致同时追加，所以必须有锁</span><br><span class="line">+ 幂等性保证</span><br><span class="line">    + 缓存活动信息，判断key sessionid是否存在</span><br><span class="line">    + 缓存sku信息，key：场次 + 商品id，判断key sessionid_skuid是否存在</span><br><span class="line">    + 解决多场次同一商品问题</span><br><span class="line">    + 缓存信号量，跟商品是否上架一起执行</span><br></pre></td></tr></table></figure><p>查询秒杀商品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 展示首页秒杀商品</span><br><span class="line">    + controller：判断符合当前时间秒杀场次的商品（获取当前时间可以参与的秒杀商品信息）</span><br><span class="line">        + 确定当前时间属于哪个秒杀场次</span><br><span class="line">        + 遍历所有keys，截取字符串，判断时间</span><br><span class="line">        + 获取秒杀场次的所有商品信息</span><br><span class="line">            + 获取场次所有商品id</span><br><span class="line">            + 根据id获取hash中的商品详情</span><br><span class="line">            + 封装Vo</span><br></pre></td></tr></table></figure><p>秒杀页面渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 秒杀预告</span><br><span class="line">+ 商品页面，查询当前sku是否参与秒杀优惠</span><br><span class="line">    + 远程调用秒杀服务，根据skuid 查询redis商品详情hash</span><br><span class="line">        + 找到所有秒杀商品的key</span><br><span class="line">        + 遍历key正则匹配，找到商品</span><br><span class="line">    + 判断秒杀是否开始，未开始则不暴露随机码</span><br><span class="line">    + feign调用、封装</span><br><span class="line">    + 异步编排</span><br><span class="line">+ 前端取值，格式化日期，三个时间区间判断</span><br><span class="line">        + 未到</span><br><span class="line">        + 正在秒杀</span><br><span class="line">        + 已过，不显示</span><br><span class="line">+ 首页跳转</span><br></pre></td></tr></table></figure><h2 id="秒杀业务（登录检查、）"><a href="#秒杀业务（登录检查、）" class="headerlink" title="秒杀业务（登录检查、）"></a>秒杀业务（登录检查、）</h2><p>登录检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ 处于秒杀阶段商品，加入购物车改为立即抢购</span><br><span class="line">+ 秒杀前端跳转请求</span><br><span class="line">    + 登录判断</span><br><span class="line">    + 参数</span><br><span class="line">        + 场次_商品id</span><br><span class="line">        + 随机码（令牌）</span><br><span class="line">        + 件数</span><br><span class="line">+ 处理秒杀请求</span><br><span class="line">    + controller</span><br><span class="line">        + 登录拦截</span><br><span class="line">        + 引入spring-session</span><br><span class="line">                + 序列化器等配置</span><br><span class="line">                + 存储类型为redis</span><br><span class="line">            + 引入登录拦截器</span><br><span class="line">            + 注册拦截器</span><br></pre></td></tr></table></figure><p><strong>秒杀流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一套流程：</span><br><span class="line">+ 购物车——订单确认页——提交订单结算</span><br><span class="line">+ 多个服务都收到高并发流量</span><br><span class="line">+ 同时也错峰了一部分流量</span><br><span class="line">+ 融合和兼容秒杀购买与正常购买流程</span><br><span class="line"></span><br><span class="line">第二套流程：</span><br><span class="line">+ 点击秒杀，合法校验通过直接获取信号量</span><br><span class="line">+ 发送消息给MQ，直接返回秒杀成功</span><br><span class="line">+ 订单等其他服务慢慢处理MQ请求</span><br><span class="line">+ 订单创建完成，用户确认结算即可</span><br><span class="line">+ 优点</span><br><span class="line">    + 流程快速，除了创建订单无需操作数据库、远程调用等</span><br><span class="line">    + 订单服务需要高可用</span><br><span class="line">    + 整个业务独立</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304224859675.png" alt="image-20220304224859675"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponFeignService couponFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductFeignService productFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SESSION__CACHE_PREFIX = <span class="string">&quot;seckill:sessions:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SECKILL_CHARE_PREFIX = <span class="string">&quot;seckill:skus&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SKU_STOCK_SEMAPHORE = <span class="string">&quot;seckill:stock:&quot;</span>;    <span class="comment">//+商品随机码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadSeckillSkuLatest3Days</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、扫描最近三天的商品需要参加秒杀的活动</span></span><br><span class="line">        R lates3DaySession = couponFeignService.getLates3DaySession();</span><br><span class="line">        <span class="keyword">if</span> (lates3DaySession.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//上架商品</span></span><br><span class="line">            List&lt;SeckillSessionWithSkusVo&gt; sessionData = lates3DaySession.getData(<span class="string">&quot;data&quot;</span>, <span class="keyword">new</span> TypeReference&lt;List&lt;SeckillSessionWithSkusVo&gt;&gt;() &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//缓存到Redis</span></span><br><span class="line">            <span class="comment">//1、缓存活动信息</span></span><br><span class="line">            saveSessionInfos(sessionData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、缓存活动的关联商品信息</span></span><br><span class="line">            saveSessionSkuInfo(sessionData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存秒杀活动信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveSessionInfos</span><span class="params">(List&lt;SeckillSessionWithSkusVo&gt; sessions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sessions.stream().forEach(session -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前活动的开始和结束时间的时间戳</span></span><br><span class="line">            <span class="keyword">long</span> startTime = session.getStartTime().getTime();</span><br><span class="line">            <span class="keyword">long</span> endTime = session.getEndTime().getTime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存入到Redis中的key</span></span><br><span class="line">            String key = SESSION__CACHE_PREFIX + startTime + <span class="string">&quot;_&quot;</span> + endTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断Redis中是否有该信息，如果没有才进行添加</span></span><br><span class="line">            Boolean hasKey = redisTemplate.hasKey(key);</span><br><span class="line">            <span class="comment">//缓存活动信息</span></span><br><span class="line">            <span class="keyword">if</span> (!hasKey) &#123;</span><br><span class="line">                <span class="comment">//获取到活动中所有商品的skuId</span></span><br><span class="line">                List&lt;String&gt; skuIds = session.getRelationSkus().stream()</span><br><span class="line">                        .map(item -&gt; item.getPromotionSessionId() + <span class="string">&quot;-&quot;</span> + item.getSkuId().toString()).collect(Collectors.toList());</span><br><span class="line">                redisTemplate.opsForList().leftPushAll(key,skuIds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存秒杀活动所关联的商品信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveSessionSkuInfo</span><span class="params">(List&lt;SeckillSessionWithSkusVo&gt; sessions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sessions.stream().forEach(session -&gt; &#123;</span><br><span class="line">            <span class="comment">//准备hash操作，绑定hash</span></span><br><span class="line">            BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">            session.getRelationSkus().stream().forEach(seckillSkuVo -&gt; &#123;</span><br><span class="line">                <span class="comment">//生成随机码</span></span><br><span class="line">                String token = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                String redisKey = seckillSkuVo.getPromotionSessionId().toString() + <span class="string">&quot;-&quot;</span> + seckillSkuVo.getSkuId().toString();</span><br><span class="line">                <span class="keyword">if</span> (!operations.hasKey(redisKey)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//缓存我们商品信息</span></span><br><span class="line">                    SeckillSkuRedisTo redisTo = <span class="keyword">new</span> SeckillSkuRedisTo();</span><br><span class="line">                    Long skuId = seckillSkuVo.getSkuId();</span><br><span class="line">                    <span class="comment">//1、先查询sku的基本信息，调用远程服务</span></span><br><span class="line">                    R info = productFeignService.getSkuInfo(skuId);</span><br><span class="line">                    <span class="keyword">if</span> (info.getCode() == <span class="number">0</span>) &#123;</span><br><span class="line">                        SkuInfoVo skuInfo = info.getData(<span class="string">&quot;skuInfo&quot;</span>,<span class="keyword">new</span> TypeReference&lt;SkuInfoVo&gt;()&#123;&#125;);</span><br><span class="line">                        redisTo.setSkuInfo(skuInfo);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2、sku的秒杀信息</span></span><br><span class="line">                    BeanUtils.copyProperties(seckillSkuVo,redisTo);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//3、设置当前商品的秒杀时间信息</span></span><br><span class="line">                    redisTo.setStartTime(session.getStartTime().getTime());</span><br><span class="line">                    redisTo.setEndTime(session.getEndTime().getTime());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//4、设置商品的随机码（防止恶意攻击）</span></span><br><span class="line">                    redisTo.setRandomCode(token);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//序列化json格式存入Redis中</span></span><br><span class="line">                    String seckillValue = JSON.toJSONString(redisTo);</span><br><span class="line">                    operations.put(seckillSkuVo.getPromotionSessionId().toString() + <span class="string">&quot;-&quot;</span> + seckillSkuVo.getSkuId().toString(),seckillValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果当前这个场次的商品库存信息已经上架就不需要上架</span></span><br><span class="line">                    <span class="comment">//5、使用库存作为分布式Redisson信号量（限流）</span></span><br><span class="line">                    <span class="comment">// 使用库存作为分布式信号量</span></span><br><span class="line">                    RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);</span><br><span class="line">                    <span class="comment">// 商品可以秒杀的数量作为信号量</span></span><br><span class="line">                    semaphore.trySetPermits(seckillSkuVo.getSeckillCount());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到当前可以参加秒杀商品的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;getCurrentSeckillSkusResource&quot;,blockHandler = &quot;blockHandler&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SeckillSkuRedisTo&gt; <span class="title">getCurrentSeckillSkus</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">&quot;seckillSkus&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//1、确定当前属于哪个秒杀场次</span></span><br><span class="line">            <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从Redis中查询到所有key以seckill:sessions开头的所有数据</span></span><br><span class="line">            Set&lt;String&gt; keys = redisTemplate.keys(SESSION__CACHE_PREFIX + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="comment">//seckill:sessions:1594396764000_1594453242000</span></span><br><span class="line">                String replace = key.replace(SESSION__CACHE_PREFIX, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                String[] s = replace.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">                <span class="comment">//获取存入Redis商品的开始时间</span></span><br><span class="line">                <span class="keyword">long</span> startTime = Long.parseLong(s[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//获取存入Redis商品的结束时间</span></span><br><span class="line">                <span class="keyword">long</span> endTime = Long.parseLong(s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断是否是当前秒杀场次</span></span><br><span class="line">                <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line">                    <span class="comment">//2、获取这个秒杀场次需要的所有商品信息</span></span><br><span class="line">                    List&lt;String&gt; range = redisTemplate.opsForList().range(key, -<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">                    BoundHashOperations&lt;String, String, String&gt; hasOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">                    <span class="keyword">assert</span> range != <span class="keyword">null</span>;</span><br><span class="line">                    List&lt;String&gt; listValue = hasOps.multiGet(range);</span><br><span class="line">                    <span class="keyword">if</span> (listValue != <span class="keyword">null</span> &amp;&amp; listValue.size() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        List&lt;SeckillSkuRedisTo&gt; collect = listValue.stream().map(item -&gt; &#123;</span><br><span class="line">                            String items = (String) item;</span><br><span class="line">                            SeckillSkuRedisTo redisTo = JSON.parseObject(items, SeckillSkuRedisTo.class);</span><br><span class="line">                            <span class="comment">// redisTo.setRandomCode(null);当前秒杀开始需要随机码</span></span><br><span class="line">                            <span class="keyword">return</span> redisTo;</span><br><span class="line">                        &#125;).collect(Collectors.toList());</span><br><span class="line">                        <span class="keyword">return</span> collect;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;资源被限流&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SeckillSkuRedisTo&gt; <span class="title">blockHandler</span><span class="params">(BlockException e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;getCurrentSeckillSkusResource被限流了,&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据skuId查询商品是否参加秒杀活动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillSkuRedisTo <span class="title">getSkuSeckilInfo</span><span class="params">(Long skuId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、找到所有需要秒杀的商品的key信息---seckill:skus</span></span><br><span class="line">        BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到所有的key</span></span><br><span class="line">        Set&lt;String&gt; keys = hashOps.keys();</span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//4-45 正则表达式进行匹配</span></span><br><span class="line">            String reg = <span class="string">&quot;\\d-&quot;</span> + skuId;</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                <span class="comment">//如果匹配上了</span></span><br><span class="line">                <span class="keyword">if</span> (Pattern.matches(reg,key)) &#123;</span><br><span class="line">                    <span class="comment">//从Redis中取出数据来</span></span><br><span class="line">                    String redisValue = hashOps.get(key);</span><br><span class="line">                    <span class="comment">//进行序列化</span></span><br><span class="line">                    SeckillSkuRedisTo redisTo = JSON.parseObject(redisValue, SeckillSkuRedisTo.class);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//随机码</span></span><br><span class="line">                    Long currentTime = System.currentTimeMillis();</span><br><span class="line">                    Long startTime = redisTo.getStartTime();</span><br><span class="line">                    Long endTime = redisTo.getEndTime();</span><br><span class="line">                    <span class="comment">//如果当前时间大于等于秒杀活动开始时间并且要小于活动结束时间</span></span><br><span class="line">                    <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line">                        <span class="keyword">return</span> redisTo;</span><br><span class="line">                    &#125;</span><br><span class="line">                    redisTo.setRandomCode(<span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">return</span> redisTo;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前商品进行秒杀（秒杀开始）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> killId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">kill</span><span class="params">(String killId, String key, Integer num)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获取当前用户的信息</span></span><br><span class="line">        MemberResponseVo user = LoginUserInterceptor.loginUser.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取当前秒杀商品的详细信息从Redis中获取</span></span><br><span class="line">        BoundHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.boundHashOps(SECKILL_CHARE_PREFIX);</span><br><span class="line">        String skuInfoValue = hashOps.get(killId);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(skuInfoValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(合法性效验)</span></span><br><span class="line">        SeckillSkuRedisTo redisTo = JSON.parseObject(skuInfoValue, SeckillSkuRedisTo.class);</span><br><span class="line">        Long startTime = redisTo.getStartTime();</span><br><span class="line">        Long endTime = redisTo.getEndTime();</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//判断当前这个秒杀请求是否在活动时间区间内(效验时间的合法性)</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime &gt;= startTime &amp;&amp; currentTime &lt;= endTime) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、效验随机码和商品id</span></span><br><span class="line">            String randomCode = redisTo.getRandomCode();</span><br><span class="line">            String skuId = redisTo.getPromotionSessionId() + <span class="string">&quot;-&quot;</span> +redisTo.getSkuId();</span><br><span class="line">            <span class="keyword">if</span> (randomCode.equals(key) &amp;&amp; killId.equals(skuId)) &#123;</span><br><span class="line">                <span class="comment">//3、验证购物数量是否合理和库存量是否充足</span></span><br><span class="line">                Integer seckillLimit = redisTo.getSeckillLimit();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取信号量</span></span><br><span class="line">                String seckillCount = redisTemplate.opsForValue().get(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">                Integer count = Integer.valueOf(seckillCount);</span><br><span class="line">                <span class="comment">//判断信号量是否大于0,并且买的数量不能超过库存</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; num &lt;= seckillLimit &amp;&amp; count &gt; num ) &#123;</span><br><span class="line">                    <span class="comment">//4、验证这个人是否已经买过了（幂等性处理）,如果秒杀成功，就去占位。userId-sessionId-skuId</span></span><br><span class="line">                    <span class="comment">//SETNX 原子性处理</span></span><br><span class="line">                    String redisKey = user.getId() + <span class="string">&quot;-&quot;</span> + skuId;</span><br><span class="line">                    <span class="comment">//设置自动过期(活动结束时间-当前时间)</span></span><br><span class="line">                    Long ttl = endTime - currentTime;</span><br><span class="line">                    Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(redisKey, num.toString(), ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (aBoolean) &#123;</span><br><span class="line">                        <span class="comment">//占位成功说明从来没有买过,分布式锁(获取信号量-1)</span></span><br><span class="line">                        RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">                        <span class="comment">//TODO 秒杀成功，快速下单</span></span><br><span class="line">                        <span class="keyword">boolean</span> semaphoreCount = semaphore.tryAcquire(num, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="comment">//保证Redis中还有商品库存</span></span><br><span class="line">                        <span class="keyword">if</span> (semaphoreCount) &#123;</span><br><span class="line">                            <span class="comment">//创建订单号和订单信息发送给MQ</span></span><br><span class="line">                            <span class="comment">// 秒杀成功 快速下单 发送消息到 MQ 整个操作时间在 10ms 左右</span></span><br><span class="line">                            String timeId = IdWorker.getTimeId();</span><br><span class="line">                            SeckillOrderTo orderTo = <span class="keyword">new</span> SeckillOrderTo();</span><br><span class="line">                            orderTo.setOrderSn(timeId);</span><br><span class="line">                            orderTo.setMemberId(user.getId());</span><br><span class="line">                            orderTo.setNum(num);</span><br><span class="line">                            orderTo.setPromotionSessionId(redisTo.getPromotionSessionId());</span><br><span class="line">                            orderTo.setSkuId(redisTo.getSkuId());</span><br><span class="line">                            orderTo.setSeckillPrice(redisTo.getSeckillPrice());</span><br><span class="line">                            rabbitTemplate.convertAndSend(<span class="string">&quot;order-event-exchange&quot;</span>,<span class="string">&quot;order.seckill.order&quot;</span>,orderTo);</span><br><span class="line">                            <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">                            log.info(<span class="string">&quot;耗时...&quot;</span> + (s2 - s1));</span><br><span class="line">                            <span class="keyword">return</span> timeId;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> s3 = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">&quot;耗时...&quot;</span> + (s3 - s1));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ Service kill</span><br><span class="line">    + 登录判断 √</span><br><span class="line">    + 合法性校验</span><br><span class="line">        + 获取当前秒杀商品的详细信息</span><br><span class="line">        + redis根据killid 获取sku信息</span><br><span class="line">        + json转为To数据</span><br><span class="line">        + 判断当前时间是否为秒杀时间</span><br><span class="line">        + 比较开始结束时间</span><br><span class="line">        + 判断随机码是否正确</span><br><span class="line">        + 判断购物数量是否合适</span><br><span class="line">    + 判断是否重复秒杀（幂等性）</span><br><span class="line">    + 到redis站位，setnx</span><br><span class="line">            + 指定key：userid_sessionid_skuid</span><br><span class="line">            + 拦截器获取user信息</span><br><span class="line">            + 设置自动过期时间（当前场次结束时间）</span><br><span class="line">            + 结束时间减去当前时间作为ttl</span><br><span class="line">            + 站位成功则说明未秒杀</span><br><span class="line">    + 获取分布式信号量</span><br><span class="line">    + 根据购买件数扣减信号量</span><br><span class="line">    + 调用tryAcquire（尝试性获取，非阻塞）</span><br><span class="line">    //+ 100毫秒尝试时间</span><br><span class="line">    + 无需等待</span><br><span class="line">    + 拿到信号量则成功秒杀</span><br><span class="line">    + 快速下单</span><br><span class="line">        + 创建订单号</span><br><span class="line">        + 发送消息给mq</span><br><span class="line">            + 引入rabbitmq</span><br><span class="line">            + 序列化、可靠消息等配置</span><br><span class="line">+ 秒杀订单To</span><br><span class="line">+ 发送消息</span><br><span class="line">    + 直接返回订单号</span><br><span class="line">    + 订单服务</span><br><span class="line">+ 队列、binding</span><br><span class="line">+ 监听秒杀队列</span><br><span class="line">+ 创建秒杀单，保存订单信息</span><br><span class="line">            + 保存订单项信息（订单关联sku表）</span><br><span class="line">            + TODO 其他</span><br></pre></td></tr></table></figure><h1 id="2、Sentinel、Sleuth-Zipkin"><a href="#2、Sentinel、Sleuth-Zipkin" class="headerlink" title="2、Sentinel、Sleuth + Zipkin"></a>2、Sentinel、Sleuth + Zipkin</h1><h2 id="Sentinel：流控、熔断降级、系统负载保护"><a href="#Sentinel：流控、熔断降级、系统负载保护" class="headerlink" title="Sentinel：流控、熔断降级、系统负载保护"></a>Sentinel：流控、熔断降级、系统负载保护</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304230038114.png" alt="image-20220304230038114"><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304230504257.png" alt="image-20220304230504257"></p><p>熔断：</p><p>  A 服务调用 B 服务的某个功能，由于网络不稳定问题，或者 B 服务卡机，导致功能时 间超长。如果这样子的次数太多。我们就可以直接将 B 断路了（A 不再请求 B 接口），凡是 调用 B 的直接返回降级数据，不必等待 B 的超长执行。 这样 B 的故障问题，就不会级联影响到 A。 熔断是被调方多次故障，触发系统的主动保护规则。</p><p>降级：</p><p>  整个网站处于流量高峰期，服务器压力剧增，根据当前业务情况及流量，对一些服务和 页面进行有策略的降级[停止服务，所有的调用直接返回降级数据]。以此缓解服务器资源的 的压力，以保证核心业务的正常运行，同时也保持了客户和大部分客户的得到正确的相应。</p><p>流量控制几个角度：</p><p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系； </p><p>运行指标，例如 QPS、线程池、系统负载等； </p><p>控制的效果，例如直接限流、冷启动、排队等。</p><p>Sentinel相比Hystrix：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ Sentinel相比Hystrix：</span><br><span class="line">+ 隔离策略</span><br><span class="line">        + 线程池隔离</span><br><span class="line">            + 为请求分配自带线程池</span><br><span class="line">            + 优点</span><br><span class="line">                + 线程池之间隔离，池子炸了与其他请求无关</span><br><span class="line">        + 信号量隔离</span><br><span class="line">            + 为请求分配信号量</span><br></pre></td></tr></table></figure><p>sentinel-定义资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ 定义resource</span><br><span class="line">    + 主流框架默认适配</span><br><span class="line">    + 抛出异常方式定义资源</span><br><span class="line">    + 返回布尔值方式定义资源</span><br><span class="line">    + 注解方式定义资源（可配置回调）</span><br><span class="line">    + 异步调用支持</span><br><span class="line">+ 自定义定义资源</span><br><span class="line">+ try-catch</span><br><span class="line">+ 基于注解 </span><br><span class="line">+ 调用链路</span><br><span class="line">        + 自定义blockhandler：限流、降级、系统保护时调用</span><br><span class="line">        + fallback：处理异常</span><br></pre></td></tr></table></figure><p>sentinel-限流模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 限流模式</span><br><span class="line">    + 链路限流模式</span><br><span class="line">        + 只统计某个入口进入的流量</span><br><span class="line">    + 关联模式</span><br><span class="line">        + 其他人流量大限制自己</span><br><span class="line">    + 直接拒绝</span><br><span class="line">    + warm up</span><br><span class="line">        + 预热：指定时间内将流量慢慢增加到限流阈值</span><br><span class="line">    + 排队等待</span><br></pre></td></tr></table></figure><p>Sentinel-熔断降级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 熔断降级</span><br><span class="line">+ 限流是对请求进行流控</span><br><span class="line">    + 远程调用需要用熔断降级进行保护</span><br><span class="line">    + 调用方熔断保护</span><br><span class="line">        + 开启feign-sentinel</span><br><span class="line">        + 对调用方接口加入fallback</span><br><span class="line">        + 实现feign接口</span><br><span class="line">            + 实现fallback方法</span><br><span class="line">    + 指定降级策略</span><br><span class="line">    + 远程服务（服务提供方）降级保护</span><br><span class="line">        + 流量过大时全局考虑，将某些服务提供方降级处理</span><br></pre></td></tr></table></figure><p>Sentinel-网关流控</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231223789.png" alt="image-20220304231223789"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 网关限流功能</span><br><span class="line">+ 引入sentinel与gateway适配整合</span><br><span class="line">+ 网关页面</span><br><span class="line">        + 流控</span><br><span class="line">        + api分组（对整个组进行流控设置）</span><br><span class="line">    + 定制网关流控返回</span><br><span class="line">    + Mono Webflux</span><br><span class="line">        + 响应式编程</span><br><span class="line">        + 天然支持高并发系统</span><br></pre></td></tr></table></figure><h2 id="Sleuth-Zipkin：链路追踪"><a href="#Sleuth-Zipkin：链路追踪" class="headerlink" title="Sleuth + Zipkin：链路追踪"></a>Sleuth + Zipkin：链路追踪</h2><p><strong>为什么用</strong></p><p>  微服务架构是一个分布式架构，它按业务划分服务单元，一个分布式系统往往有很多个服务 单元。由于服务单元数量众多，业务的复杂性，如果<strong>出现了错误和异常，很难去定位</strong>。主要 体现在，<strong>一个请求可能需要调用很多个服务</strong>，而内部服务的调用复杂性，决定了问题难以 定位。所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与， 参与的顺序又是怎样的，从而<strong>达到每个请求的步骤清晰可见，出了问题，很快定位</strong>。 </p><p>链路追踪组件有 Google 的 Dapper，Twitter 的 Zipkin，以及阿里的 Eagleeye （鹰眼）等，它们都是非常优秀的链路追踪开源组件。 </p><p><strong>基本术语</strong></p><p>Span（跨度）：基本工作单元，发送一个远程调度任务 就会产生一个 Span，Span 是一 个 64 位 ID 唯一标识的，Trace 是用另一个 64 位 ID 唯一标识的，Span 还有其他数据信息，比如摘要、时间戳事件、Span 的 ID、以及进度 ID。 </p><p>Trace（跟踪）：一系列 Span 组成的一个树状结构。请求一个微服务系统的 API 接口， 这个 API 接口，需要调用多个微服务，调用每个微服务都会产生一个新的 Span，所有 由这个请求产生的 Span 组成了这个 Trace。 </p><p>Annotation（标注）：用来及时记录一个事件的，一些核心注解用来定义一个请求的开 始和结束 。这些注解包括以下：  </p><ul><li><p>cs - Client Sent -客户端发送一个请求，这个注解描述了这个 Span 的开始  </p></li><li><p>sr - Server Received -服务端获得请求并准备开始处理它，如果将其 sr 减去 cs 时间戳 便可得到网络传输的时间。 </p></li><li><p>ss - Server Sent （服务端发送响应）–该注解表明请求处理的完成(当请求返回客户 端)，如果 ss 的时间戳减去 sr 时间戳，就可以得到服务器请求的时间。  </p></li><li><p>cr - Client Received （客户端接收响应）-此时 Span 的结束，如果 cr 的时间戳减去 cs 时间戳便可以得到整个请求所消耗的时间。 </p></li></ul><p>Sleuth原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231626939.png" alt="image-20220304231626939"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 每一个服务一个span</span><br><span class="line">    + trace id</span><br><span class="line">    + span id</span><br><span class="line">    + annotation标注</span><br><span class="line">    + 用来计算时间</span><br></pre></td></tr></table></figure><p>Sleuth + Zipkin</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231702938.png" alt="image-20220304231702938"></p><p>链路追踪</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220304231828856.png" alt="image-20220304231828856"></p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——支付宝支付&amp;RSA加密&amp;内网穿透</title>
    <link href="https://fireonice.github.io/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98&amp;RSA%E5%8A%A0%E5%AF%86&amp;%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://fireonice.github.io/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98&amp;RSA%E5%8A%A0%E5%AF%86&amp;%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2022-02-28T14:59:05.494Z</published>
    <updated>2022-02-28T15:32:20.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、支付"><a href="#1、支付" class="headerlink" title="1、支付"></a>1、支付</h1><p>支付宝&amp;蚂蚁金服开发者平台：</p><p><a href="https://gitee.com/link?target=https://open.alipay.com/platform/home.htm">https://open.alipay.com/platform/home.htm</a></p><p>文档地址：</p><p>创建应用对应文档 <a href="https://gitee.com/link?target=https://openhome.alipay.com/docCenter/docCenter.htm">https://openhome.alipay.com/docCenter/docCenter.htm</a></p><p>网页移动应用文档 <a href="https://gitee.com/link?target=https://opendocs.alipay.com/open/200/105304">https://opendocs.alipay.com/open/200/105304</a></p><h2 id="支付宝支付流程"><a href="#支付宝支付流程" class="headerlink" title="支付宝支付流程"></a>支付宝支付流程</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230726942.png" alt="image-20220228230726942"></p><p>跳转的页面是根据AlipayTemplate定义的回调地址来进行跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 服务器[异步通知]页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">// 支付宝会悄悄的给我们发送一个请求，告诉我们支付成功的信息</span></span><br><span class="line">    <span class="keyword">private</span>  String notify_url = <span class="string">&quot;http://member.gulimall.com/memberOrder.html&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问</span></span><br><span class="line">    <span class="comment">//同步通知，支付成功，一般跳转到成功页</span></span><br><span class="line">    <span class="keyword">private</span>  String return_url = <span class="string">&quot;http://member.gulimall.com/memberOrder.html&quot;</span>;</span><br></pre></td></tr></table></figure><p>支付成功后异步回调接口处理，需要有服务器或配置了内网穿透才能接收到该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付宝异步通知回调接口,需要拥有内网穿透或服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/payed/notify&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleAlipayed</span><span class="params">(PayAsyncVo vo, HttpServletRequest request)</span> <span class="keyword">throws</span> UnsupportedEncodingException, AlipayApiException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重要一步验签名</span></span><br><span class="line"><span class="comment">         *  防止别人通过postman给我们发送一个请求，告诉我们请求成功，为了防止这种效果通过验签</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        Map&lt;String,String[]&gt; requestParams = request.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; iter = requestParams.keySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            String name = (String) iter.next();</span><br><span class="line">            String[] values = (String[]) requestParams.get(name);</span><br><span class="line">            String valueStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                valueStr = (i == values.length - <span class="number">1</span>) ? valueStr + values[i]</span><br><span class="line">                        : valueStr + values[i] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//乱码解决，这段代码在出现乱码时使用</span></span><br><span class="line">            valueStr = <span class="keyword">new</span> String(valueStr.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            params.put(name, valueStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 支付宝验签 防止恶意提交</span></span><br><span class="line">        <span class="keyword">boolean</span> signVerified = AlipaySignature.rsaCheckV1(params</span><br><span class="line">                , alipayTemplate.getAlipay_public_key()</span><br><span class="line">                , alipayTemplate.getCharset()</span><br><span class="line">                , alipayTemplate.getSign_type());</span><br><span class="line">        <span class="keyword">if</span> (signVerified) &#123;</span><br><span class="line">            String result = orderService.handleAlipayed(vo);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收单问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228233211250.png" alt="image-20220228233211250"></p><h2 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ 支付跳转</span><br><span class="line">    + controller</span><br><span class="line">        + 根据订单号查询封装订单Vo</span><br><span class="line">        + 调用支付方法</span><br><span class="line">+ 响应返回一个页面（支付宝收银台）</span><br><span class="line">+ 直接交给浏览器即可</span><br><span class="line">+ 跳转到会员订单列表页</span><br><span class="line">    + 支付成功跳转controller</span><br><span class="line">    + 会员服务feign远程调用订单服务</span><br><span class="line">            + 查询用户订单详情controller</span><br><span class="line">                + 根据id查询订单</span><br><span class="line">                + 遍历订单</span><br><span class="line">                    + 根据订单id查询订单项</span><br><span class="line">                    + 封装订单项详情</span><br><span class="line">    + 配置feign cookie同步拦截器（请求带上cookie）</span><br><span class="line">+ 异步通知（支付宝推荐）</span><br><span class="line">+ 不断通知，直到商户返回收到（最大努力通知型方案）</span><br><span class="line">+ 保证外网能够访问到</span><br><span class="line">            + 内网穿透</span><br><span class="line">            + server_name 加上外网的地址，保证可以进行server的跳转</span><br><span class="line">+ 异步通知获取参数接口</span><br><span class="line">+ 抽取异步参数的Vo</span><br><span class="line">+ 修改状态之前，需要验签（是否支付宝的数据）</span><br><span class="line">+ 验签代码，从demo中复制</span><br><span class="line">+ 支付成功处理（修改状态）</span><br><span class="line">+ 保存交易流水</span><br><span class="line">+ 数据库保证订单号、交易号等唯一</span><br><span class="line">+ 修改订单状态</span><br><span class="line">+ 查询订单，改为已支付</span><br><span class="line">+ 收单</span><br><span class="line">+ 问题</span><br><span class="line">        + 在支付页面过久，关单后才支付</span><br><span class="line">        + 库存关单后解锁，订单支付后变为已支付</span><br><span class="line">+ 支付宝自动收单功能（自动关闭收银台）</span><br><span class="line">    + 解锁库存完，支付完的异步通知才到</span><br><span class="line">    + 订单解锁，手动收单</span><br></pre></td></tr></table></figure><h1 id="2、RSA、加密加签、密钥"><a href="#2、RSA、加密加签、密钥" class="headerlink" title="2、RSA、加密加签、密钥"></a>2、RSA、加密加签、密钥</h1><p>对称加密：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230515319.png" alt="image-20220228230515319"></p><p>对称加密</p><ul><li>加密解密用同一把钥匙</li><li>一把钥匙不安全</li></ul><p>非对称加密 ：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228230534327.png" alt="image-20220228230534327"></p><p>非对称加密</p><ul><li>加密解密使用不同钥匙</li></ul><p>公钥私钥：</p><p>公钥和私钥是一个相对概念，它们的公私性是相对于生成者来说的。 </p><p>一对密钥生成后，保存在生成者手里的就是私钥， 生成者发布出去大家用的就是公钥</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228231813227.png" alt="image-20220228231813227"></p><h1 id="3、内网穿透"><a href="#3、内网穿透" class="headerlink" title="3、内网穿透"></a>3、内网穿透</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228231656684.png" alt="image-20220228231656684"></p><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>内网穿透功能可以允许我们使用外网的网址来访问主机 正常的外网需要访问我们项目的流程是:</p><p>1、买服务器并且有公网固定IP</p><p>2、买域名映射到服务器的IP</p><p>3、域名需要进行备案和审核</p><h2 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h2><p>1、开发测试(微信、支付宝)</p><p>2、智慧互联</p><p>3、远程控制</p><p>4、私有云</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 优点</span><br><span class="line">+ 免服务器部署，直接在本地启动项目指定端口进行内网穿透即可</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——柔性事务-可靠消息+最终一致性解决方案（异步确保型）</title>
    <link href="https://fireonice.github.io/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF+%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://fireonice.github.io/2022/02/28/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF+%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2022-02-28T05:57:31.284Z</published>
    <updated>2022-03-04T15:32:16.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="柔性事务-可靠消息-最终一致性解决方案（异步确保型）"><a href="#柔性事务-可靠消息-最终一致性解决方案（异步确保型）" class="headerlink" title="柔性事务-可靠消息+最终一致性解决方案（异步确保型）"></a>柔性事务-可靠消息+最终一致性解决方案（异步确保型）</h1><h2 id="RabbitMQ延时队列（实现定时任务）"><a href="#RabbitMQ延时队列（实现定时任务）" class="headerlink" title="RabbitMQ延时队列（实现定时任务）"></a>RabbitMQ延时队列（实现定时任务）</h2><p>场景： </p><p>比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 常用解决方案 </span><br><span class="line">+ spring的 schedule 定时任务轮询数据库 </span><br><span class="line">+ 缺点 </span><br><span class="line">+ 消耗系统内存、增加了数据库的压力、存在较大的时间误差 </span><br><span class="line">+ 解决</span><br><span class="line">+ rabbitmq的消息TTL和死信Exchange结合</span><br></pre></td></tr></table></figure><p>TTL存活时间</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102109187.png" alt="image-20220228102109187"></p><p>DLX死信交换机（Dead Letter Exchanges）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102131676.png" alt="image-20220228102131676"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102251153.png" alt="image-20220228102251153"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 模拟延迟场景</span><br><span class="line">    + 消息设置30m过期（队列不被监听）</span><br><span class="line">    + 30m后进入死信交换机</span><br><span class="line">    + 消息进入另一个队列（被监听）</span><br></pre></td></tr></table></figure><h3 id="延时队列实现"><a href="#延时队列实现" class="headerlink" title="延时队列实现"></a>延时队列实现</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228102330181.png" alt="image-20220228102330181"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 给队列设置消息过期时间(推荐)</span><br><span class="line">+ 给消息设置消息过期时间</span><br><span class="line">+ rabbitmq懒检查</span><br><span class="line">    + 只会检查第一个消息是否过期</span><br><span class="line">    + 若后面消息ttl小，仍无法出队列</span><br><span class="line">    + 所以给队列设置过期时间</span><br></pre></td></tr></table></figure><h2 id="基于MQ可靠消息的一致性解决"><a href="#基于MQ可靠消息的一致性解决" class="headerlink" title="基于MQ可靠消息的一致性解决"></a>基于MQ可靠消息的一致性解决</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B5%81%E7%A8%8B.jpg" alt="消息队列流程"></p><p>监听库存解锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 解锁场景</span><br><span class="line">+ 未支付场景、手动取消订单</span><br><span class="line">+ 锁定成功，其他业务失败，订单回滚，自动解锁库存、</span><br><span class="line">+ 解锁之前，保存工作单（追溯）</span><br><span class="line">+ 库存锁成功时</span><br><span class="line">    + 保存工作单详情</span><br><span class="line">    + 给MQ发送消息到延时队列（消息包含工作单详情）</span><br></pre></td></tr></table></figure><p>库存解锁逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 监听解锁队列（延时过期队列）</span><br><span class="line">+ 根据消息查找库存工作单</span><br><span class="line">+ 没有：失败正常回滚</span><br><span class="line">    + 有：库存锁定成功，远程调用查询订单</span><br><span class="line">        + 没有订单：必须解锁</span><br><span class="line">        + 有订单，查看订单状态</span><br><span class="line">            + 已取消：解锁库存</span><br><span class="line">            + 没取消：不解锁</span><br><span class="line">    + ack</span><br><span class="line">+ 库存解锁，更新工作单状态</span><br></pre></td></tr></table></figure><p>定时关单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 监听器——关闭订单</span><br><span class="line">    + 执行成功则ack</span><br><span class="line">    + 不成功拒绝消息，重回队列</span><br><span class="line">+ 订单创建成功后，发送消息（订单）到MQ延时队列</span><br><span class="line">    + 消息过期到达监听器</span><br><span class="line">        + 查询订单的最新状态（可能已支付）</span><br><span class="line">        + 仍在代付款状态，则关单</span><br><span class="line">            + 更新订单状态为已取消</span><br></pre></td></tr></table></figure><p>问题：</p><p>1、订单消息卡顿，导致关单比库存解锁慢</p><p>2、库存解锁判断订单</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228103933963.png" alt="image-20220228103933963"></p><p>解决：关单后发送消息解锁库存（主动解锁库存补偿）</p><p>关单解锁库存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ 查询库存工作单状态，防止重复解锁库存</span><br><span class="line">+ 按照工作单找到所有未解锁的库存（状态为1）进行解锁</span><br></pre></td></tr></table></figure><p>库存解锁总结：两种消息监听（库存解锁延迟消息、order主动关闭消息）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 主动补偿：关单解锁</span><br><span class="line">+ 被动补偿：自动解锁</span><br><span class="line">+ 若判断解锁过则放过消息</span><br><span class="line">+ 解决高并发</span><br><span class="line">+ 解决系统异构</span><br></pre></td></tr></table></figure><h2 id="消息丢失、积压、重复等解决方案"><a href="#消息丢失、积压、重复等解决方案" class="headerlink" title="消息丢失、积压、重复等解决方案"></a>消息丢失、积压、重复等解决方案</h2><h3 id="消息丢失：ack，防重表"><a href="#消息丢失：ack，防重表" class="headerlink" title="消息丢失：ack，防重表"></a>消息丢失：ack，防重表</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104351405.png" alt="image-20220228104351405"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104549154.png" alt="image-20220228104549154"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 消息丢失</span><br><span class="line">+ 网络问题，发送失败</span><br><span class="line">+ 加上try-catch</span><br><span class="line">    + 日志记录</span><br><span class="line">            + 数据库保存发送的消息详细信息，记录消息状态</span><br><span class="line">            + 定期扫描数据库，发送失败消息</span><br><span class="line">    + 消息抵达broker，尚未持久化完成（未抵达队列），宕机</span><br><span class="line">    + 发送端加入消息确认回调机制（e-&gt;q）</span><br><span class="line">    + 自动ack，消费者没来得及消费，宕机</span><br><span class="line">    + 开启手动ack模式，消费成功才移除消息</span><br><span class="line">    + 总结</span><br><span class="line">    + 做好消息确认机制（ pulisher，consumer 手动ack）</span><br><span class="line">+ 每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `mq_message` (</span><br><span class="line">`message_id` <span class="type">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`content` text,</span><br><span class="line">`to_exchane` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`routing_key` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`class_type` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`message_status` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0-新建 1-已发送 2-错误抵达 3-已抵达&#x27;</span>,</span><br><span class="line">`create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`message_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br></pre></td></tr></table></figure><h3 id="消息重复：幂等性"><a href="#消息重复：幂等性" class="headerlink" title="消息重复：幂等性"></a>消息重复：幂等性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 消息重复</span><br><span class="line">    + 消息消费成功，ack前宕机，再次被消费</span><br><span class="line">    + 消费失败，重试机制</span><br><span class="line">    + ack宕机，unack变为ready，broker重新发送消息，同1</span><br><span class="line">    + 解决</span><br><span class="line">        + 业务逻辑解锁库存方法设为幂等性：判断库存工单状态，已解锁则无需解锁</span><br><span class="line">        + 保证幂等：使用防重表，处理后保存唯一标识id，免再次处理</span><br><span class="line">        + 消息的redelivered属性，判断是否为重新投递</span><br><span class="line">            + 无法判断上次是否处理成功</span><br></pre></td></tr></table></figure><h3 id="消息积压："><a href="#消息积压：" class="headerlink" title="消息积压："></a>消息积压：</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228104743095.png" alt="image-20220228104743095"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 消息积压</span><br><span class="line">    + 消费者宕机</span><br><span class="line">    + 消费能力不足</span><br><span class="line">    + 发送流量太大</span><br><span class="line">        + 限制业务流量</span><br><span class="line">        + 上线更多消费者</span><br><span class="line">        + 批量取出消息保存到数据库中，离线业务慢慢处理</span><br></pre></td></tr></table></figure><p>1、分离消息微服务，考虑消息可靠性</p><p>2、调用微服务去发送消息</p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——幂等性&amp;分布式事务&amp;Raft原理</title>
    <link href="https://fireonice.github.io/2022/02/27/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%B9%82%E7%AD%89%E6%80%A7&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1&amp;%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF&amp;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://fireonice.github.io/2022/02/27/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%B9%82%E7%AD%89%E6%80%A7&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1&amp;%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF&amp;%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-02-27T15:25:07.604Z</published>
    <updated>2022-03-04T15:32:13.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、订单链路"><a href="#1、订单链路" class="headerlink" title="1、订单链路"></a>1、订单链路</h1><h2 id="订单中心"><a href="#订单中心" class="headerlink" title="订单中心"></a>订单中心</h2><p>电商系统涉及到 3 流，分别时信息流，资金流，物流，而订单系统作为中枢将三者有机的集合起来。 </p><p>订单模块是电商系统的枢纽，在订单这个环节上需求获取多个模块的数据和信息，同时对这些信息进行加工处理后流向下个环节，这一系列就构成了订单的信息流通。 </p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228080432263.png" alt="image-20220228080432263"></p><h2 id="订单流程"><a href="#订单流程" class="headerlink" title="订单流程"></a>订单流程</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228081824936.png" alt="image-20220228081824936"></p><h2 id="Feign远程异步调用丢失请求头、上下文问题"><a href="#Feign远程异步调用丢失请求头、上下文问题" class="headerlink" title="Feign远程异步调用丢失请求头、上下文问题"></a>Feign远程异步调用丢失请求头、上下文问题</h2><p>Feign远程调用丢失请求头问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228091104146.png" alt="image-20220228091104146"></p><p>feign异步情况丢失上下文问题</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228091118962.png" alt="image-20220228091118962"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ Feign远程调用丢失请求头问题</span><br><span class="line">    + 原因</span><br><span class="line">    + fegin调用没带session</span><br><span class="line">        + 创建一个新request，没有请求头</span><br><span class="line">    + 解决（同步老请求cookie）</span><br><span class="line">        + 加个feign请求调用的拦截器</span><br><span class="line">        + ThreadLocal获取老请求请求属性——cookie</span><br><span class="line">        + 设置新请求cookie</span><br><span class="line">+ feign异步情况丢失上下文问题</span><br><span class="line">+ 原因</span><br><span class="line">+ requecontexHolder底层是同一线程共享数据</span><br><span class="line">+ 通过ThreadLocal获取老请求，异步编排非同一线程</span><br><span class="line">+ 解决</span><br><span class="line">+ 执行异步前，提前共享请求数据</span><br></pre></td></tr></table></figure><p>也可以传传用户id，传用户会话，后者安全些，</p><p>1、id传参</p><p>2、传递cookie</p><h1 id="2、接口幂等性"><a href="#2、接口幂等性" class="headerlink" title="2、接口幂等性"></a>2、接口幂等性</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E8%AE%A2%E5%8D%95%E7%A1%AE%E8%AE%A4%E9%A1%B5%E6%B5%81%E7%A8%8B.png" alt="订单确认页流程"></p><p>保证幂等情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 用户多次点击按钮</span><br><span class="line">+ 用户页面回退再次提交</span><br><span class="line">+ 微服务互相调用，由于网络问题，导致请求失败。feign 触发重试机制</span><br><span class="line">+ 其他业务情况</span><br></pre></td></tr></table></figure><p>幂等解决方案：</p><h2 id="1、token机制"><a href="#1、token机制" class="headerlink" title="1、token机制"></a>1、token机制</h2><p>1、服务端提供了发送 token 的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取 token，服务器会把 token 保存到 redis 中。<br>2、然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。<br>3、服务器判断 token 是否存在 redis 中，存在表示第一次请求，然后删除 token,继续执行业务。<br>4、如果判断 token 不存在 redis 中，就表示是重复操作，直接返回重复标记给 client，这样就保证了业务代码，不被重复执行。</p><p>危险性(非原子操作)：<br>1、先删除 token 还是后删除 token；<br>    (1) 先删除可能导致，业务确实没有执行，重试还带上之前 token，由于防重设计导致， 请求还是不能执行。<br>    (2) 后删除可能导致，业务处理成功，但是服务闪断，出现超时，没有删除 token，别 人继续重试，导致业务被执行两边<br>    (3) 我们最好设计为先删除 token，如果业务调用失败，就重新获取 token 再次请求。<br>2、Token 获取、比较和删除必须是原子性<br>    (1) redis.get(token) 、token.equals、redis.del(token)如果这两个操作不是原子，可能导 致，高并发下，都 get 到同样的数据，判断都成功，继续业务并发执行<br>    (2) 可以在 redis 使用 lua 脚本完成这个操作 if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">必须原子性：lua脚本</span><br><span class="line">1、获取令牌</span><br><span class="line">2、对比token</span><br><span class="line">3、删除令牌</span><br></pre></td></tr></table></figure><h2 id="2、各种锁机制"><a href="#2、各种锁机制" class="headerlink" title="2、各种锁机制"></a>2、各种锁机制</h2><p>数据库悲观锁</p><p>select * from xxxx where id = 1 for update; 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。 另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。</p><p>数据库乐观锁</p><p>这种方法适合在更新的场景中， update t_goods set count = count -1 , version = version + 1 where good_id=2 and version = 1 根据 version 版本，也就是在操作库存前先获取当前商品的 version 版本号，然后操作的时候 带上此 version 号。我们梳理下，我们第一次操作库存时，得到 version 为 1，调用库存服务 version 变成了 2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订 单服务传如的 version 还是 1，再执行上面的 sql 语句时，就不会执行；因为 version 已经变 为 2 了，where 条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。乐观锁主要使用于处理读多写少的问题</p><p>业务层分布式锁</p><p>如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数 据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</p><h2 id="3、各种唯一约束"><a href="#3、各种唯一约束" class="headerlink" title="3、各种唯一约束"></a>3、各种唯一约束</h2><p>数据库唯一约束</p><p>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。 这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键 的要求不是自增的主键，这样就需要业务生成全局唯一的主键。 如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p><p>redis set防重</p><p>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的 set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理。</p><h2 id="4、防重表"><a href="#4、防重表" class="headerlink" title="4、防重表"></a>4、防重表</h2><p>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且 他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。 </p><p>redis 防重也算</p><h2 id="5、全局请求唯一id"><a href="#5、全局请求唯一id" class="headerlink" title="5、全局请求唯一id"></a>5、全局请求唯一id</h2><p>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。 </p><p>可以使用 nginx 设置每一个请求的唯一 id；</p><p>proxy_set_header X-Request-Id $request_id;</p><p>总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ token令牌</span><br><span class="line">+ 原子性获取、对比、删除token</span><br><span class="line">+ 锁</span><br><span class="line">+ 数据库乐观锁、悲观锁</span><br><span class="line">+ 分布式锁</span><br><span class="line">+ 唯一约束</span><br><span class="line">+ 数据库主键唯一约束</span><br><span class="line">+ MD5加密redis set</span><br><span class="line">+ 防重表</span><br><span class="line">+ 操作之后以唯一索引放入去重表中，且与业务表同一数据库保证同一事务</span><br><span class="line">+ 全局请求唯一id</span><br><span class="line">+ 调用接口生成唯一id，放到redis中去重</span><br><span class="line">+ 链路追踪</span><br></pre></td></tr></table></figure><h1 id="3、分布式事务"><a href="#3、分布式事务" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h1><h2 id="1、本地事务"><a href="#1、本地事务" class="headerlink" title="1、本地事务"></a>1、本地事务</h2><h3 id="事务的基本性质"><a href="#事务的基本性质" class="headerlink" title="事务的基本性质"></a>事务的基本性质</h3><p>数据库事务的几个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称就是 ACID。</p><ul><li><p>原子性：一系列的操作整体不可拆分，要么同时成功，要么同时失败；</p></li><li><p>一致性：数据在事务的前后，业务整体一致；</p></li><li><p>隔离性：事务之间互相隔离；</p></li><li><p>持久性：一旦事务成功，数据一定会落盘在数据库。</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li><p>READ UNCOMMITTED（读未提交）：该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为脏读。</p></li><li><p>READ COMMITTED（读提交）：一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。</p></li><li><p>REPEATABLE READ（可重复读）：该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL的 InnoDB 引擎可以通过 next-key locks 机制（参考下文”行锁的算法”一节）来避免幻读。</p></li><li><p>SERIALIZABLE（序列化）：在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</p></li></ul><h3 id="事务的传播级别"><a href="#事务的传播级别" class="headerlink" title="事务的传播级别"></a>事务的传播级别</h3><ol><li><p>PROPAGATION_REQUIRED： ：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p></li><li><p>PROPAGATION_SUPPORTS： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p></li><li><p>PROPAGATION_MANDATORY： ：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p></li><li><p>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p></li><li><p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p>PROPAGATION_NEVER： 以非事务方式执行，如果当前存在事务，则抛出异常。</p></li><li><p>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</p></li></ol><p>问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 远程调用超时——假异常</span><br><span class="line">    + 抛出异常导致全部回滚</span><br><span class="line">+ 扣减积分异常</span><br><span class="line">    + 扣减积分可以回滚</span><br><span class="line">    + 本地的订单可以回滚</span><br><span class="line">    + 远程锁库存无法回滚</span><br><span class="line">        + 事务无法控制远程服务</span><br><span class="line">        + 还需手动释放库存</span><br></pre></td></tr></table></figure><h2 id="2、SpringBoot事务"><a href="#2、SpringBoot事务" class="headerlink" title="2、SpringBoot事务"></a>2、SpringBoot事务</h2><p>@Transactional</p><p>内部事务互调问题：</p><p>在同一个类里面，编写两个方法，内部调用的时候，会导致事务设置失效。</p><p>原因：同一对象内事务互调默认失效，绕过了代理对象。</p><p>解决：</p><ol><li><p>导入 spring-boot-starter-aop</p></li><li><p>@EnableTransactionManagement(proxyTargetClass = true)</p></li><li><p>@EnableAspectJAutoProxy(exposeProxy=true)</p></li><li><p>AopContext.currentProxy() 调用方法</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 本地事务互调解决</span><br><span class="line">    + 使用代理对象调用事务方法</span><br><span class="line">        + 引入aop的aspectj</span><br><span class="line">        + 开启aspectj动态代理功能</span><br><span class="line">        + spring中bean可以代替 aspectj</span><br></pre></td></tr></table></figure><h2 id="3、分布式事务-1"><a href="#3、分布式事务-1" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228092926460.png" alt="image-20220228092926460"></p><p>1、远程服务假失败</p><p>2、远程事务回滚</p><h3 id="分布式CAP定理"><a href="#分布式CAP定理" class="headerlink" title="分布式CAP定理"></a>分布式CAP定理</h3><p>分布式系统经常出现的异常机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的 TCP、存储数据丢失…</p><p>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094112202.png" alt="image-20220228094112202"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ CAP定理</span><br><span class="line">+ 一致、可用二选一，分区容错性无法避免</span><br></pre></td></tr></table></figure><h3 id="Raft原理"><a href="#Raft原理" class="headerlink" title="Raft原理"></a>Raft原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094509282.png" alt="image-20220228094509282"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ 分布式系统实现一致性的Raft算法、paxos等</span><br><span class="line">    + leader选举</span><br><span class="line">        + 随从自旋时间（随机），等待命令</span><br><span class="line">        + 自旋结束的随从变成候选人，开启一轮新的选举</span><br><span class="line">        + 随从若当前未投票可发送投票</span><br><span class="line">        + 随从投过票后重新自旋</span><br><span class="line">        + leader发送追加日志信息给随从</span><br><span class="line">            + 消息发送以间隔（心跳时间）发送</span><br><span class="line">            + 随从收到消息后重置自旋时间</span><br><span class="line">        + leader宕机</span><br><span class="line">            + 随从自旋时间结束，变为候选者</span><br><span class="line">            + 开启选举，成为leader</span><br><span class="line">        + 如果出现两个候选者，出现投票分离</span><br><span class="line">            + 谁的投票请求先到投谁，其他的拒收</span><br><span class="line">            + 票数一样</span><br><span class="line">            + 重写来一轮自旋，候选者选举</span><br><span class="line">            + 直到候选者票数最多选出leader</span><br><span class="line">    + 日志复制</span><br><span class="line">    + leader将所有改变复制给其他node</span><br><span class="line">            + 使用追加日志方式复制（在每一个心跳时发送）</span><br><span class="line">            + 随从收到同步后回复消息</span><br><span class="line">            + leader收到大多数回复后提交，并响应客户端</span><br><span class="line">            + 在下一个心跳时间，请求其他node提交</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094701842.png" alt="image-20220228094701842"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228094710919.png" alt="image-20220228094710919"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ 出现分区错误</span><br><span class="line">    + 分区之后</span><br><span class="line">        + 接收不到消息，选举领导</span><br><span class="line">        + 大多数同意才能进行改变</span><br><span class="line">    + 恢复网络分区</span><br><span class="line">        + 低轮次leader退位</span><br><span class="line">        + 处于低轮次的node未提交日志全部回滚</span><br><span class="line">        + 匹配新leader日志</span><br><span class="line">        + 全部node一致</span><br></pre></td></tr></table></figure><p>Raft算法官网：<a href="https://raft.github.io/">https://raft.github.io/</a></p><h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>是对 CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可以采用适当的采取弱一致性，即<strong>最终一致性</strong>。 </p><p>BASE 是指</p><ul><li><p>基本可用（Basically Available）</p></li><li><ul><li>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。</li></ul></li><li><ul><li><ul><li>响应时间上的损失：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。</li><li>功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li></ul></li><li><p>软状态（ Soft State）</p></li><li><ul><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。</li></ul></li><li><p>最终一致性（ Eventual Consistency）</p></li><li><ul><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ base</span><br><span class="line">    + 基本可用</span><br><span class="line">        + 允许损失部分可用性</span><br><span class="line">    + 软状态</span><br><span class="line">        + 允许系统存在中间状态</span><br><span class="line">    + 最终一致性</span><br><span class="line">        + 经历一定时间后，最终能达到一致性状态</span><br></pre></td></tr></table></figure><h3 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h3><p>​    从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是 <strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是 <strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是 <strong>最终一致性。</strong></p><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><h4 id="2PC模式"><a href="#2PC模式" class="headerlink" title="2PC模式"></a>2PC模式</h4><p>数据库支持的 2PC【2 phase commit 二阶提交】，又叫做 XA Transactions。</p><p>MySQL 从 5.5 版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：</p><p>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</p><p>第二阶段：事务协调器要求每个数据库提交数据。</p><p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228100342688.png" alt="image-20220228100342688"></p><ul><li><p>XA 协议比较简单，而且一旦商业数据库实现了 XA 协议，使用分布式事务的成本也比较低。</p></li><li><p>XA  性能不理想，特别是在交易下单链路，往往并发量很高，XA 无法满足高并发场景</p></li><li><p>XA 目前在商业数据库支持的比较理想，在 在 mysql  数据库中支持的不太理想，mysql 的XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</p></li><li><p>许多 nosql 也没有支持 XA，这让 XA 的应用场景变得非常狭隘。</p></li><li><p>也有 3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 2PC模式（XA）：二阶段提交</span><br><span class="line">    + 使用场景小</span><br><span class="line">    + 高并发性能差</span><br></pre></td></tr></table></figure><h4 id="柔性事务-TCC"><a href="#柔性事务-TCC" class="headerlink" title="柔性事务-TCC"></a>柔性事务-TCC</h4><p>刚性事务：遵循 ACID 原则，强一致性。</p><p>柔性事务：遵循 BASE 理论，最终一致性；</p><p>与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/1629027928516-e4e2272b-2df1-48ec-ac90-dee09d1c96ab.png" alt="image.png"></p><p>一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。</p><p>二阶段 commit 行为：调用 自定义 的 commit 逻辑。</p><p>二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。</p><p>所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228100848491.png" alt="image-20220228100848491"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 柔性事务-TCC事务补偿型方案</span><br><span class="line">    + 一阶段prepare——try</span><br><span class="line">    + 二阶段commit——confirm</span><br><span class="line">    + 二阶段rollback——cancel</span><br></pre></td></tr></table></figure><h4 id="柔性事务-最大努力通知型方案（结合MQ）"><a href="#柔性事务-最大努力通知型方案（结合MQ）" class="headerlink" title="柔性事务-最大努力通知型方案（结合MQ）"></a>柔性事务-最大努力通知型方案（结合MQ）</h4><p>按规律进行通知， <strong>不保证数据一定能通知成功，但会提供可查询操作接口进行核对</strong>。这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。</p><p>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调。</p><h4 id="柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="柔性事务-可靠消息 + 最终一致性方案（异步确保型）"></a>柔性事务-可靠消息 + 最终一致性方案（异步确保型）</h4><p>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</p><p>防止消息丢失：</p><ol><li>做好消息确认机制（ pulisher ， consumer 【手动 ack 】）</li><li>每一个发送的消息都在数据库做好记录。定期将失败的消息再次发送一遍.</li></ol><h3 id="Seata分布式事务"><a href="#Seata分布式事务" class="headerlink" title="Seata分布式事务"></a>Seata分布式事务</h3><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/145942191-7a2d469f-94c8-4cd2-8c7e-46ad75683636.png" alt="image"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 创建UNDO_LOG表（每一个数据库）（AT模式：自动模式）</span><br><span class="line">    + 回滚表</span><br><span class="line">    + 自动补偿</span><br><span class="line">+ 安装事务协调器：seata-server</span><br><span class="line">+ 使用seata DataSourceProxy代理自己的数据源</span><br><span class="line">+ 全局事务注解</span><br><span class="line">    + GlobalTransactional</span><br></pre></td></tr></table></figure><p>问题：AT模式吞吐量低，不支持高并发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ seata默认AT模式</span><br><span class="line">    + 不用做高并发场景</span><br><span class="line">    + 后台简单场景，不要求高并发</span><br><span class="line">    + 包含各种锁机制</span><br></pre></td></tr></table></figure><p>高并发场景：考虑基于消息服务的柔性事务方案</p><p>1、锁库存成功数据库保存锁库存工作单</p><p>2、引入延迟队列——完成库存自动解锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220228101557537.png" alt="image-20220228101557537"></p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——session共享&amp;sso&amp;ThreadLocal</title>
    <link href="https://fireonice.github.io/2022/02/17/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-session%E5%85%B1%E4%BA%AB&amp;sso&amp;ThreadLocal/"/>
    <id>https://fireonice.github.io/2022/02/17/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-session%E5%85%B1%E4%BA%AB&amp;sso&amp;ThreadLocal/</id>
    <published>2022-02-17T15:58:23.470Z</published>
    <updated>2022-02-17T16:52:39.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、MD5-amp-盐值-amp-BCrypt"><a href="#1、MD5-amp-盐值-amp-BCrypt" class="headerlink" title="1、MD5&amp;盐值&amp;BCrypt"></a>1、MD5&amp;盐值&amp;BCrypt</h1><p>MD5 （Message Digest algorithm 5，信息摘要算法） </p><p>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。 </p><p>2、容易计算：从原数据计算出MD5值很容易。 </p><p>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 </p><p>4、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 </p><p>5、不可逆 </p><p>加盐： </p><p>1、通过生成随机数与MD5生成字符串进行组合 </p><p>2、数据库同时存储MD5值与salt值。验证正确性时使用salt进行MD5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ Spring的加密</span><br><span class="line">+ 自动加盐</span><br><span class="line">+ match匹配（与encode匹配）</span><br></pre></td></tr></table></figure><h1 id="2、分布式session共享"><a href="#2、分布式session共享" class="headerlink" title="2、分布式session共享"></a>2、分布式session共享</h1><p>问题：</p><p>不同服务session不共享</p><p>同一服务session不同步</p><h2 id="session原理"><a href="#session原理" class="headerlink" title="session原理"></a>session原理</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218001900202.png" alt="image-20220218001900202"></p><h2 id="分布式session解决方案"><a href="#分布式session解决方案" class="headerlink" title="分布式session解决方案"></a>分布式session解决方案</h2><h3 id="1、session复制"><a href="#1、session复制" class="headerlink" title="1、session复制"></a>1、session复制</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002213539.png" alt="image-20220218002213539"></p><p>Session复制（tomcat之间同步）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + web-server（Tomcat）原生支持，只需要修改配置文件 </span><br><span class="line">+ 缺点：</span><br><span class="line">+ session同步需要数据传输，占用大量网络带宽，降低了服务器群的业务处理能力 </span><br><span class="line">    + 任意一台web-server保存的数据都是所有web-server的session总和，受到内存限制无法水平扩展更多的web-server </span><br><span class="line">    + 大型分布式集群情况下，由于所有web-server都全量保存数据，所以此方案不可取。</span><br></pre></td></tr></table></figure><h3 id="2、客户端存储"><a href="#2、客户端存储" class="headerlink" title="2、客户端存储"></a>2、客户端存储</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002226115.png" alt="image-20220218002226115"></p><p>放到cookie中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 优点</span><br><span class="line">+ 服务器不需存储session，用户保存自己的session信息到cookie中。</span><br><span class="line">+ 节省服务端资源</span><br><span class="line">+ 缺点</span><br><span class="line">    + 都是缺点，这只是一种思路。</span><br><span class="line">    + 每次http请求，携带用户在cookie中的完整信息，浪费网络带宽</span><br><span class="line">    + session数据放在cookie中，cookie有长度限制4K，不能保存大量信息</span><br><span class="line">    + session数据放在cookie中，存在泄漏、篡改、窃取等安全隐患</span><br></pre></td></tr></table></figure><h3 id="3、hash一致性"><a href="#3、hash一致性" class="headerlink" title="3、hash一致性"></a>3、hash一致性</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002507539.png" alt="image-20220218002507539"></p><p>Hash一致性（修改负载均衡）</p><p>+ 服务器闪断会丢失</p><p>+ 服务器数量变化重新hash，部分会丢失</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + 只需要改nginx配置，不需要修改应用代码 负载均衡，只要hash属性的值分布是均匀的，多台web-server的负载是均衡的 </span><br><span class="line">    + 可以支持web-server水平扩展（session同步法是不行的，受内存限制） </span><br><span class="line">缺点</span><br><span class="line">    + session还是存在web-server中的，所以web-server重 </span><br><span class="line">    启可能导致部分session丢失，影响业务，如部分用户 </span><br><span class="line">    需要重新登录 </span><br><span class="line">    + 如果web-server水平扩展，rehash后session重新分布， </span><br><span class="line">    也会有一部分用户路由不到正确的session </span><br><span class="line">+ 但是以上缺点问题也不是很大，因为session本来都是有有 </span><br></pre></td></tr></table></figure><h3 id="4、统一存储"><a href="#4、统一存储" class="headerlink" title="4、统一存储"></a>4、统一存储</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218002612719.png" alt="image-20220218002612719"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 优点：</span><br><span class="line">    + 没有安全隐患</span><br><span class="line">    + 可以水平扩展，数据库/缓存水平切分即可</span><br><span class="line">    + web-server重启或者扩容都不会有 session丢失</span><br><span class="line">+ 不足</span><br><span class="line">    + 增加了一次网络调用，并且需要修改应 用代码；如将所有的getSession方法替换为从Redis查数据的方式。redis获取数 据比内存慢很多</span><br><span class="line">    + 上面缺点可以用SpringSession完美解决</span><br></pre></td></tr></table></figure><h3 id="5、扩大cookie作用域"><a href="#5、扩大cookie作用域" class="headerlink" title="5、扩大cookie作用域"></a>5、扩大cookie作用域</h3><p>解决子域共享问题</p><p>问题：多域名</p><h2 id="SpringSession"><a href="#SpringSession" class="headerlink" title="SpringSession"></a>SpringSession</h2><p>配置类：json编码、cooki子域问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSessionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">cookieSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">//放大作用域</span></span><br><span class="line">        cookieSerializer.setDomainName(<span class="string">&quot;gulimall.com&quot;</span>);</span><br><span class="line">        cookieSerializer.setCookieName(<span class="string">&quot;GULISESSION&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSerializer&lt;Object&gt; <span class="title">springSessionDefaultRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理：装饰者模式"><a href="#原理：装饰者模式" class="headerlink" title="原理：装饰者模式"></a>原理：装饰者模式</h3><p>狸猫换太子</p><p>@EnableRedisHttpSession 导入 RedisHttpSessionConfiguration 配置</p><p>1、给容器中添加了一个组件 RedisOperationsSessionRepository：Redis操作session，session的增删改查封装类；</p><p>2、继承 SpringHttpSessionConfiguration 初始化了一个 SessionRepositoryFilter：session 存储过滤器；每个请求过来都必须经过 Filter 组件；创建的时候，自动从容器中获取到了 SessionRepository；</p><p> SessionRepositoryFilter：</p><ul><li>将原生的 HttpServletRequest Response 包装成 SessionRepositoryRequestWrapper ResponseWrapper；包装后的对象应用到了后面整个执行链；</li><li>以后获取 request.getSession(); 都会调用 wrappedRequesr.getSession(); 从SessionRepository获取；</li></ul><p>3、装饰者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    request.setAttribute(SESSION_REPOSITORY_ATTR, <span class="keyword">this</span>.sessionRepository);</span><br><span class="line">    SessionRepositoryFilter&lt;S&gt;.SessionRepositoryRequestWrapper wrappedRequest = <span class="keyword">new</span> SessionRepositoryFilter.SessionRepositoryRequestWrapper(request, response);</span><br><span class="line">    SessionRepositoryFilter.SessionRepositoryResponseWrapper wrappedResponse = <span class="keyword">new</span> SessionRepositoryFilter.SessionRepositoryResponseWrapper(wrappedRequest, response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filterChain.doFilter(wrappedRequest, wrappedResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        wrappedRequest.commitSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、sso单点登录"><a href="#3、sso单点登录" class="headerlink" title="3、sso单点登录"></a>3、sso单点登录</h1><p>跨域名单点登录简单实现：</p><p>1、服务端：未登录跳转认证中心（附带参数保存原地址）</p><p>2、认证中心：登录成功本地保存cookie（sso_token）</p><p>3、认证中心：保存登录用户登录状态到redis中</p><p>4、认证中心：重定向url中附带token跳转回原页面</p><p>5、服务端：根据token查询redis获取用户信息保存session</p><p>6、其他服务端：未登录跳转到认证中心，直接登录成功返回</p><p>服务端：根据有无session判断是否登录</p><p>认证中心：根据有无sso_token判断是否登录</p><p>可实现：filter、jwt、springsecurity</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" alt="单点登录流程"></p><h1 id="4、ThreadLocal同一个线程共享数据"><a href="#4、ThreadLocal同一个线程共享数据" class="headerlink" title="4、ThreadLocal同一个线程共享数据"></a>4、ThreadLocal同一个线程共享数据</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220218004911488.png" alt="image-20220218004911488"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; toThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">toThreadLocal.set(userInfoTo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">UserInfoTo userInfoTo = CartInterceptor.toThreadLocal.get();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——缓存&amp;分布式锁&amp;检索&amp;异步&amp;线程池</title>
    <link href="https://fireonice.github.io/2022/02/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E7%BC%93%E5%AD%98&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;%E6%A3%80%E7%B4%A2&amp;%E5%BC%82%E6%AD%A5/"/>
    <id>https://fireonice.github.io/2022/02/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E7%BC%93%E5%AD%98&amp;%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;%E6%A3%80%E7%B4%A2&amp;%E5%BC%82%E6%AD%A5/</id>
    <published>2022-02-16T15:38:58.639Z</published>
    <updated>2022-02-16T17:12:51.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、缓存"><a href="#1、缓存" class="headerlink" title="1、缓存"></a>1、缓存</h1><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220216234206407.png" alt="image-20220216234206407"></h2><h2 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h2><p>1、缓存穿透：</p><p>不存在数据</p><p>缓存null、设置短的过期时间</p><p>2、缓存雪崩：</p><p>大面积同时失效</p><p>失效加随机值</p><p>3、缓存击穿</p><p>热点key失效</p><p>加锁</p><h2 id="缓存数据一致性解决"><a href="#缓存数据一致性解决" class="headerlink" title="缓存数据一致性解决"></a>缓存数据一致性解决</h2><p>双写模式：</p><p>+ 改完数据库同时改缓存</p><p>+ 脏数据</p><p>​    + 加锁</p><p>​    + 是否允许暂时不一致性——缓存过期后可读正确数据</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220216234700247.png" alt="image-20220216234700247"></p><p>失效模式</p><p>+ 删除缓存数据</p><p>+ 等待下次查询主动更新</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003139062.png" alt="image-20220217003139062"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003318428.png" alt="image-20220217003318428"></p><p>+ 并发量小不考虑</p><p>+ 菜单等，用canal</p><p>​    + 自动更新缓存（db从库）</p><p>​    + 数据异构（访问记录表 和 商品 进行分析计算——用户推荐）</p><p>+ 过期时间保证 最终一致性</p><p>+ 加读写锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217003503499.png" alt="image-20220217003503499"></p><p>我们系统的一致性<strong>解决方案</strong>： </p><p>1、缓存的所有数据都有过期时间，数据过期下一次查询触发主动更新 </p><p>2、读写数据的时候，加上分布式的<strong>读写锁</strong>。 （经常写，经常读）</p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>使用大量aop切面编程，最终都是动态代理机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ @Cacheable：结果缓存</span><br><span class="line">+ key、value</span><br><span class="line">+ ttl</span><br><span class="line">+ 序列化：json</span><br><span class="line">+ @CacheEvict：删除缓存</span><br><span class="line">+ @CachePut：调用方法且缓存</span><br><span class="line">+ 双写模式</span><br><span class="line">+ @Caching：多个操作</span><br><span class="line">+ 开启缓存空值</span><br><span class="line">+ 防止缓存穿透</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ 读模式</span><br><span class="line">+ 缓存穿透：缓存null</span><br><span class="line">+ 缓存击穿：加锁</span><br><span class="line">+ 缓存雪崩：过期时间加随机</span><br><span class="line">+ 写模式（缓存与数据库一致）</span><br><span class="line">+ 读写加锁</span><br><span class="line">+ canal感知数据库</span><br><span class="line">+ 读多写多，直接去数据库</span><br></pre></td></tr></table></figure><h1 id="2、分布式锁"><a href="#2、分布式锁" class="headerlink" title="2、分布式锁"></a>2、分布式锁</h1><h3 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h3><p>redis setnx</p><p>问题：异常退出死锁</p><h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><p>同时原子设置过期时间</p><p>问题：锁过期，删错锁</p><h3 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h3><p>唯一标识value验证</p><p>问题：获取value和删除key非原子，仍存在删错锁</p><h3 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h3><p>lua脚本，解锁保证原子性</p><p>问题：未执行完锁过期，续期问题</p><h3 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h3><p>锁时间放长，finally解锁</p><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220217001540526.png" alt="image-20220217001540526"></p><p>使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，更进一步简化了分布式环境中程序相互之间的协作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+lock锁</span><br><span class="line">+自动续期</span><br><span class="line">+看门狗：判断线程 + 定时任务（重设过期时间）</span><br><span class="line">+ trylock（获取一次）</span><br><span class="line">+ fair lock公平锁（队列）</span><br><span class="line">+ readwritelock读写锁</span><br><span class="line">    + 写锁限制读和写操作（保证读数据一致性）</span><br><span class="line">    + 读锁单独无限制（无锁）</span><br><span class="line">    + 只要有写操作，就需要等待（读写，写读）</span><br><span class="line">+ 信号量（固定车位）</span><br><span class="line">+ 分布式限流</span><br><span class="line">+ acquire（阻塞）、Tryacquire</span><br><span class="line">+ 闭锁（走完关门）</span><br></pre></td></tr></table></figure><p>看门狗原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/816762-20210425105548419-1714180337.jpg" alt="img"></p><h1 id="3、检索"><a href="#3、检索" class="headerlink" title="3、检索"></a>3、检索</h1><p>vo封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询到的所有商品信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SkuEsModel&gt; product;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总页码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer totalPages;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; pageNavs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的品牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BrandVo&gt; brands;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的所有属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AttrVo&gt; attrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前查询到的结果，所有涉及到的所有分类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CatalogVo&gt; catalogs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================以上是返回给页面的所有信息============================//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 面包屑导航数据 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;NavVo&gt; navs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NavVo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String navName;</span><br><span class="line">        <span class="keyword">private</span> String navValue;</span><br><span class="line">        <span class="keyword">private</span> String link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long brandId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String brandName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String brandImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AttrVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long attrId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String attrName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; attrValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CatalogVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long catalogId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String catalogName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DSL</p><p>模糊匹配、过滤（属性、分类、品牌、价格区间、库存）</p><p>排序、分页、高亮、聚合分析</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">GET mall_product/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [ &#123;<span class="attr">&quot;match&quot;</span>: &#123;  <span class="attr">&quot;skuTitle&quot;</span>: <span class="string">&quot;华为&quot;</span> &#125;&#125; ], # 检索出华为</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [ # 过滤</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;catalogId&quot;</span>: <span class="string">&quot;225&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;terms&quot;</span>: &#123;<span class="attr">&quot;brandId&quot;</span>: [ <span class="string">&quot;2&quot;</span>] &#125; &#125;, </span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;hasStock&quot;</span>: <span class="string">&quot;false&quot;</span>&#125; &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;skuPrice&quot;</span>: &#123; # 价格1K~7K</span><br><span class="line">              <span class="attr">&quot;gte&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">              <span class="attr">&quot;lte&quot;</span>: <span class="number">7000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;nested&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;attrs&quot;</span>, # 聚合名字</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;attrs.attrId&quot;</span>: &#123; <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;6&quot;</span>&#125; &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [ &#123;<span class="attr">&quot;skuPrice&quot;</span>: &#123;<span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125; &#125; ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;  </span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;<span class="attr">&quot;skuTitle&quot;</span>: &#123;&#125;&#125;, # 高亮的字段</span><br><span class="line">    <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;b style=&#x27;color:red&#x27;&gt;&quot;</span>,  # 前缀</span><br><span class="line">    <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/b&gt;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123; # 查完后聚合</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123; # 子聚合</span><br><span class="line">        <span class="attr">&quot;brandNameAgg&quot;</span>: &#123;  # 每个商品id的品牌</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandName&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      </span><br><span class="line">        <span class="attr">&quot;brandImgAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brandImg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;catalogAgg&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;catalogId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;catalogNameAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;catalogName&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;attrs&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;nested&quot;</span>: &#123;<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;attrs&quot;</span> &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;attrIdAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;attrs.attrId&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;attrNameAgg&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;attrs.attrName&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;size&quot;</span>: <span class="number">10</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、异步-amp-线程池"><a href="#4、异步-amp-线程池" class="headerlink" title="4、异步&amp;线程池"></a>4、异步&amp;线程池</h1><p>1）、继承 Thread </p><p>2）、实现 Runnable 接口 </p><p>3）、实现 Callable 接口 + FutureTask （可以拿到返回结果，可以处理异常） </p><p>4）、线程池：调度、资源控制</p><p>线程池七大参数：</p><p>核心线程数、最大线程数、超时时间、超时时间单位、阻塞队列，线程工厂、拒绝策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行流程： </span><br><span class="line">1、线程池创建，准备好 core 数量的核心线程，准备接受任务 </span><br><span class="line">2、新的任务进来，用 core 准备好的空闲线程执行。 </span><br><span class="line">  (1) 、core 满了，就将再进来的任务放入阻塞队列中。空闲的 core 就会自己去阻塞队 列获取任务执行 </span><br><span class="line">  (2) 、阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量</span><br><span class="line">  (3) 、max 都执行好了。Max-core 数量空闲的线程会在 keepAliveTime 指定的时间后自 动销毁。最终保持到 core 大小 </span><br><span class="line">  (4) 、如果线程数开到了 max 的数量，还有新任务进来，就会使用 reject 指定的拒绝策 略进行处理 </span><br><span class="line">3、所有的线程创建都是由指定的 factory 创建的。</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h2><p>  很多语言，比如 Node.js，采用回调的方式实现异步编程。Java 的一些框架，比如 Netty，自 己扩展了 Java 的 <code>Future</code>接口，提供了<code>addListener</code>等多个扩展方法；Google guava 也提供了 通用的扩展 Future；Scala 也提供了简单易用且功能强大的 Future/Promise 异步编程模式。</p><p>  在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以 通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。 CompletableFuture 类实现了 Future 接口，所以你还是可以像以前一样通过<code>get</code>方法阻塞或 者轮询的方式获得结果，但是这种方式不推荐使用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ 启动异步任务</span><br><span class="line">+ runAsync</span><br><span class="line">+ supplyAsync</span><br><span class="line">+ 完成回调与异常感知</span><br><span class="line">+ whenComplete</span><br><span class="line">+ exceptionally</span><br><span class="line">+ whenCompleteAsync</span><br><span class="line">+ handle最终处理</span><br><span class="line">+ 和 complete 一样</span><br><span class="line">+ 可对结果做最后的处理（可处理异常），可改变返回值</span><br><span class="line">+ 线程串行化方法</span><br><span class="line">+ thenApply</span><br><span class="line">+ thenAccept</span><br><span class="line">+ thenRun</span><br><span class="line">+ 两任务组合</span><br><span class="line">    + 都要完成</span><br><span class="line">    + 一个完成</span><br><span class="line">+ 多任务组合</span><br><span class="line">+ allOf</span><br><span class="line">+ anyOf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——性能压测</title>
    <link href="https://fireonice.github.io/2022/02/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%8E%8B%E6%B5%8B/"/>
    <id>https://fireonice.github.io/2022/02/14/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%8E%8B%E6%B5%8B/</id>
    <published>2022-02-14T06:47:15.765Z</published>
    <updated>2022-02-16T15:38:45.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、jvm-内存模型"><a href="#1、jvm-内存模型" class="headerlink" title="1、jvm 内存模型"></a>1、jvm 内存模型</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214153035740.png" alt="image-20220214153035740"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ 程序计数器 Program Counter Register： </span><br><span class="line"> + 记录的是正在执行的虚拟机字节码指令的地址， </span><br><span class="line"> + 此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OutOfMemoryError的区域 </span><br><span class="line">+ 虚拟机：VM Stack </span><br><span class="line"> + 描述的是 JAVA 方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法接口等信息</span><br><span class="line"> + 局部变量表存储了编译期可知的各种基本数据类型、对象引用  </span><br><span class="line"> + 线程请求的栈深度不够会报 StackOverflowError 异常  </span><br><span class="line"> + 栈动态扩展的容量不够会报 OutOfMemoryError 异常  </span><br><span class="line"> + 虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈  </span><br><span class="line">+ 本地方法：Native Stack  </span><br><span class="line"> + 本地方法栈类似于虚拟机栈，只不过本地方法栈使用的是本地方法  </span><br><span class="line">+ 堆：Heap </span><br><span class="line"> + 几乎所有的对象实例都在堆上分配内存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145444465.png" alt="image-20220214145444465"></p><h1 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h1><p>所有的对象实例以及数组都要在堆上分配。堆是垃圾收集器管理的主要区域，也被称为“GC堆”；也是我们优化最多考虑的地方。 堆可以细分为： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 新生代 </span><br><span class="line"> + Eden 空间 </span><br><span class="line"> + From Survivor 空间 </span><br><span class="line"> + To Survivor 空间 </span><br><span class="line">+ 老年代</span><br><span class="line">+ 永久代/元空间 </span><br><span class="line"> + Java8 以前永久代，受 jvm 管理，java8 以后元空间，直接使用物理内存。因此， 默认情况下，元空间的大小仅受本地内存限制。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145921888.png" alt="image-20220214145921888"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145742455.png" alt="image-20220214145742455"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214145909109.png" alt="image-20220214145909109"></p><h1 id="3、JVM-分析-amp-调优"><a href="#3、JVM-分析-amp-调优" class="headerlink" title="3、JVM 分析&amp;调优"></a>3、JVM 分析&amp;调优</h1><p>Full gc 最会影响性能，根据代码问题，避免 full gc 频率。可以适当调大年轻代容量，让大对象可以在年轻代触发 yong gc，调整大对象在年轻代的回收频次，尽可能保证大对象在年轻代回收，减小老年代缩短回收时间。</p><h1 id="4、压测"><a href="#4、压测" class="headerlink" title="4、压测"></a>4、压测</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214152417181.png" alt="image-20220214152417181"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220214152548781.png" alt="image-20220214152548781"></p><p>现阶段优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 中间件</span><br><span class="line"> + nginx 动静分离</span><br><span class="line"> + gateway</span><br><span class="line">+ db</span><br><span class="line"> + 索引</span><br><span class="line"> + 操作</span><br><span class="line">+ log</span><br><span class="line">+ redis</span><br><span class="line">+ page cache</span><br><span class="line">+ jvm内存</span><br><span class="line">+ 业务流程</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城——分布式基础-全栈开发篇</title>
    <link href="https://fireonice.github.io/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://fireonice.github.io/2022/02/12/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-02-12T11:15:39.860Z</published>
    <updated>2022-02-12T13:31:40.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、写在前面"><a href="#1、写在前面" class="headerlink" title="1、写在前面"></a>1、写在前面</h1><p>仿京东商城大型分布式架构电商平台：微服务架构+分布式+全栈+集群+部署+自动化运维+可视化CICD</p><p>Gitee仓库：<a href="https://gitee.com/namdev/gulimall">https://gitee.com/namdev/gulimall</a></p><p>后台接口文档：<a href="https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd">https://easydoc.net/s/78237135/ZUqEdvA4/hKJTcbfd</a></p><p>b站视频地址：<a href="https://www.bilibili.com/video/BV1np4y1C7Yf">全网最强电商教程《谷粒商城》对标阿里P6/P7，40-60万年薪</a></p><h1 id="2、架构"><a href="#2、架构" class="headerlink" title="2、架构"></a>2、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201439633.png" alt="image-20220212201439633"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212201228064.png" alt="image-20220212201228064"></p><h1 id="3、基础环境"><a href="#3、基础环境" class="headerlink" title="3、基础环境"></a>3、基础环境</h1><p>linux、docker</p><p>数据库</p><p>人人后台</p><p>分布式组件</p><h1 id="4、商品、订单、仓库服务后台"><a href="#4、商品、订单、仓库服务后台" class="headerlink" title="4、商品、订单、仓库服务后台"></a>4、商品、订单、仓库服务后台</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211040144.png" alt="image-20220212211040144"></p><h2 id="pms库"><a href="#pms库" class="headerlink" title="pms库"></a>pms库</h2><p>Attr：属性表</p><p>Attr_group：属性分组表</p><p>Attr_attrgroup_relation：属性分组关联表</p><p>Product_attr_value：商品id属性值表</p><p>Spu_info：商品spu</p><p>Sku_info：商品sku</p><p>Sku_images：商品sku图片</p><p>Sku_sale_attr_values：商品sku销售属性值</p><p>三级分类——属性分组——属性</p><p>属性——商品（spu）属性集——商品型号（sku）属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211136464.png" alt="image-20220212211136464"></p><h2 id="保存商品"><a href="#保存商品" class="headerlink" title="保存商品"></a>保存商品</h2><p>Spu_info：基本信息</p><p>Spu_info_desc：id + 描述图片</p><p>Spu_images：id + 图片集</p><p>Product_attr_value：spu规格参数 spuid + 属性值</p><p>Spu_bounds：商品积分 （sms库）</p><p>Sku_info：sku基本信息 + spuid</p><p>Sku_images：skuid + sku图片信息</p><p>Sku_sale_attr_value：sku销售属性 skuid + 属性值</p><p>Sku优惠满减信息（sms库）：skuid</p><p>Sku_ladder：打折表</p><p>Sku_full_reduction：满减表</p><p>Member_price：会员价格表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220212211157512.png" alt="image-20220212211157512"></p><h2 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h2><p>单表、多表、多库、远程调用、属性拷贝等暂时省略</p><h1 id="5、jsr303校验"><a href="#5、jsr303校验" class="headerlink" title="5、jsr303校验"></a>5、jsr303校验</h1><p>开启校验（错误返回） + bean校验注解</p><p>统一异常处理</p><p>枚举类</p><p>jsr303分组校验</p><p>jsr303自定义校验注解</p><h1 id="5、object"><a href="#5、object" class="headerlink" title="5、object"></a>5、object</h1><p>1.PO(persistant object) 持久对象 </p><p>PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。 </p><p>2.DO（Domain Object）领域对象就是从现实世界中抽象出来的有形或无形的业务实体。 </p><p>3.TO(Transfer Object) 数据传输对象</p><p>不同的应用程序之间传输的对象 </p><p>4.DTO（Data Transfer Object）数据传输对象</p><p>这个概念来源于 J2EE 的设计模式，原来的目的是为了 EJB 的分布式应用提供粗粒度的 数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。 </p><p>5.VO(value object) 值对象 </p><p>通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已。但应是抽象出 的业务对象 , 可以和表对应 , 也可以不 , 这根据业务的需要 。用 new 关键字创建，由 GC 回收的。 View object：视图对象； 接受页面传递来的数据，封装对象将业务处理完成的对象，封装成页面要用的数据 </p><p><strong>6.BO(business object)</strong> <strong>业务对象</strong> </p><p>从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 </p><p>java 对 象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。business object: 业务对象主要作 用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简 历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经 历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。</p><p>7.POJO(plain ordinary java object) 简单无规则 java 对象 </p><p>传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护 数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增 加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及 setter 和 getter 方法！。POJO 是 DO/DTO/BO/VO 的统称。 </p><p>8.DAO(data access object) 数据访问对象 </p><p>是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久 层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作.</p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开发总结——金融业务平台</title>
    <link href="https://fireonice.github.io/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/"/>
    <id>https://fireonice.github.io/2022/02/07/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%933/</id>
    <published>2022-02-07T11:19:32.659Z</published>
    <updated>2022-02-07T12:10:50.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、产品架构"><a href="#1、产品架构" class="headerlink" title="1、产品架构"></a>1、产品架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207192011048.png" alt="image-20220207192011048"></p><h1 id="2、业务流程"><a href="#2、业务流程" class="headerlink" title="2、业务流程"></a>2、业务流程</h1><p>1、账户绑定</p><p>（用户表、用户绑定表）</p><p>用户——绑定信息提交（借款、出借）——调用第三方托管平台账户创建（阿里云短信）——绑定完成（异步更新）</p><p>2、申请借款额度</p><p>（用户表、积分表、借款人表、借款人图片表）垂直分表</p><p>提交借款人个人信息（身份证等证件资源：对象存储）——后台系统评估——审核通过——获取额度</p><p>3、借款额度审核</p><p>后台借款额度申请列表——借款人信息——借款额度审核</p><p>4、借款申请</p><p>（借款信息表、积分等级配置表、标的准备表）</p><p>获取借款额度（用户积分）——提交借款申请——获取借款申请状态</p><p>5、借款审核</p><p>后台借款信息列表——借款详情——借款审批</p><p>6、标的管理</p><p>（标的表）</p><p>审核完成——新标的、标的详情、标的列表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220207194625467.png" alt="image-20220207194625467"></p><p>7、我要投资</p><p>前端标的列表</p><p>8、充值</p><p>（用户账号表[余额等]、交易流水表）</p><p>注册 + 账户绑定——充值——第三方托管支付——完成（异步修改）</p><p>幂等性保证（重复请求）：判断流水是否存在，存在则退出</p><p>9、投标</p><p>收益根据还款方式：等额本息、等额本金、按期付息到期还本、一次还本付息</p><p>（标的表、标的出借记录表、还款记录表、标的出借回款记录表）标的id</p><p>标的详情——输入金额计算收益——投标支付——完成（异步回调：标的状态、投资流水、金额、标的信息）</p><p>10、放款</p><p>（还款人还款记录表、投资人回款记录表）</p><p>管理平台放款——（1）标的状态和标的平台收益（2）<strong>给借款账号转入金额</strong>（3）增加借款交易流水（4）<strong>解冻并扣除投资人资金</strong>（5）增加投资人交易流水（6）生成借款人还款计划和出借人回款计划</p><p>11、投资列表展示</p><p>后台列表——前台列表——后台还款计划——前台还款计划——前台回款计划</p><p>12、提现和还款</p><p>第三方托管提现</p><p>还款——转出金额——分配转入投资方——流水明细、回款明细</p><p>13、个人中心</p><p>流水明细、用户账号明细</p><p>14、消息队列</p><p>监听消息队列发送短信（充值、绑定、转出等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/27528777bac0634fd778ca60094057b4.png" alt="27528777bac0634fd778ca60094057b4"></p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开发总结——MongoDB、业务流程</title>
    <link href="https://fireonice.github.io/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/"/>
    <id>https://fireonice.github.io/2022/02/06/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932/</id>
    <published>2022-02-06T14:15:39.809Z</published>
    <updated>2022-02-06T14:45:34.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、架构"><a href="#1、架构" class="headerlink" title="1、架构"></a>1、架构</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222116806.png" alt="image-20220206222116806"></p><h1 id="2、MongoDB"><a href="#2、MongoDB" class="headerlink" title="2、MongoDB"></a>2、MongoDB</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>基于分布式文件存储的开源数据库系统</p><p>字段值可以包含其他文档，数组及文档数组。</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206222409680.png" alt="image-20220206222409680"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MongoDB 是一个面向文档存储的数据库</p><p>MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序</p><p>可以通过本地或者网络创建数据镜像，实现高扩展性</p><p>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上，分片</p><p>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>1、网站数据、大数据、缓存</p><p>2、高伸缩性</p><p>3、对象、json数据</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>MongoTemplate</p><p>MongoRepository（SpringData方法定义规范）</p><h1 id="3、预约挂号业务"><a href="#3、预约挂号业务" class="headerlink" title="3、预约挂号业务"></a>3、预约挂号业务</h1><p>1、排班和挂号详情信息——【医院+科室——规则——日期——排班、挂号信息】</p><p>2、确认挂号信息——【就诊人、排班信息】</p><p>3、生成预约挂号订单【就诊人 + 排班 —— 生成订单】</p><p>4、挂号订单支付（微信）【微信支付、订单状态】</p><p>5、取消预约订单【退款、取消订单】</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220206221759069.png" alt="image-20220206221759069"></p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开发总结——前后端分离+微服务</title>
    <link href="https://fireonice.github.io/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://fireonice.github.io/2022/02/05/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2022-02-05T14:14:05.168Z</published>
    <updated>2022-02-05T15:38:47.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、MP"><a href="#1、MP" class="headerlink" title="1、MP"></a>1、MP</h1><p>基本流程</p><p>主键自动生成</p><p>自动填充</p><p>乐观锁实现</p><p>select、分页</p><p>delete：逻辑删除、物理删除</p><p>mp性能分析插件</p><p>条件查询Querywrapper</p><h1 id="2、后端1"><a href="#2、后端1" class="headerlink" title="2、后端1"></a>2、后端1</h1><p>json时区</p><p>swagger测试</p><p>统一返回格式</p><p>@requestbody</p><p>统一、指定、自定义异常处理</p><p>日志输出、日志级别</p><h1 id="3、前端1"><a href="#3、前端1" class="headerlink" title="3、前端1"></a>3、前端1</h1><p>es6语法：</p><p>数组解构、对象赋值、模拟字符串、对象方法、箭头函数</p><p>vue指令、组件</p><p>vue生命周期：</p><p>Create、Mounted</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220205230634449.png" alt="image-20220205230634449"></p><p>断点</p><p>Vue路由</p><p>Axios</p><p>Element-ui</p><p>Node.js</p><p>npm</p><p>Babel</p><p>前端模块化</p><p>Webpack</p><p>vue-admin-template、目录结构</p><p>跨域</p><p>路由切换</p><p><strong>开发流程</strong></p><p>服务端渲染技术</p><p>NUST框架</p><h1 id="4、oss、视频点播、短信、微信支付、微信注册"><a href="#4、oss、视频点播、短信、微信支付、微信注册" class="headerlink" title="4、oss、视频点播、短信、微信支付、微信注册"></a>4、oss、视频点播、短信、微信支付、微信注册</h1><p>阿里云对象存储</p><p>阿里云视频点播：上传、播放、删除</p><p>阿里云短信服务</p><p>微信支付</p><p>微信注册</p><h1 id="5、后端2"><a href="#5、后端2" class="headerlink" title="5、后端2"></a>5、后端2</h1><p>nginx</p><p>EasyExcel读写</p><p>Vue tree</p><p>vo</p><p>bean转换</p><p>树形结构：遍历、循环</p><p>路由、隐藏路由、动态路由</p><p>富文本编辑器</p><p>多表联查——SQL</p><p>openfeign、nacos</p><p>远程调用流程：</p><p>1、接口化请求调用</p><p>2、Feign</p><p>3、Hystrix</p><p>4、Ribbon</p><p>5、Httpclient</p><h1 id="6、后端3"><a href="#6、后端3" class="headerlink" title="6、后端3"></a>6、后端3</h1><p>redis缓存：</p><p>Cacheable、Cacheput、Cacheevict</p><p>sso单点登录</p><p>jwt：json web token</p><p>1、jwt头信息</p><p>2、有效载荷</p><p>3、签名哈希</p><p>sso实现：</p><p>1、session复制</p><p>2、Cookie带着唯一key在中redis 查询 </p><p>3、Token：用户信息加密成的字符串（自包含令牌）</p><p>（1）cookie 或者 地址栏</p><p>（2）访问时携带字符串</p><p>Reids过期时间、token过期时间 均可设置过期</p><p>密码加密：</p><p>1、MD5工具类</p><p>2、密码加密和数据库比较</p><p>token解析</p><h1 id="7、前端2"><a href="#7、前端2" class="headerlink" title="7、前端2"></a>7、前端2</h1><p>二维码</p><p>定时器</p><p>token实现：</p><p>(1) 登录返回token</p><p>(2) Token放到cookie中</p><p>(3) 前端拦截器（请求拦截）：判断cookie是否有token，把token放到请求头中</p><p>(4) 根据请求头的token获取用户信息，用户信息放到cookie中</p><p>(5) 显示用户信息</p><p>验证——获得token（放到cookie）——拦截：获取token放到header——调用api获取用户信息（放到cookie）</p><p>cookie：json字符串转为json对象</p><p>OAuth2</p><p>微信登录：</p><p>1、使用httpclient发送get请求（工具类 + 依赖）</p><p>2、从json字符串获取值（转为map）</p><p>3、再请求一个地址，获取扫码人信息</p><p>4、自动注册（未注册）</p><p>token路径传递</p><p>1、通过路径获取token</p><p>以下同前面</p><p>2、Token——cookie、拦截器：token——header</p><p>存在cookie中是因为有拦截器会将cookie中的token存到header中，后端也是从hader中取token的，cookie相当于转存的介质</p><p>3、Token + header = member——cookie</p><p>播放器组件</p><p>评论组件</p><p>微信支付：</p><p>(1) 生成订单</p><p>① 根据课程id获取课程信息——远程调用</p><p>② 根据用户id（jwt从header获取id）获取用户信息——远程调用</p><p>(2) 根据id查询订单信息</p><p>(3) 生成微信支付二维码</p><p>① 、获取订单参数</p><p>②、发送httpclient请求（参数xml）</p><p>③、获取返回结果</p><p>(4) 查询支付状态</p><p>①Service——发送httpclient请求——返回包含状态</p><p>②添加支付记录，更改订单状态</p><p>③定时器</p><p>根据Url下载二维码组件</p><p>Echarts</p><p>定时任务</p><h1 id="8、后端4"><a href="#8、后端4" class="headerlink" title="8、后端4"></a>8、后端4</h1><p>canal数据同步</p><p>Gateway：路由、断言、过滤器</p><p>权限管理</p><p>权限关系表</p><p>递归分级</p><p>SpringSecurity</p><p>nacos配置中心</p><h1 id="9、Jenkins"><a href="#9、Jenkins" class="headerlink" title="9、Jenkins"></a>9、Jenkins</h1><p>Jenkins、github action</p><h1 id="10、产品开发流程"><a href="#10、产品开发流程" class="headerlink" title="10、产品开发流程"></a>10、产品开发流程</h1><p>1、需求调研（产品经理）</p><p>2、需求评审（产品/设计/前端/后端/测试/运营）</p><p>3、立项（项目经理、品管）</p><p>4、UI设计</p><p>5、开发</p><p>· 架构、数据库设计、API文档、MOCK数据、开发、单元测试</p><p>· 前端</p><p>· 后端</p><p>6、前端后端联调</p><p>7、项目提测：黑盒白盒、压力测试（qps）  loadrunner</p><p>8、bug修改</p><p>9、回归测试</p><p>10、运维和部署上线</p><p>11、灰度发布</p><p>12、全量发布</p><p>13、维护和运营</p>]]></content>
    
    
    <summary type="html">产品开发</summary>
    
    
    
    <category term="产品" scheme="https://fireonice.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="产品开发" scheme="https://fireonice.github.io/tags/%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Mycat</title>
    <link href="https://fireonice.github.io/2022/01/28/Mycat/"/>
    <id>https://fireonice.github.io/2022/01/28/Mycat/</id>
    <published>2022-01-28T11:47:51.198Z</published>
    <updated>2022-02-05T14:15:32.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><p>① Java与数据库紧耦合。 </p><p>② 高访问量高并发对数据库的压力。 </p><p>③ 读写请求数据不一致</p><p>对比：<img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195056298.png" alt="image-20220128195056298"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>读写分离：配合主从复制、主备模式</p><p>数据分片：分库分表</p><p>多数据源整合</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195358045.png" alt="image-20220128195358045"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>拦截</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195439600.png" alt="image-20220128195439600"></p><p>三个重要配置文件</p><p>1、逻辑库、表、分片节点</p><p>2、分片规则</p><p>3、用户、系统配置</p><h1 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h1><p>Myqsl：从接入点开始复制</p><h2 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h2><p>日志格式</p><p>balance属性：读写分离</p><p>复制原理：</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195544208.png" alt="image-20220128195544208"></p><h2 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h2><p>主备切换</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195329105.png" alt="image-20220128195329105"></p><h1 id="3、分库分表"><a href="#3、分库分表" class="headerlink" title="3、分库分表"></a>3、分库分表</h1><h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128195834488.png" alt="image-20220128195834488"></p><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><p>多表联查</p><p>全局表：全局一致性（广播）</p><p>常用分片规则：</p><p>取模、分片枚举、范围约定、日期</p><h2 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h2><p>1、本地文件</p><p>2、时间戳</p><p>3、数据库方式</p><p>4、reids、雪花算法等</p><h1 id="4、基于HA机制的Mycat高可用"><a href="#4、基于HA机制的Mycat高可用" class="headerlink" title="4、基于HA机制的Mycat高可用"></a>4、基于HA机制的Mycat高可用</h1><p>Mycat集群保证数据库高可用</p><p>haproxy保证mycat高可用（负载均衡）</p><p>Keepalived保证haproxy高可用（创建虚拟ip）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200457657.png" alt="image-20220128200457657"></p><p>安全权限</p><p>user、privileges、sql拦截</p><h1 id="6、监控"><a href="#6、监控" class="headerlink" title="6、监控"></a>6、监控</h1><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220128200635053.png" alt="image-20220128200635053"></p>]]></content>
    
    
    <summary type="html">Mycat</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="Mycat" scheme="https://fireonice.github.io/tags/Mycat/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ</title>
    <link href="https://fireonice.github.io/2022/01/27/RocketMQ/"/>
    <id>https://fireonice.github.io/2022/01/27/RocketMQ/</id>
    <published>2022-01-27T10:43:25.568Z</published>
    <updated>2022-02-05T14:15:45.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h2><p>限流削峰（请求存在队列中）</p><p>异步解耦</p><p>数据采集</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213121974.png" alt="image-20220127213121974"></p><h2 id="MQ常见协议"><a href="#MQ常见协议" class="headerlink" title="MQ常见协议"></a>MQ常见协议</h2><p>JMS</p><p>STOMP</p><p>AMQP</p><p>MQTT</p><h1 id="2、RocketMQ"><a href="#2、RocketMQ" class="headerlink" title="2、RocketMQ"></a>2、RocketMQ</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>消息、主题、标签、队列、消息标识（消息唯一id：生产者、broker）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213610678.png" alt="image-20220127213610678"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213633953.png" alt="image-20220127213633953"></p><p>生产者</p><p>消费者</p><p>（一个消费者组，消费者消费队列不同）</p><p>Name Server（注册中心）：broker管理、路由信息管理</p><p>路由注册、路由剔除（心跳包）、路由发现、选择策略：轮询</p><p>broker</p><p>组成：实体、客户端管理、存储、高可用（集群数据同步）、索引（ID）</p><p>集群部署：主备集群</p><p>主从、主备</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127213923298.png" alt="image-20220127213923298"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>1、启动server、监听端口</p><p>2、Broker与serve长连接</p><p>3、创建topic</p><p>4、生产者发送消息：和server建立连接，获取路由（topic、broker）。</p><p>与broker长连接，向broker发送消息。路由信息每30s缓存在本地。</p><p>5、消费者，server连接，获取路由。与broker长连接，消费。</p><p>Consumer发送心跳，确认broker存活状态。</p><h3 id="Topic的创建模式"><a href="#Topic的创建模式" class="headerlink" title="Topic的创建模式"></a>Topic的创建模式</h3><p>集群、broker模式</p><h3 id="读写队列"><a href="#读写队列" class="headerlink" title="读写队列"></a>读写队列</h3><p>一般情况数量一样</p><p>设计目的：方便topic的缩容</p><p>写队列先缩容，读队列消费完后再缩容，不丢失任何消息。</p><h2 id="集群搭建理论"><a href="#集群搭建理论" class="headerlink" title="集群搭建理论"></a>集群搭建理论</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214305521.png" alt="image-20220127214305521"></p><h3 id="数据复制与刷盘策略"><a href="#数据复制与刷盘策略" class="headerlink" title="数据复制与刷盘策略"></a>数据复制与刷盘策略</h3><p>生产者、消费者：groupname相同即可</p><p>Nameserver集群：相互不通信，启动即可</p><p>Broker集群：多个主备小集群</p><p>数据复制：master向slave复制</p><h3 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h3><p>刷盘：由内存写入到磁盘</p><p>同步、异步复制（ACK时机）</p><p>同步：slave成功后ack</p><p>异步：master写入后ack</p><h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p>同步、异步刷盘</p><p>同步：broker写入磁盘ack</p><p>异步：broker写入内存ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214313364.png" alt="image-20220127214313364"></p><p>多master集群：宕机后无法消费</p><h3 id="多master多slave集群"><a href="#多master多slave集群" class="headerlink" title="多master多slave集群"></a>多master多slave集群</h3><p>一个master一个slave：主备模式</p><p>Master处理消息读写</p><p>Slave负责消息备份和宕机后的自动切换</p><p>最好使用RAID阵列</p><p>同步双写：同步复制</p><p>安全性最高，RT响应时间长</p><p>Slave不能自动切换</p><p>RAID10磁盘阵列 + 异步复制</p><h2 id="磁盘阵列RAID"><a href="#磁盘阵列RAID" class="headerlink" title="磁盘阵列RAID"></a>磁盘阵列RAID</h2><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h1 id="3、RocketMQ的工作原理"><a href="#3、RocketMQ的工作原理" class="headerlink" title="3、RocketMQ的工作原理"></a>3、RocketMQ的工作原理</h1><h2 id="消息的生产"><a href="#消息的生产" class="headerlink" title="消息的生产"></a>消息的生产</h2><p>1、生产者向servre发送请求，获取topic路由</p><p>2、Server返回topic路由表及broker列表</p><p>（1）路由表：map&lt;topic,queuedata&gt;，queuedata：broker——queue</p><p>找到queue对应的broker</p><p>（2）Broker列表</p><p>3、选择queue</p><p>4、生产者对消息特殊处理</p><p>5、生产者向broker发出RPC请求，发送到queue（底层netty）</p><h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><p>轮询（问题：性能）、最小投递延迟（问题：分配不均）</p><h2 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h2><h3 id="store目录"><a href="#store目录" class="headerlink" title="store目录"></a>store目录</h3><p>刷盘、消息、配置、队列、消息索引、全局资源锁</p><h3 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h3><p>第n个文件名：前n-1个文件大小之和</p><p>消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214852355.png" alt="image-20220127214852355"></p><h3 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h3><p>消费队列</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127214940291.png" alt="image-20220127214940291"></p><p>索引条目：</p><p>是commitlog的索引文件——定位具体消息</p><p>消息条目——偏移量、消息长度、消息tag</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215015213.png" alt="image-20220127215015213"></p><h3 id="对文件的读写"><a href="#对文件的读写" class="headerlink" title="对文件的读写"></a>对文件的读写</h3><p>消息写入</p><p>1、根据queueid，得到comsumequeue要写入的偏移量</p><p>2、封装消息单元</p><p>3、写入commitlog</p><p>4、形成索引条目</p><p>消息拉取</p><p>1、获取所在queue的偏移量</p><p>2、发送broker拉取请求，queue等信息</p><p>3、得到consumequeue中位置</p><p>4、查找指定tag索引</p><p>5、定位commitlog</p><p>6、读取其中的消息单元</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215053467.png" alt="image-20220127215053467"></p><p>性能提升：</p><p>文件读写：通过mmap零拷贝</p><p>Comsuequeue读取：</p><p>引入pagecache预读取机制，接近内存读取（顺序读写）</p><p>本质：缓存</p><p>写：先写入pagecache，再异步写入磁盘</p><p>读：首先读pagecache，若没有命中，将磁盘数据加载到pacache，同时对相邻数据预读取</p><p>Commitlog读取：随机访问，会影响性能</p><p>与kafka对比：</p><p>RocketMQ中的commitlog目录与consumequeue的结合就类似于Kafka中的partition分区目录。</p><p>mappedFile文件就类似于Kafka中的segment段</p><h2 id="indexfile"><a href="#indexfile" class="headerlink" title="indexfile"></a>indexfile</h2><p>根据key进行消息查询（前提：消息包含key）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215235908.png" alt="image-20220127215235908"></p><p>Indexheader：该索引索引相关信息（数量，偏移量等）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215241833.png" alt="image-20220127215241833"></p><p>Slot</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215249106.png" alt="image-20220127215249106"></p><p>Index</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215257689.png" alt="image-20220127215257689"></p><p>创建</p><p>indexfile查询流程：</p><p>1、根据key、time找到indexfile</p><p>2、传入时间与文件名差值</p><p>3、计算key的hash——Slot序号——读取slot——最新的indexNo</p><p>4、根据indexN找到index位置</p><p>5、相比Index中的diff</p><p>（1）若时间差小，往前找</p><p>（2）若时间差大，index中定位位置，找到消息</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215406692.png" alt="image-20220127215406692"></p><h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><h3 id="两种消息获取方式"><a href="#两种消息获取方式" class="headerlink" title="两种消息获取方式"></a>两种消息获取方式</h3><p>Push（consumer主动拉取），注意拉取时间间隔</p><p>pull（broker主动推动，实时性高），向queue注册监听器，基于长连接</p><h3 id="两种消息消费模式"><a href="#两种消息消费模式" class="headerlink" title="两种消息消费模式"></a>两种消息消费模式</h3><p>广播模式：每个消费者都接收topic全部消息</p><p>集群模式：消费者平分消息</p><h3 id="消息进度保存"><a href="#消息进度保存" class="headerlink" title="消息进度保存"></a>消息进度保存</h3><p>广播模式：消费者保存</p><p>集群模式：保存broker中共享，消息进度参与负载均衡</p><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>Queue和consumer的之间重新分配</p><p>增加减少消费者，提升消息并行</p><p>消费者要小于队列</p><p>危害：</p><p>消息暂停：重分配后才能再消费</p><p>消费重复：异步提交，导致可能重复消费</p><p>一次性读取消息数量需要均衡：重复消费、性能</p><p>消息突刺：重复消费过多消息、积压时间过长</p><p>产生的原因和过程</p><p>1、Queue数量变化</p><p>（1）broker扩缩容</p><p>（2）Broker升级运维</p><p>（3）网络异常</p><p>（4）Queue扩缩容</p><p>2、消费者数量变化</p><p>（1）consumergroup扩缩容</p><p>（2）Consumer升级运维</p><p>（3）网络异常</p><p>过程：</p><p>Broker发现变化，向consumergroup发出Rebalance通知</p><p>Consumer采用分配算法，自主进行Rebalance</p><p>Broker中group coordinate选举consumer leader</p><p>由lerder完成分区的再分配，上报coordinate，coordinate同步给consumer实例</p><p>Kafka的Rebalance由选举的comsumer leader完成。</p><p>Rocket的Rebalance由每个consumer完成</p><p>Queue分配算法</p><p>平均分配</p><p>环形平均策略：类似轮询</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215711998.png" alt="image-20220127215711998"></p><p>一致性hash策略：先把consumer放到环上，再把queue的hash值放环上，顺时针找consumer （缺点：分配不均）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127215721201.png" alt="image-20220127215721201"></p><p>同机房策略</p><p>一致性hash：减少扩缩容的rebalance</p><p>扩缩容需要rebalance，变化较大</p><p>一致性hash扩缩容变化较小：应用场景，consumer变化较多</p><p>至少一次原则</p><h2 id="订阅关系的一致性"><a href="#订阅关系的一致性" class="headerlink" title="订阅关系的一致性"></a>订阅关系的一致性</h2><h2 id="offset管理"><a href="#offset管理" class="headerlink" title="offset管理"></a>offset管理</h2><p>Consumer的消费进度offset</p><h3 id="Offset本地管理"><a href="#Offset本地管理" class="headerlink" title="Offset本地管理"></a>Offset本地管理</h3><p>广播，消费进度保存在consumer中</p><h3 id="Offset远程管理"><a href="#Offset远程管理" class="headerlink" title="Offset远程管理"></a>Offset远程管理</h3><p>集群消费，保存在broker文件中</p><p>所有consumer共享queue的消费进度</p><p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制</p><p>Rebalance后，新的consumer可以读取相应消费进度继续消费</p><p>NextBeginOffset：下次消费起始</p><p>消费异常：异常消息提交broker的重试队列</p><p>同步、异步提交offset</p><p>异步：提交offset、无需等待broker响应，直接从broker获取next</p><h2 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h2><h3 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h3><p>重复消费影响相同</p><p>1、发送重复：Broker对生产者ack失败，生产者重复发送相同消息（msgid相同）</p><p>2、消费重复：consumer对broker的ack失败，broker再次投递相同消息</p><p>3、Rebalance：consumer、queue变化，没提交ack前Rebalance可能重复消费</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>幂等令牌：具备唯一业务表示的字符串，唯一id</p><p>唯一性处理：服务端采用算法，保证成功执行一次</p><p>1、通过缓存去重，缓存是否命中幂等令牌</p><p>2、数据库查询是否有幂等令牌（缓存可能过期）</p><p>3、同一事务中：唯一性处理、幂等令牌写入缓存，幂等令牌写入DB</p><h3 id="支付场景中的解决方案"><a href="#支付场景中的解决方案" class="headerlink" title="支付场景中的解决方案"></a>支付场景中的解决方案</h3><p>1、首先redis获取流水号</p><p>（1）不为空，调用重复逻辑</p><p>2、无缓存，查询DB</p><p>（1）不为空，调用重复逻辑</p><p>3、为空，在分布式事务完成</p><p>（1）完成支付</p><p>（2）流水号作为key，存入redis（过期时间）</p><p>（3）流水号作为主键存入DB</p><p>消费幂等的实现</p><p>最好以业务唯一标识作为依据</p><h2 id="消息堆积与消费延迟"><a href="#消息堆积与消费延迟" class="headerlink" title="消息堆积与消费延迟"></a>消息堆积与消费延迟</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220321282.png" alt="image-20220127220321282"></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>消费速度跟不上生产速度</p><p>1、上下游能力不匹配</p><p>2、实时性要求较高，延迟造成堆积</p><p>长轮询PULL模式</p><p>1、消息拉取：批量拉取，缓存到本地缓存队列</p><p>2、消息消费：取决于消费并发、消费耗时度</p><p>本地缓存队列达到上限，停止从服务端拉取消息</p><h3 id="消费耗时的深入分析"><a href="#消费耗时的深入分析" class="headerlink" title="消费耗时的深入分析"></a>消费耗时的深入分析</h3><p>主要耗时：外部IO代码</p><p>1、mysql 、redis访问</p><p>2、下游系统调用:dubbo的RPC远程调用、springcloud的http接口调用</p><p>下游系统服务异常等原因</p><p>消息堆积——消息消费——消息耗时——外部IO——下游DB、RPC、http调用——服务异常、容量限制——网络宽带等</p><h3 id="消息并发度的深入分析"><a href="#消息并发度的深入分析" class="headerlink" title="消息并发度的深入分析"></a>消息并发度的深入分析</h3><p>普通消息 并发度 = 单节点线程数 * 节点数（consumer）</p><p>顺序消息：topic的queue分区数量</p><p>全局顺序消息</p><p>分区顺序消息</p><p>单机线程数的计算</p><h3 id="避免消息堆积与消费延迟"><a href="#避免消息堆积与消费延迟" class="headerlink" title="避免消息堆积与消费延迟"></a>避免消息堆积与消费延迟</h3><p>消费耗时</p><p>1、避免循环、递归</p><p>2、IO操作是否可以本地缓存</p><p>3、是否可以异步化处理</p><p>设置消费并发度</p><h2 id="消息的清理"><a href="#消息的清理" class="headerlink" title="消息的清理"></a>消息的清理</h2><p>以commitlog为单位进行清理</p><p>文件过期、磁盘占用率</p><h1 id="4、RocketMQ的应用"><a href="#4、RocketMQ的应用" class="headerlink" title="4、RocketMQ的应用"></a>4、RocketMQ的应用</h1><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>同步发送消息：收到ack后继续发送</p><p>1、创建生产者、group名称</p><p>2、Nameserver配置</p><p>3、开启生产者，发送消息</p><p>4、关闭生产者</p><p>SendResult：状态、msgid</p><p>异步发送消息：无需等待mq的ack消息，发送的回调接口异步响应</p><p>指定回调函数</p><p>单向发送消息：不接收ack</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220358071.png" alt="image-20220127220358071"></p><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>顺序消息：</p><p>严格按发送顺序进行消费——只有一条queue——一个消费者消费</p><p>相同订单号消息放到同一queue中</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220514365.png" alt="image-20220127220514365"></p><h3 id="消息有序性的分类"><a href="#消息有序性的分类" class="headerlink" title="消息有序性的分类"></a>消息有序性的分类</h3><p>全局有序：只有一个queue</p><p>分区有序</p><p>生产者可以指定queue选择器</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220623422.png" alt="image-20220127220623422"></p><h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>指定时长后才可被处理：实现定时任务</p><p>发送延迟消息：过时且判断未支付，放回票池</p><h3 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220640775.png" alt="image-20220127220640775"></p><p>1、先发给延迟topic延迟队列</p><p>2、根据定时管理器，时间到了——发送给commitlog——正常消息</p><p>写入commitqueue</p><p>原本Tage的hashcode改为消息投递时间（定时结束时间）</p><h3 id="再次投递"><a href="#再次投递" class="headerlink" title="再次投递"></a>再次投递</h3><p>1、定时管理器中有相应timertask——负责消息消费和投递</p><p>2、检测相应queue中第一条消息是否到期</p><p>3、若到期，投递</p><p>管理器作为生产者，重新写入commitlog</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220802767.png" alt="image-20220127220802767"></p><p>1、TM向TC发指令，开启全局事务</p><p>2、工行给TC发送事务消息M</p><p>3、TC给broker发送半事务消息（预提交）</p><p>4、Broker预提交返回执行结果</p><p>（1）失败——TC——TM，全局事务结束</p><p>5、成功——调用——预扣款——返回执行结果（本地事务）——TC——TM</p><p>（1）预扣款成功——commit——TC——broker（branch commit）——M可被建行看到</p><p>（2）预扣款失败——rollback——TC——broker（branch rollback）</p><h3 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h3><p>事务消息</p><p>半事务消息：暂不能被消费者看到</p><p>本地事务状态：生产者回调操作执行的结果——TC——TM——全局事务确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127220933007.png" alt="image-20220127220933007"></p><p>消息回查：重新查看本地事务的执行状态</p><p>（1）状态（UNKNOWN）</p><p>（2）TC未收到TM的最终全局事务确认指令</p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>XA：分布式事务处理模式</p><p>三剑客</p><p>（1）TC：事务协调者（broker）维护全局事务</p><p>（2）TM：事务管理器（生产者）全局事务发起者</p><p>（3）RM：资源管理器（生产者、broker）报告事务状态</p><p>架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221048552.png" alt="image-20220127221048552"></p><p>1、TM向TC发指令开启全局事务</p><p>2、RM向TC注册分支事务，TC——RM——预执行</p><p>3、RM执行结果返回，TC汇总结果——TM</p><p>（1）global commit——TC——RM</p><p>（2）Global rollback——TC——RM</p><p>事务消息：同步的，先broker再生产者</p><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>Topic、刷盘策略一样</p><p>不能是延时、事务消息</p><p>消息——字符串：topic、body、日志、properties相关属性</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221147787.png" alt="image-20220127221147787"></p><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>默认一次拉取32条消息</p><p>默认最大一次消费32条</p><p>分割器</p><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>tag过滤</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220127221233544.png" alt="image-20220127221233544"></p><p>SQL过滤：Properties中的属性，支持运算符</p><h2 id="消息重试机制"><a href="#消息重试机制" class="headerlink" title="消息重试机制"></a>消息重试机制</h2><h3 id="发送-1"><a href="#发送-1" class="headerlink" title="发送"></a>发送</h3><p>1、同步异步会重试，单向无法重试（只管发送）</p><p>2、顺序消息没有重试</p><p>3、可能消息重复、重复消息（负载变化、网络原因）</p><p>4、发送重试策略：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</p><p>同步发送失败</p><p>失败隔离：选择不同broker</p><p>异步发送失败</p><p>消息刷盘失败策略：刷盘失败，默认不会发送到其他broker</p><h3 id="消费-1"><a href="#消费-1" class="headerlink" title="消费"></a>消费</h3><p>顺序消息消费重试：不断重试直至消费成功</p><p>广播消费：消费失败——无消费重试</p><p>若重复完仍然失败——死信队列</p><p>需要重试消费的消息——&gt;重试队列（基于延时消息实现）</p><p>消息监听接口配置</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列：处理异常消息</p><p>详见RabbitMQ</p>]]></content>
    
    
    <summary type="html">RocketMQ</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="RocketMQ" scheme="https://fireonice.github.io/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://fireonice.github.io/2022/01/25/RabbitMQ/"/>
    <id>https://fireonice.github.io/2022/01/25/RabbitMQ/</id>
    <published>2022-01-25T15:05:01.328Z</published>
    <updated>2022-02-05T14:15:38.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><p>消息队列</p><p>流量削峰</p><p>应用解耦：上游只需发送消息</p><p>异步处理：异步处理回调消息</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><p>生产者、交换机、队列、消费者</p><h2 id="六大核心模式"><a href="#六大核心模式" class="headerlink" title="六大核心模式"></a>六大核心模式</h2><p>简单、工作队列、发布订阅、路由、主题、发布确认</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223147422.png" alt="image-20220125223147422"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>Broker</strong></p><p><strong>Virtual host</strong></p><p><strong>Connection</strong></p><p><strong>Channel</strong></p><p><strong>Exchange</strong></p><p><strong>Queue</strong></p><p><strong>Binding</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125223250580.png" alt="image-20220125223250580"></p><h1 id="2、核心"><a href="#2、核心" class="headerlink" title="2、核心"></a>2、核心</h1><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><strong>轮询</strong>分发消息</p><p>消息应答：消费者是否处理消息</p><p>自动应答、手动应答（批量应答）</p><p>消息自动重新入队</p><p>rabbitmq持久化：队列持久化、消息持久化</p><p>不公平分发</p><p>预取值：通道中堆积消息个数</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>单个确认发布</p><p>批量确认发布</p><p>异步确认发布：异步通知——交换机确认收到、未确认收到</p><p>并发链路式队列——发消息和监听线程之间传递消息——本质：map</p><p>1、发送消息时进记录队列</p><p>2、确认回调再删除</p><p>未删除的——未确认消息</p><p>跳表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224155047.png" alt="image-20220125224155047"></p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224048175.png" alt="image-20220125224048175"></p><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><p>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p><p>无名 exchange</p><p>临时队列</p><p>bindings</p><h3 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h3><p>广播：路由key为空</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224517818.png" alt="image-20220125224517818"></p><h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>发送路由key对应队列——无论队列个数</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224644373.png" alt="image-20220125224644373"></p><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p>没有*和#：fanout、direct模式</p><p>*(星号)可以代替一个单词</p><p>#(井号)可以替代零个或多个单词</p><h1 id="3、高级"><a href="#3、高级" class="headerlink" title="3、高级"></a>3、高级</h1><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>发送异常消息——进入死信队列</p><p>死信队列的来源：</p><p>消息 TTL 过期</p><p>队列达到最大长度(队列满了，无法再添加数据到 mq 中)</p><p>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125224938734.png" alt="image-20220125224938734"></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延迟队列——消息过期进入死信队列</p><p>存放需要在指定时间被处理的元素的队列</p><p>应用场景</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225016545.png" alt="image-20220125225016545"></p><p>缺陷：ttl不灵活</p><h3 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h3><p>QC队列不设置过期时间，由生产者设置ttl</p><p>缺陷：队列FIFO</p><h3 id="基于插件优化"><a href="#基于插件优化" class="headerlink" title="基于插件优化"></a>基于插件优化</h3><p>基于插件的交换机：在交换机处延迟</p><p>延迟交换机：类型、延迟类型（直接：路由key固定）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225256329.png" alt="image-20220125225256329"></p><p>其他延时队列：</p><p>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz，或者利用 kafka 的时间轮。RabbitMQ安全，完善。</p><h2 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h2><h3 id="交换机回调"><a href="#交换机回调" class="headerlink" title="交换机回调"></a>交换机回调</h3><p>交换机确认消息是否收到</p><p>写回调方法、注入</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125225816018.png" alt="image-20220125225816018"></p><p>生产者只管给交换机消息，只接受交换机的接收结果</p><p>路由错误无法接收结果</p><h3 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h3><p>无法路由时，消息回退给交换机，通知生产者</p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>无法投递的消息给备份交换机</p><p>没有什么是加一层解决不了的</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230021103.png" alt="image-20220125230021103"></p><p>备份优先级更高</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等性：重复提交</p><p>消费者ack中断，造成重新消费</p><p>解决思路：生成全局唯一id，消费之前判断是否被消费过</p><p>1、唯一ID + 指纹码机制（数据库）</p><p>2、Redis原子性：利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>设置优先级参数</p><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><p>消息存到磁盘中，消费者从磁盘取</p><p>内存占比非常小，取消息慢</p><h1 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h1><h2 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125221757500.png" alt="image-20220125221757500"></p><h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125222245390.png" alt="image-20220125222245390"></p><h2 id="高负载均衡"><a href="#高负载均衡" class="headerlink" title="高负载均衡"></a>高负载均衡</h2><p><strong>nginx、gateway</strong>、Haproxy等集群，进行反向代理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220125230327710.png" alt="image-20220125230327710"></p><p>以下暂用不到</p><h2 id="Shovel集群"><a href="#Shovel集群" class="headerlink" title="Shovel集群"></a>Shovel集群</h2><p>远程同步</p><h2 id="Federation-联邦集群"><a href="#Federation-联邦集群" class="headerlink" title="Federation 联邦集群"></a>Federation 联邦集群</h2><p>Federation Exchange、Federation Queue</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/acae23ba5952abdce66bb65e8b00a5a0.png" alt="img"></p>]]></content>
    
    
    <summary type="html">RabbitMQ</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="RabbitMQ" scheme="https://fireonice.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ</title>
    <link href="https://fireonice.github.io/2022/01/24/ActiveMQ/"/>
    <id>https://fireonice.github.io/2022/01/24/ActiveMQ/</id>
    <published>2022-01-24T14:14:42.140Z</published>
    <updated>2022-02-05T14:15:21.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221656632.png" alt="image-20220124221656632"></p><p>解耦、异步、削峰</p><p>分布式系统</p><p>只要消息发送，尽量异步</p><p>只要解耦，尽量引入消息中间件</p><h2 id="2、编码"><a href="#2、编码" class="headerlink" title="2、编码"></a>2、编码</h2><p>JMS编码架构</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124221810182.png" alt="image-20220124221810182"></p><p>原生API：</p><p>生产者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息生产者</p><p>消息生产者发送消息</p><p>（1）创建消息</p><p>（2）通过生产者发送</p><p>关闭资源（倒序：生产者、session、连接）</p><p>消费者：</p><p>连接工厂——获取连接——创建会话session</p><p>创建目的地（队列、主题）——创建消息消费者</p><p>消费生产者接收消息——接收消息（一直型、定时型）、消息类型要一致</p><p>关闭资源（倒序：消费者、session、连接）</p><p>1、receive</p><p>2、监听</p><p>队列同时监听：轮询</p><p>主题：先订阅再有生产消息</p><h2 id="3、JMS"><a href="#3、JMS" class="headerlink" title="3、JMS"></a>3、JMS</h2><p>JavaEE</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222038405.png" alt="image-20220124222038405"></p><p>JMS：java消息服务</p><p>消息头</p><p>消息体</p><p>消息属性</p><p>可靠性：持久化、事务、签收、集群</p><h2 id="4、Broker"><a href="#4、Broker" class="headerlink" title="4、Broker"></a>4、Broker</h2><h2 id="5、spring-boot整合"><a href="#5、spring-boot整合" class="headerlink" title="5、spring boot整合"></a>5、spring boot整合</h2><p>间隔定投</p><p>注解监听</p><h2 id="6、传输协议"><a href="#6、传输协议" class="headerlink" title="6、传输协议"></a>6、传输协议</h2><p>种类</p><p>NIO + 多协议</p><h2 id="7、消息存储和持久化"><a href="#7、消息存储和持久化" class="headerlink" title="7、消息存储和持久化"></a>7、消息存储和持久化</h2><p>AMQ</p><p>KahaDB：事务日志 + 索引文件</p><p>Db.log：存储消息、Db.data：B树索引、Lock：文件锁</p><p>LevelDB：基于文件的本地数据库：redis aof</p><p>JDBC + Mysql：</p><p>建库，自动建表：消息表、订阅关系表、记录master表</p><p>JDBC With Journal：</p><p>存到高速缓存日志，减少数据库压力</p><h2 id="8、多节点集群"><a href="#8、多节点集群" class="headerlink" title="8、多节点集群"></a>8、多节点集群</h2><p>Zookeeper和Replicated LevelDB集群</p><p>原理：对外暴露master</p><p>主从复制 + Zookeeper集群</p><p>已被舍弃</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124222731107.png" alt="image-20220124222731107"></p><h2 id="9、高级特性、面试考点"><a href="#9、高级特性、面试考点" class="headerlink" title="9、高级特性、面试考点"></a>9、高级特性、面试考点</h2><p>异步投递：</p><p>发送是否成功：写回调函数：成功、失败的信息</p><p>延时投递和定时投递：消息头属性中设置</p><p>分发策略</p><p>消息重试机制：消息侧回滚、消费侧没有commit等</p><p>有毒消息：重发超过6次，放到DLQ（死信队列）</p><p>死信队列：查看出错消息，人工干预修复，可自定义</p><p>防止重复调用，幂等性：数据库主键、redis key</p>]]></content>
    
    
    <summary type="html">ActiveMQ</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="ActiveMQ" scheme="https://fireonice.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security</title>
    <link href="https://fireonice.github.io/2022/01/24/Spring%20Security/"/>
    <id>https://fireonice.github.io/2022/01/24/Spring%20Security/</id>
    <published>2022-01-24T14:00:07.512Z</published>
    <updated>2022-02-05T14:15:47.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h2><p>认证</p><p>授权</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220153579.png" alt="image-20220124220153579"></p><h2 id="2、web权限"><a href="#2、web权限" class="headerlink" title="2、web权限"></a>2、web权限</h2><p>查询数据库认证</p><p>自定义登录页面</p><p>方法注解</p><p>注销</p><p>原理分析</p><p>CSRF</p><h2 id="3、微服务权限"><a href="#3、微服务权限" class="headerlink" title="3、微服务权限"></a>3、微服务权限</h2><p>流程</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220433500.png" alt="image-20220124220433500"></p><p>数据库分表</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220446710.png" alt="image-20220124220446710"></p><p>JWT：JWT 头、内容、签名哈希</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124220917745.png" alt="image-20220124220917745"></p><h2 id="4、源码解析"><a href="#4、源码解析" class="headerlink" title="4、源码解析"></a>4、源码解析</h2><p><strong>Spring Security</strong> 采取<strong>过滤链</strong>实现认证与授权</p><p>认证流程</p><p>权限访问流程</p><p>请求间共享认证信息</p>]]></content>
    
    
    <summary type="html">Spring Security</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="Spring Security" scheme="https://fireonice.github.io/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="https://fireonice.github.io/2022/01/24/nginx/"/>
    <id>https://fireonice.github.io/2022/01/24/nginx/</id>
    <published>2022-01-24T13:49:09.621Z</published>
    <updated>2022-02-05T14:15:35.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>nginx</p><p>正向代理</p><p>反向代理</p><p>负载均衡</p><p>动静分离</p><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>高可用集群（主从模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215235206.png" alt="image-20220124215235206"></p><p>高可用集群（双主模式）</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124215307904.png" alt="image-20220124215307904"></p><h2 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h2><p><img src="https://img-blog.csdnimg.cn/20191103213303224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hcml0aC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="Nginx 整体架构"></p>]]></content>
    
    
    <summary type="html">nginx</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="nginx" scheme="https://fireonice.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="https://fireonice.github.io/2022/01/24/zookeeper/"/>
    <id>https://fireonice.github.io/2022/01/24/zookeeper/</id>
    <published>2022-01-24T13:31:15.600Z</published>
    <updated>2022-02-05T14:15:52.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、入门"><a href="#1、入门" class="headerlink" title="1、入门"></a>1、入门</h2><p>概述：工作机制</p><p>数据结构：ZNode 树型文件系统</p><p>统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下</p><p>线、软负载均衡等</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><h2 id="3、集群"><a href="#3、集群" class="headerlink" title="3、集群"></a>3、集群</h2><p>选举机制：</p><p>第一次启动</p><p>非第一次启动：任期id——事务id——id</p><p>节点类型：</p><p>持久、短暂、有序号、无序号</p><p>监听器</p><p>写数据原理：</p><p>发给leader</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213707456.png" alt="image-20220124213707456"></p><p>发给follower</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213720276.png" alt="image-20220124213720276"></p><h2 id="4、案例"><a href="#4、案例" class="headerlink" title="4、案例"></a>4、案例</h2><p>服务器动态上下线</p><p>分布式锁</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124213847011.png" alt="image-20220124213847011"></p><p>Curator框架实现分布式锁</p><h2 id="5、源码"><a href="#5、源码" class="headerlink" title="5、源码"></a>5、源码</h2><p>选举机制：第一次、非第一次</p><p>分布式一致性：</p><p>Paxos算法</p><p>ZAB协议：消息广播、崩溃恢复</p><p>异常发生——leader选举 + 数据恢复</p><p>数据恢复——一个follower所有事务提交之后才变为follower</p><p>CAP理论：保证CP</p><p>持久化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214406672.png" alt="image-20220124214406672"></p><p>序列化源码</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214429678.png" alt="image-20220124214429678"></p><p>服务端初始化源码-启动脚本</p><p>初始化-解析参数</p><p>初始化-过期快照删除</p><p>初始化-通信初始化</p><p>服务端加载数据源码</p><p>选举-选举准备</p><p>选举-选举执行</p><p>Follower 和 Leader 状态同步源码</p><p>状态同步细节</p><p>Leader启动</p><p>Follower启动</p><p>客户端启动</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124214747431.png" alt="image-20220124214747431"></p><p>选举</p>]]></content>
    
    
    <summary type="html">zookeeper</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="zookeeper" scheme="https://fireonice.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>dubbo</title>
    <link href="https://fireonice.github.io/2022/01/24/dubbo/"/>
    <id>https://fireonice.github.io/2022/01/24/dubbo/</id>
    <published>2022-01-24T13:23:46.178Z</published>
    <updated>2022-02-05T14:15:27.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>分布式系统演变</p><p>RPC原理</p><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212540495.png" alt="image-20220124212540495"></p><p>dubbo核心原理</p><p>监控中心</p><h2 id="2、dubbo配置"><a href="#2、dubbo配置" class="headerlink" title="2、dubbo配置"></a>2、dubbo配置</h2><h2 id="3、高可用"><a href="#3、高可用" class="headerlink" title="3、高可用"></a>3、高可用</h2><p>zookeeper</p><p>集群负载均衡</p><p>hystrix、服务熔断、服务降级</p><h2 id="4、原理"><a href="#4、原理" class="headerlink" title="4、原理"></a>4、原理</h2><h3 id="RPC原理："><a href="#RPC原理：" class="headerlink" title="RPC原理："></a>RPC原理：</h3><p>一次完整的RPC调用流程（同步调用，异步另说）如下： </p><p><strong>1）服务消费方（client）调用以本地调用方式调用服务；</strong> </p><p>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p><p>3）client stub找到服务地址，并将消息发送到服务端； </p><p>4）server stub收到消息后进行解码； </p><p>5）server stub根据解码结果调用本地的服务； </p><p>6）本地服务执行并将结果返回给server stub； </p><p>7）server stub将返回结果打包成消息并发送至消费方； </p><p>8）client stub接收到消息，并进行解码； </p><p><strong>9）服务消费方得到最终结果。</strong></p><p>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h3 id="netty通信原理"><a href="#netty通信原理" class="headerlink" title="netty通信原理"></a>netty通信原理</h3><p>BIO</p><p>NIO</p><h3 id="dubbo原理"><a href="#dubbo原理" class="headerlink" title="dubbo原理"></a>dubbo原理</h3><p><img src="https://cdn.jsdelivr.net/gh/fireonice/picgo/img/image-20220124212904106.png" alt="image-20220124212904106"></p><p>框架设计</p><p>启动解析、加载配置信息</p><p>服务暴露</p><p>服务引用</p><p>服务调用</p>]]></content>
    
    
    <summary type="html">dubbo</summary>
    
    
    
    <category term="微服务核心" scheme="https://fireonice.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83/"/>
    
    
    <category term="dubbo" scheme="https://fireonice.github.io/tags/dubbo/"/>
    
  </entry>
  
</feed>
